module.exports = {

"[project]/node_modules/@genkit-ai/google-cloud/lib/auth.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var auth_exports = {};
__export(auth_exports, {
    credentialsFromEnvironment: ()=>credentialsFromEnvironment,
    resolveCurrentPrincipal: ()=>resolveCurrentPrincipal
});
module.exports = __toCommonJS(auth_exports);
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_google_auth_library = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-rsc] (ecmascript)");
async function credentialsFromEnvironment() {
    let authClient;
    const options = {};
    if (process.env.GCLOUD_SERVICE_ACCOUNT_CREDS) {
        import_logging.logger.debug("Retrieving credentials from GCLOUD_SERVICE_ACCOUNT_CREDS");
        const serviceAccountCreds = JSON.parse(process.env.GCLOUD_SERVICE_ACCOUNT_CREDS);
        const authOptions = {
            credentials: serviceAccountCreds
        };
        authClient = new import_google_auth_library.GoogleAuth(authOptions);
        options.credentials = await authClient.getCredentials();
    } else {
        authClient = new import_google_auth_library.GoogleAuth();
    }
    try {
        const projectId = await authClient.getProjectId();
        if (projectId && projectId.length > 0) {
            options.projectId = projectId;
        }
    } catch (error) {
        import_logging.logger.warn(error);
    }
    return options;
}
async function resolveCurrentPrincipal() {
    const envCredentials = await credentialsFromEnvironment();
    let adcCredentials = {};
    try {
        adcCredentials = await import_google_auth_library.auth.getCredentials();
    } catch (e) {
        import_logging.logger.debug("Could not retrieve client_email from ADC.");
    }
    const serviceAccountEmail = envCredentials.credentials?.client_email ?? adcCredentials.client_email;
    return {
        projectId: envCredentials.projectId,
        serviceAccountEmail
    };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    credentialsFromEnvironment,
    resolveCurrentPrincipal
}); //# sourceMappingURL=auth.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var utils_exports = {};
__export(utils_exports, {
    createCommonLogAttributes: ()=>createCommonLogAttributes,
    extractErrorMessage: ()=>extractErrorMessage,
    extractErrorName: ()=>extractErrorName,
    extractErrorStack: ()=>extractErrorStack,
    extractOuterFeatureNameFromPath: ()=>extractOuterFeatureNameFromPath,
    extractOuterFlowNameFromPath: ()=>extractOuterFlowNameFromPath,
    loggingDenied: ()=>loggingDenied,
    loggingDeniedHelpText: ()=>loggingDeniedHelpText,
    metricsDenied: ()=>metricsDenied,
    metricsDeniedHelpText: ()=>metricsDeniedHelpText,
    permissionDeniedHelpText: ()=>permissionDeniedHelpText,
    requestDenied: ()=>requestDenied,
    tracingDenied: ()=>tracingDenied,
    tracingDeniedHelpText: ()=>tracingDeniedHelpText,
    truncate: ()=>truncate,
    truncatePath: ()=>truncatePath
});
module.exports = __toCommonJS(utils_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_auth = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/auth.js [app-rsc] (ecmascript)");
const MAX_LOG_CONTENT_CHARS = 128e3;
const MAX_PATH_CHARS = 4096;
function extractOuterFlowNameFromPath(path) {
    if (!path || path === "<unknown>") {
        return "<unknown>";
    }
    const flowName = path.match("/{(.+),t:flow}+");
    return flowName ? flowName[1] : "<unknown>";
}
function truncate(text, limit = MAX_LOG_CONTENT_CHARS) {
    return text ? text.substring(0, limit) : text;
}
function truncatePath(path) {
    return truncate(path, MAX_PATH_CHARS);
}
function extractOuterFeatureNameFromPath(path) {
    if (!path || path === "<unknown>") {
        return "<unknown>";
    }
    const first = path.split("/")[1];
    const featureName = first?.match("{(.+),t:(flow|action|prompt|dotprompt|helper)");
    return featureName ? featureName[1] : "<unknown>";
}
function extractErrorName(events) {
    return events.filter((event)=>event.name === "exception").map((event)=>{
        const attributes = event.attributes;
        return attributes ? truncate(attributes["exception.type"], 1024) : "<unknown>";
    }).at(0);
}
function extractErrorMessage(events) {
    return events.filter((event)=>event.name === "exception").map((event)=>{
        const attributes = event.attributes;
        return attributes ? truncate(attributes["exception.message"], 4096) : "<unknown>";
    }).at(0);
}
function extractErrorStack(events) {
    return events.filter((event)=>event.name === "exception").map((event)=>{
        const attributes = event.attributes;
        return attributes ? truncate(attributes["exception.stacktrace"], 32768) : "<unknown>";
    }).at(0);
}
function createCommonLogAttributes(span, projectId) {
    const spanContext = span.spanContext();
    const isSampled = !!(spanContext.traceFlags & import_api.TraceFlags.SAMPLED);
    return {
        "logging.googleapis.com/spanId": spanContext.spanId,
        "logging.googleapis.com/trace": `projects/${projectId}/traces/${spanContext.traceId}`,
        "logging.googleapis.com/trace_sampled": isSampled ? "1" : "0"
    };
}
function requestDenied(err) {
    return err.code === 7;
}
function loggingDenied(err) {
    return requestDenied(err) && err.statusDetails?.some((details)=>{
        return details?.metadata?.permission === "logging.logEntries.create";
    });
}
function tracingDenied(err) {
    return requestDenied(err);
}
function metricsDenied(err) {
    return requestDenied(err);
}
async function permissionDeniedHelpText(role) {
    const principal = await (0, import_auth.resolveCurrentPrincipal)();
    return `Add the role '${role}' to your Service Account in the IAM & Admin page on the Google Cloud console, or use the following command:

gcloud projects add-iam-policy-binding ${principal.projectId ?? "${PROJECT_ID}"} \\
    --member=serviceAccount:${principal.serviceAccountEmail || "${SERVICE_ACCT}"} \\
    --role=${role}`;
}
async function loggingDeniedHelpText() {
    return permissionDeniedHelpText("roles/logging.logWriter");
}
async function tracingDeniedHelpText() {
    return permissionDeniedHelpText("roles/cloudtrace.agent");
}
async function metricsDeniedHelpText() {
    return permissionDeniedHelpText("roles/monitoring.metricWriter");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    createCommonLogAttributes,
    extractErrorMessage,
    extractErrorName,
    extractErrorStack,
    extractOuterFeatureNameFromPath,
    extractOuterFlowNameFromPath,
    loggingDenied,
    loggingDeniedHelpText,
    metricsDenied,
    metricsDeniedHelpText,
    permissionDeniedHelpText,
    requestDenied,
    tracingDenied,
    tracingDeniedHelpText,
    truncate,
    truncatePath
}); //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/gcpLogger.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var gcpLogger_exports = {};
__export(gcpLogger_exports, {
    GcpLogger: ()=>GcpLogger,
    __addTransportStreamForTesting: ()=>__addTransportStreamForTesting,
    __useJsonFormatForTesting: ()=>__useJsonFormatForTesting
});
module.exports = __toCommonJS(gcpLogger_exports);
var import_logging_winston = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
let additionalStream;
let useJsonFormatOverride = false;
class GcpLogger {
    constructor(config){
        this.config = config;
    }
    async getLogger(env) {
        const winston = await __turbopack_context__.r("[project]/node_modules/winston/lib/winston.js [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i);
        const format = useJsonFormatOverride || this.shouldExport(env) ? {
            format: winston.format.json()
        } : {
            format: winston.format.printf((info)=>{
                return `[${info.level}] ${info.message}`;
            })
        };
        const transports = [];
        transports.push(this.shouldExport(env) ? new import_logging_winston.LoggingWinston({
            labels: {
                module: "genkit"
            },
            prefix: "genkit",
            logName: "genkit_log",
            projectId: this.config.projectId,
            credentials: this.config.credentials,
            autoRetry: true,
            defaultCallback: await this.getErrorHandler()
        }) : new winston.transports.Console());
        if (additionalStream) {
            transports.push(new winston.transports.Stream({
                stream: additionalStream
            }));
        }
        return winston.createLogger({
            transports,
            ...format,
            exceptionHandlers: [
                new winston.transports.Console()
            ]
        });
    }
    async getErrorHandler() {
        let instructionsLogged = false;
        const helpInstructions = await (0, import_utils.loggingDeniedHelpText)();
        return async (err)=>{
            const defaultLogger = import_logging.logger.defaultLogger;
            if (err && (0, import_utils.loggingDenied)(err)) {
                if (!instructionsLogged) {
                    instructionsLogged = true;
                    defaultLogger.error(`Unable to send logs to Google Cloud: ${err.message}

${helpInstructions}
`);
                }
            } else if (err) {
                defaultLogger.error(`Unable to send logs to Google Cloud: ${err}`);
            }
            if (err) {
                import_logging.logger.init(await new GcpLogger(this.config).getLogger((0, import_genkit.getCurrentEnv)()));
                defaultLogger.info("Initialized a new GcpLogger.");
            }
        };
    }
    shouldExport(env) {
        return this.config.export;
    }
}
function __addTransportStreamForTesting(stream) {
    additionalStream = stream;
}
function __useJsonFormatForTesting() {
    useJsonFormatOverride = true;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GcpLogger,
    __addTransportStreamForTesting,
    __useJsonFormatForTesting
}); //# sourceMappingURL=gcpLogger.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/action.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var action_exports = {};
__export(action_exports, {
    actionTelemetry: ()=>actionTelemetry
});
module.exports = __toCommonJS(action_exports);
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/genkit/lib/tracing.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
class ActionTelemetry {
    tick(span, logInputAndOutput, projectId) {
        if (!logInputAndOutput) {
            return;
        }
        const attributes = span.attributes;
        const actionName = attributes["genkit:name"] || "<unknown>";
        const subtype = attributes["genkit:metadata:subtype"];
        if (subtype === "tool" || actionName === "generate") {
            const path = attributes["genkit:path"] || "<unknown>";
            const input = (0, import_utils.truncate)(attributes["genkit:input"]);
            const output = (0, import_utils.truncate)(attributes["genkit:output"]);
            const sessionId = attributes["genkit:sessionId"];
            const threadName = attributes["genkit:threadName"];
            let featureName = (0, import_utils.extractOuterFeatureNameFromPath)(path);
            if (!featureName || featureName === "<unknown>") {
                featureName = actionName;
            }
            if (input) {
                this.writeLog(span, "Input", featureName, path, input, projectId, sessionId, threadName);
            }
            if (output) {
                this.writeLog(span, "Output", featureName, path, output, projectId, sessionId, threadName);
            }
        }
    }
    writeLog(span, tag, featureName, qualifiedPath, content, projectId, sessionId, threadName) {
        const path = (0, import_utils.truncatePath)((0, import_tracing.toDisplayPath)(qualifiedPath));
        const sharedMetadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            path,
            qualifiedPath,
            featureName,
            sessionId,
            threadName
        };
        import_logging.logger.logStructured(`${tag}[${path}, ${featureName}]`, {
            ...sharedMetadata,
            content
        });
    }
}
const actionTelemetry = new ActionTelemetry();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    actionTelemetry
}); //# sourceMappingURL=action.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/metrics.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var metrics_exports = {};
__export(metrics_exports, {
    METER_NAME: ()=>METER_NAME,
    METRIC_NAME_PREFIX: ()=>METRIC_NAME_PREFIX,
    MetricCounter: ()=>MetricCounter,
    MetricHistogram: ()=>MetricHistogram,
    internalMetricNamespaceWrap: ()=>internalMetricNamespaceWrap
});
module.exports = __toCommonJS(metrics_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
const METER_NAME = "genkit";
const METRIC_NAME_PREFIX = "genkit";
const METRIC_DIMENSION_MAX_CHARS = 256;
function internalMetricNamespaceWrap(...namespaces) {
    return [
        METRIC_NAME_PREFIX,
        ...namespaces
    ].join("/");
}
class Metric {
    createFn;
    meterName;
    metric;
    constructor(createFn, meterName = METER_NAME){
        this.meterName = meterName;
        this.createFn = createFn;
    }
    get() {
        if (!this.metric) {
            this.metric = this.createFn(import_api.metrics.getMeterProvider().getMeter(this.meterName));
        }
        return this.metric;
    }
}
class MetricCounter extends Metric {
    constructor(name, options){
        super((meter)=>meter.createCounter(name, options));
    }
    add(val, opts) {
        if (val) {
            truncateDimensions(opts);
            this.get().add(val, opts);
        }
    }
}
class MetricHistogram extends Metric {
    constructor(name, options){
        super((meter)=>meter.createHistogram(name, options));
    }
    record(val, opts) {
        if (val) {
            truncateDimensions(opts);
            this.get().record(val, opts);
        }
    }
}
function truncateDimensions(opts) {
    if (opts) {
        Object.keys(opts).forEach((k)=>{
            if (typeof opts[k] === "string") {
                opts[k] = opts[k].substring(0, METRIC_DIMENSION_MAX_CHARS);
            }
        });
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    METER_NAME,
    METRIC_NAME_PREFIX,
    MetricCounter,
    MetricHistogram,
    internalMetricNamespaceWrap
}); //# sourceMappingURL=metrics.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/engagement.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var engagement_exports = {};
__export(engagement_exports, {
    engagementTelemetry: ()=>engagementTelemetry
});
module.exports = __toCommonJS(engagement_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_metrics = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/metrics.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
class EngagementTelemetry {
    /**
   * Wraps the declared metrics in a Genkit-specific, internal namespace.
   */ _N = import_metrics.internalMetricNamespaceWrap.bind(null, "engagement");
    feedbackCounter = new import_metrics.MetricCounter(this._N("feedback"), {
        description: "Counts calls to genkit flows.",
        valueType: import_api.ValueType.INT
    });
    acceptanceCounter = new import_metrics.MetricCounter(this._N("acceptance"), {
        description: "Tracks unique flow paths per flow.",
        valueType: import_api.ValueType.INT
    });
    tick(span, logInputAndOutput, projectId) {
        const subtype = span.attributes["genkit:metadata:subtype"];
        if (subtype === "userFeedback") {
            this.writeUserFeedback(span, projectId);
            return;
        }
        if (subtype === "userAcceptance") {
            this.writeUserAcceptance(span, projectId);
            return;
        }
        import_logging.logger.warn(`Unknown user engagement subtype: ${subtype}`);
    }
    writeUserFeedback(span, projectId) {
        const attributes = span.attributes;
        const name = this.extractTraceName(attributes);
        const dimensions = {
            name,
            value: attributes["genkit:metadata:feedbackValue"],
            hasText: !!attributes["genkit:metadata:textFeedback"],
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION
        };
        this.feedbackCounter.add(1, dimensions);
        const metadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            feedbackValue: attributes["genkit:metadata:feedbackValue"]
        };
        if (attributes["genkit:metadata:textFeedback"]) {
            metadata["textFeedback"] = (0, import_utils.truncate)(attributes["genkit:metadata:textFeedback"]);
        }
        import_logging.logger.logStructured(`UserFeedback[${name}]`, metadata);
    }
    writeUserAcceptance(span, projectId) {
        const attributes = span.attributes;
        const name = this.extractTraceName(attributes);
        const dimensions = {
            name,
            value: attributes["genkit:metadata:acceptanceValue"],
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION
        };
        this.acceptanceCounter.add(1, dimensions);
        const metadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            acceptanceValue: attributes["genkit:metadata:acceptanceValue"]
        };
        import_logging.logger.logStructured(`UserAcceptance[${name}]`, metadata);
    }
    extractTraceName(attributes) {
        const path = attributes["genkit:path"];
        if (!path || path === "<unknown>") {
            return "<unknown>";
        }
        const name = path.match("/{(.+)}+");
        return name ? name[1] : "<unknown>";
    }
}
const engagementTelemetry = new EngagementTelemetry();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    engagementTelemetry
}); //# sourceMappingURL=engagement.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/feature.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var feature_exports = {};
__export(feature_exports, {
    featuresTelemetry: ()=>featuresTelemetry
});
module.exports = __toCommonJS(feature_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_core = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/genkit/lib/tracing.js [app-rsc] (ecmascript)");
var import_metrics = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/metrics.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
class FeaturesTelemetry {
    /**
   * Wraps the declared metrics in a Genkit-specific, internal namespace.
   */ _N = import_metrics.internalMetricNamespaceWrap.bind(null, "feature");
    featureCounter = new import_metrics.MetricCounter(this._N("requests"), {
        description: "Counts calls to genkit features.",
        valueType: import_api.ValueType.INT
    });
    featureLatencies = new import_metrics.MetricHistogram(this._N("latency"), {
        description: "Latencies when calling Genkit features.",
        valueType: import_api.ValueType.DOUBLE,
        unit: "ms"
    });
    tick(span, logInputAndOutput, projectId) {
        const attributes = span.attributes;
        const name = attributes["genkit:name"];
        const path = attributes["genkit:path"];
        const latencyMs = (0, import_core.hrTimeToMilliseconds)((0, import_core.hrTimeDuration)(span.startTime, span.endTime));
        const isRoot = attributes["genkit:isRoot"];
        if (!isRoot) {
            throw new import_genkit.GenkitError({
                status: "FAILED_PRECONDITION",
                message: "FeatureTelemetry tick called with non-root span."
            });
        }
        const state = attributes["genkit:state"];
        if (state === "success") {
            this.writeFeatureSuccess(name, latencyMs);
        } else if (state === "error") {
            const errorName = (0, import_utils.extractErrorName)(span.events) || "<unknown>";
            this.writeFeatureFailure(name, latencyMs, errorName);
        } else {
            import_logging.logger.warn(`Unknown state; ${state}`);
            return;
        }
        if (logInputAndOutput) {
            const input = (0, import_utils.truncate)(attributes["genkit:input"]);
            const output = (0, import_utils.truncate)(attributes["genkit:output"]);
            const sessionId = attributes["genkit:sessionId"];
            const threadName = attributes["genkit:threadName"];
            if (input) {
                this.writeLog(span, "Input", name, path, input, projectId, sessionId, threadName);
            }
            if (output) {
                this.writeLog(span, "Output", name, path, output, projectId, sessionId, threadName);
            }
        }
    }
    writeFeatureSuccess(featureName, latencyMs) {
        const dimensions = {
            name: featureName,
            status: "success",
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION
        };
        this.featureCounter.add(1, dimensions);
        this.featureLatencies.record(latencyMs, dimensions);
    }
    writeFeatureFailure(featureName, latencyMs, errorName) {
        const dimensions = {
            name: featureName,
            status: "failure",
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION,
            error: errorName
        };
        this.featureCounter.add(1, dimensions);
        this.featureLatencies.record(latencyMs, dimensions);
    }
    writeLog(span, tag, featureName, qualifiedPath, content, projectId, sessionId, threadName) {
        const path = (0, import_utils.truncatePath)((0, import_tracing.toDisplayPath)(qualifiedPath));
        const sharedMetadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            path,
            qualifiedPath,
            featureName,
            sessionId,
            threadName
        };
        import_logging.logger.logStructured(`${tag}[${path}, ${featureName}]`, {
            ...sharedMetadata,
            content
        });
    }
}
const featuresTelemetry = new FeaturesTelemetry();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    featuresTelemetry
}); //# sourceMappingURL=feature.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/generate.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var generate_exports = {};
__export(generate_exports, {
    generateTelemetry: ()=>generateTelemetry
});
module.exports = __toCommonJS(generate_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/genkit/lib/tracing.js [app-rsc] (ecmascript)");
var import_metrics = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/metrics.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
class GenerateTelemetry {
    /**
   * Wraps the declared metrics in a Genkit-specific, internal namespace.
   */ _N = import_metrics.internalMetricNamespaceWrap.bind(null, "ai");
    actionCounter = new import_metrics.MetricCounter(this._N("generate/requests"), {
        description: "Counts calls to genkit generate actions.",
        valueType: import_api.ValueType.INT
    });
    latencies = new import_metrics.MetricHistogram(this._N("generate/latency"), {
        description: "Latencies when interacting with a Genkit model.",
        valueType: import_api.ValueType.DOUBLE,
        unit: "ms"
    });
    inputCharacters = new import_metrics.MetricCounter(this._N("generate/input/characters"), {
        description: "Counts input characters to any Genkit model.",
        valueType: import_api.ValueType.INT
    });
    inputTokens = new import_metrics.MetricCounter(this._N("generate/input/tokens"), {
        description: "Counts input tokens to a Genkit model.",
        valueType: import_api.ValueType.INT
    });
    inputImages = new import_metrics.MetricCounter(this._N("generate/input/images"), {
        description: "Counts input images to a Genkit model.",
        valueType: import_api.ValueType.INT
    });
    outputCharacters = new import_metrics.MetricCounter(this._N("generate/output/characters"), {
        description: "Counts output characters from a Genkit model.",
        valueType: import_api.ValueType.INT
    });
    outputTokens = new import_metrics.MetricCounter(this._N("generate/output/tokens"), {
        description: "Counts output tokens from a Genkit model.",
        valueType: import_api.ValueType.INT
    });
    outputImages = new import_metrics.MetricCounter(this._N("generate/output/images"), {
        description: "Count output images from a Genkit model.",
        valueType: import_api.ValueType.INT
    });
    tick(span, logInputAndOutput, projectId) {
        const attributes = span.attributes;
        const modelName = (0, import_utils.truncate)(attributes["genkit:name"], 1024);
        const path = attributes["genkit:path"] || "";
        const input = "genkit:input" in attributes ? JSON.parse(attributes["genkit:input"]) : void 0;
        const output = "genkit:output" in attributes ? JSON.parse(attributes["genkit:output"]) : void 0;
        const errName = (0, import_utils.extractErrorName)(span.events);
        let featureName = (0, import_utils.truncate)(attributes["genkit:metadata:flow:name"] || (0, import_utils.extractOuterFeatureNameFromPath)(path));
        if (!featureName || featureName === "<unknown>") {
            featureName = "generate";
        }
        const sessionId = attributes["genkit:sessionId"];
        const threadName = attributes["genkit:threadName"];
        if (input) {
            this.recordGenerateActionMetrics(modelName, featureName, path, {
                response: output,
                errName
            });
            this.recordGenerateActionConfigLogs(span, modelName, featureName, path, input, projectId, sessionId, threadName);
            if (logInputAndOutput) {
                this.recordGenerateActionInputLogs(span, modelName, featureName, path, input, projectId, sessionId, threadName);
            }
        }
        if (output && logInputAndOutput) {
            this.recordGenerateActionOutputLogs(span, modelName, featureName, path, output, projectId, sessionId, threadName);
        }
    }
    recordGenerateActionMetrics(modelName, featureName, path, opts) {
        this.doRecordGenerateActionMetrics(modelName, opts.response?.usage || {}, {
            featureName,
            path,
            latencyMs: opts.response?.latencyMs,
            errName: opts.errName,
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION
        });
    }
    recordGenerateActionConfigLogs(span, model, featureName, qualifiedPath, input, projectId, sessionId, threadName) {
        const path = (0, import_utils.truncatePath)((0, import_tracing.toDisplayPath)(qualifiedPath));
        const sharedMetadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            model,
            path,
            qualifiedPath,
            featureName,
            sessionId,
            threadName
        };
        import_logging.logger.logStructured(`Config[${path}, ${model}]`, {
            ...sharedMetadata,
            maxOutputTokens: input.config?.maxOutputTokens,
            stopSequences: input.config?.stopSequences,
            // array
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION
        });
    }
    recordGenerateActionInputLogs(span, model, featureName, qualifiedPath, input, projectId, sessionId, threadName) {
        const path = (0, import_utils.truncatePath)((0, import_tracing.toDisplayPath)(qualifiedPath));
        const sharedMetadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            model,
            path,
            qualifiedPath,
            featureName,
            sessionId,
            threadName
        };
        const messages = input.messages.length;
        input.messages.forEach((msg, msgIdx)=>{
            const parts = msg.content.length;
            msg.content.forEach((part, partIdx)=>{
                const partCounts = this.toPartCounts(partIdx, parts, msgIdx, messages);
                import_logging.logger.logStructured(`Input[${path}, ${model}] ${partCounts}`, {
                    ...sharedMetadata,
                    content: this.toPartLogContent(part),
                    role: msg.role,
                    partIndex: partIdx,
                    totalParts: parts,
                    messageIndex: msgIdx,
                    totalMessages: messages
                });
            });
        });
    }
    recordGenerateActionOutputLogs(span, model, featureName, qualifiedPath, output, projectId, sessionId, threadName) {
        const path = (0, import_utils.truncatePath)((0, import_tracing.toDisplayPath)(qualifiedPath));
        const sharedMetadata = {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            model,
            path,
            qualifiedPath,
            featureName,
            sessionId,
            threadName
        };
        const message = output.message || output.candidates?.[0]?.message;
        if (message?.content) {
            const parts = message.content.length;
            message.content.forEach((part, partIdx)=>{
                const partCounts = this.toPartCounts(partIdx, parts, 0, 1);
                const initial = output.finishMessage ? {
                    finishMessage: (0, import_utils.truncate)(output.finishMessage)
                } : {};
                import_logging.logger.logStructured(`Output[${path}, ${model}] ${partCounts}`, {
                    ...initial,
                    ...sharedMetadata,
                    content: this.toPartLogContent(part),
                    role: message.role,
                    partIndex: partIdx,
                    totalParts: parts,
                    candidateIndex: 0,
                    totalCandidates: 1,
                    messageIndex: 0,
                    finishReason: output.finishReason
                });
            });
        }
    }
    toPartCounts(partOrdinal, parts, msgOrdinal, messages) {
        if (parts > 1 && messages > 1) {
            return `(part ${this.xOfY(partOrdinal, parts)} in message ${this.xOfY(msgOrdinal, messages)})`;
        }
        if (parts > 1) {
            return `(part ${this.xOfY(partOrdinal, parts)})`;
        }
        if (messages > 1) {
            return `(message ${this.xOfY(msgOrdinal, messages)})`;
        }
        return "";
    }
    xOfY(x, y) {
        return `${x + 1} of ${y}`;
    }
    toPartLogContent(part) {
        if (part.text) {
            return (0, import_utils.truncate)(part.text);
        }
        if (part.data) {
            return (0, import_utils.truncate)(JSON.stringify(part.data));
        }
        if (part.media) {
            return this.toPartLogMedia(part);
        }
        if (part.toolRequest) {
            return this.toPartLogToolRequest(part);
        }
        if (part.toolResponse) {
            return this.toPartLogToolResponse(part);
        }
        if (part.custom) {
            return (0, import_utils.truncate)(JSON.stringify(part.custom));
        }
        return "<unknown format>";
    }
    toPartLogMedia(part) {
        if (part.media.url.startsWith("data:")) {
            const splitIdx = part.media.url.indexOf("base64,");
            if (splitIdx < 0) {
                return "<unknown media format>";
            }
            const prefix = part.media.url.substring(0, splitIdx + 7);
            const hashedContent = (0, import_crypto.createHash)("sha256").update(part.media.url.substring(splitIdx + 7)).digest("hex");
            return `${prefix}<sha256(${hashedContent})>`;
        }
        return (0, import_utils.truncate)(part.media.url);
    }
    toPartLogToolRequest(part) {
        const inputText = typeof part.toolRequest.input === "string" ? part.toolRequest.input : JSON.stringify(part.toolRequest.input);
        return (0, import_utils.truncate)(`Tool request: ${part.toolRequest.name}, ref: ${part.toolRequest.ref}, input: ${inputText}`);
    }
    toPartLogToolResponse(part) {
        const outputText = typeof part.toolResponse.output === "string" ? part.toolResponse.output : JSON.stringify(part.toolResponse.output);
        return (0, import_utils.truncate)(`Tool response: ${part.toolResponse.name}, ref: ${part.toolResponse.ref}, output: ${outputText}`);
    }
    /**
   * Records all metrics associated with performing a GenerateAction.
   */ doRecordGenerateActionMetrics(modelName, usage, dimensions) {
        const shared = {
            modelName,
            featureName: dimensions.featureName,
            path: dimensions.path,
            source: dimensions.source,
            sourceVersion: dimensions.sourceVersion,
            status: dimensions.errName ? "failure" : "success"
        };
        this.actionCounter.add(1, {
            error: dimensions.errName,
            ...shared
        });
        this.latencies.record(dimensions.latencyMs, shared);
        this.inputTokens.add(usage.inputTokens, shared);
        this.inputCharacters.add(usage.inputCharacters, shared);
        this.inputImages.add(usage.inputImages, shared);
        this.outputTokens.add(usage.outputTokens, shared);
        this.outputCharacters.add(usage.outputCharacters, shared);
        this.outputImages.add(usage.outputImages, shared);
    }
}
const generateTelemetry = new GenerateTelemetry();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    generateTelemetry
}); //# sourceMappingURL=generate.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/path.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var path_exports = {};
__export(path_exports, {
    pathsTelemetry: ()=>pathsTelemetry
});
module.exports = __toCommonJS(path_exports);
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_core = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/genkit/lib/tracing.js [app-rsc] (ecmascript)");
var import_metrics = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/metrics.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
class PathsTelemetry {
    /**
   * Wraps the declared metrics in a Genkit-specific, internal namespace.
   */ _N = import_metrics.internalMetricNamespaceWrap.bind(null, "feature");
    pathCounter = new import_metrics.MetricCounter(this._N("path/requests"), {
        description: "Tracks unique flow paths per flow.",
        valueType: import_api.ValueType.INT
    });
    pathLatencies = new import_metrics.MetricHistogram(this._N("path/latency"), {
        description: "Latencies per flow path.",
        ValueType: import_api.ValueType.DOUBLE,
        unit: "ms"
    });
    tick(span, logInputAndOutput, projectId) {
        const attributes = span.attributes;
        const path = attributes["genkit:path"];
        const isFailureSource = !!span.attributes["genkit:isFailureSource"];
        const state = attributes["genkit:state"];
        if (!path || !isFailureSource || state !== "error") {
            return;
        }
        const sessionId = attributes["genkit:sessionId"];
        const threadName = attributes["genkit:threadName"];
        const errorName = (0, import_utils.extractErrorName)(span.events) || "<unknown>";
        const errorMessage = (0, import_utils.extractErrorMessage)(span.events) || "<unknown>";
        const errorStack = (0, import_utils.extractErrorStack)(span.events) || "";
        const latency = (0, import_core.hrTimeToMilliseconds)((0, import_core.hrTimeDuration)(span.startTime, span.endTime));
        const pathDimensions = {
            featureName: (0, import_utils.extractOuterFeatureNameFromPath)(path),
            status: "failure",
            error: errorName,
            path,
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION
        };
        this.pathCounter.add(1, pathDimensions);
        this.pathLatencies.record(latency, pathDimensions);
        const displayPath = (0, import_utils.truncatePath)((0, import_tracing.toDisplayPath)(path));
        import_logging.logger.logStructuredError(`Error[${displayPath}, ${errorName}]`, {
            ...(0, import_utils.createCommonLogAttributes)(span, projectId),
            path: displayPath,
            qualifiedPath: path,
            name: errorName,
            message: errorMessage,
            stack: errorStack,
            source: "ts",
            sourceVersion: import_genkit.GENKIT_VERSION,
            sessionId,
            threadName
        });
    }
}
const pathsTelemetry = new PathsTelemetry();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    pathsTelemetry
}); //# sourceMappingURL=path.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/gcpOpenTelemetry.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var gcpOpenTelemetry_exports = {};
__export(gcpOpenTelemetry_exports, {
    GcpOpenTelemetry: ()=>GcpOpenTelemetry,
    __forceFlushSpansForTesting: ()=>__forceFlushSpansForTesting,
    __getMetricExporterForTesting: ()=>__getMetricExporterForTesting,
    __getSpanExporterForTesting: ()=>__getSpanExporterForTesting
});
module.exports = __toCommonJS(gcpOpenTelemetry_exports);
var import_opentelemetry_cloud_monitoring_exporter = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/index.js [app-rsc] (ecmascript)");
var import_opentelemetry_cloud_trace_exporter = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/index.js [app-rsc] (ecmascript)");
var import_opentelemetry_resource_util = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/index.js [app-rsc] (ecmascript)");
var import_api = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
var import_auto_instrumentations_node = __turbopack_context__.r("[project]/node_modules/@opentelemetry/auto-instrumentations-node/build/src/index.js [app-rsc] (ecmascript)");
var import_instrumentation_pino = __turbopack_context__.r("[project]/node_modules/@opentelemetry/instrumentation-pino/build/src/index.js [app-rsc] (ecmascript)");
var import_instrumentation_winston = __turbopack_context__.r("[project]/node_modules/@opentelemetry/instrumentation-winston/build/src/index.js [app-rsc] (ecmascript)");
var import_resources = __turbopack_context__.r("[project]/node_modules/@opentelemetry/resources/build/esm/index.js [app-rsc] (ecmascript)");
var import_sdk_metrics = __turbopack_context__.r("[project]/node_modules/@opentelemetry/sdk-metrics/build/esm/index.js [app-rsc] (ecmascript)");
var import_sdk_trace_base = __turbopack_context__.r("[project]/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_action = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/action.js [app-rsc] (ecmascript)");
var import_engagement = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/engagement.js [app-rsc] (ecmascript)");
var import_feature = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/feature.js [app-rsc] (ecmascript)");
var import_generate = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/generate.js [app-rsc] (ecmascript)");
var import_path = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/path.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/utils.js [app-rsc] (ecmascript)");
let metricExporter;
let spanProcessor;
let spanExporter;
class GcpOpenTelemetry {
    config;
    resource;
    constructor(config){
        this.config = config;
        this.resource = new import_resources.Resource({
            type: "global"
        }).merge(new import_opentelemetry_resource_util.GcpDetectorSync().detect());
    }
    /**
   * Log hook for writing trace and span metadata to log messages in the format
   * required by GCP.
   */ gcpTraceLogHook = (span, record)=>{
        const spanContext = span.spanContext();
        const isSampled = !!(spanContext.traceFlags & import_api.TraceFlags.SAMPLED);
        const projectId = this.config.projectId;
        record["logging.googleapis.com/trace"] ??= `projects/${projectId}/traces/${spanContext.traceId}`;
        record["logging.googleapis.com/trace_sampled"] ??= isSampled ? "1" : "0";
        record["logging.googleapis.com/spanId"] ??= spanContext.spanId;
        delete record["span_id"];
        delete record["trace_id"];
        delete record["trace_flags"];
    };
    async getConfig() {
        spanProcessor = new import_sdk_trace_base.BatchSpanProcessor(await this.createSpanExporter());
        return {
            resource: this.resource,
            spanProcessor,
            sampler: this.config.sampler,
            instrumentations: this.getInstrumentations(),
            metricReader: await this.createMetricReader()
        };
    }
    async createSpanExporter() {
        spanExporter = new AdjustingTraceExporter(this.shouldExportTraces() ? new import_opentelemetry_cloud_trace_exporter.TraceExporter({
            // provided projectId should take precedence over env vars, etc
            projectId: this.config.projectId,
            // creds for non-GCP environments, in lieu of using ADC.
            credentials: this.config.credentials
        }) : new import_sdk_trace_base.InMemorySpanExporter(), this.config.exportInputAndOutput, this.config.projectId, getErrorHandler((err)=>{
            return (0, import_utils.tracingDenied)(err);
        }, await (0, import_utils.tracingDeniedHelpText)()));
        return spanExporter;
    }
    /**
   * Creates a {MetricReader} for pushing metrics out to GCP via OpenTelemetry.
   */ async createMetricReader() {
        metricExporter = await this.buildMetricExporter();
        return new import_sdk_metrics.PeriodicExportingMetricReader({
            exportIntervalMillis: this.config.metricExportIntervalMillis,
            exportTimeoutMillis: this.config.metricExportTimeoutMillis,
            exporter: metricExporter
        });
    }
    /** Gets all open telemetry instrumentations as configured by the plugin. */ getInstrumentations() {
        let instrumentations = [];
        if (this.config.autoInstrumentation) {
            instrumentations = (0, import_auto_instrumentations_node.getNodeAutoInstrumentations)(this.config.autoInstrumentationConfig);
        }
        return instrumentations.concat(this.getDefaultLoggingInstrumentations()).concat(this.config.instrumentations ?? []);
    }
    shouldExportTraces() {
        return this.config.export && !this.config.disableTraces;
    }
    shouldExportMetrics() {
        return this.config.export && !this.config.disableMetrics;
    }
    /** Always configure the Pino and Winston instrumentations */ getDefaultLoggingInstrumentations() {
        return [
            new import_instrumentation_winston.WinstonInstrumentation({
                logHook: this.gcpTraceLogHook
            }),
            new import_instrumentation_pino.PinoInstrumentation({
                logHook: this.gcpTraceLogHook
            })
        ];
    }
    async buildMetricExporter() {
        const exporter = this.shouldExportMetrics() ? new MetricExporterWrapper({
            userAgent: {
                product: "genkit",
                version: import_genkit.GENKIT_VERSION
            },
            // provided projectId should take precedence over env vars, etc
            projectId: this.config.projectId,
            // creds for non-GCP environments, in lieu of using ADC.
            credentials: this.config.credentials
        }, getErrorHandler((err)=>{
            return (0, import_utils.metricsDenied)(err);
        }, await (0, import_utils.metricsDeniedHelpText)())) : new import_sdk_metrics.InMemoryMetricExporter(import_sdk_metrics.AggregationTemporality.DELTA);
        return exporter;
    }
}
class MetricExporterWrapper extends import_opentelemetry_cloud_monitoring_exporter.MetricExporter {
    constructor(options, errorHandler){
        super(options);
        this.errorHandler = errorHandler;
    }
    promise = new Promise((resolve)=>resolve());
    async export(metrics, resultCallback) {
        await this.promise;
        this.modifyStartTimes(metrics);
        this.promise = new Promise((resolve)=>{
            super.export(metrics, (result)=>{
                try {
                    if (this.errorHandler && result.error) {
                        this.errorHandler(result.error);
                    }
                    resultCallback(result);
                } finally{
                    resolve();
                }
            });
        });
    }
    selectAggregation(instrumentType) {
        if (instrumentType === import_sdk_metrics.InstrumentType.HISTOGRAM) {
            return new import_sdk_metrics.ExponentialHistogramAggregation();
        }
        return new import_sdk_metrics.DefaultAggregation();
    }
    selectAggregationTemporality(instrumentType) {
        return import_sdk_metrics.AggregationTemporality.DELTA;
    }
    /**
   * Modify the start times of each data point to ensure no
   * overlap with previous exports.
   *
   * Cloud metrics do not support delta metrics for custom metrics
   * and will convert any DELTA aggregations to CUMULATIVE ones on
   * export. There is implicit overlap in the start/end times that
   * the Metric reader is sending -- the end_time of the previous
   * export will become the start_time of the current export. The
   * overlap in times means that only one of those records will
   * persist and the other will be overwritten. This
   * method adds a thousandth of a second to ensure discrete export
   * timeframes.
   */ modifyStartTimes(metrics) {
        metrics.scopeMetrics.forEach((scopeMetric)=>{
            scopeMetric.metrics.forEach((metric)=>{
                metric.dataPoints.forEach((dataPoint)=>{
                    dataPoint.startTime[1] = dataPoint.startTime[1] + 1e6;
                });
            });
        });
    }
    async shutdown() {
        return await this.forceFlush();
    }
    async forceFlush() {
        await this.promise;
    }
}
class AdjustingTraceExporter {
    constructor(exporter, logInputAndOutput, projectId, errorHandler){
        this.exporter = exporter;
        this.logInputAndOutput = logInputAndOutput;
        this.projectId = projectId;
        this.errorHandler = errorHandler;
    }
    export(spans, resultCallback) {
        this.exporter?.export(this.adjust(spans), (result)=>{
            if (this.errorHandler && result.error) {
                this.errorHandler(result.error);
            }
            resultCallback(result);
        });
    }
    shutdown() {
        return this.exporter?.shutdown();
    }
    getExporter() {
        return this.exporter;
    }
    forceFlush() {
        if (this.exporter?.forceFlush) {
            return this.exporter.forceFlush();
        }
        return Promise.resolve();
    }
    adjust(spans) {
        return spans.map((span)=>{
            this.tickTelemetry(span);
            span = this.redactInputOutput(span);
            span = this.markErrorSpanAsError(span);
            span = this.markFailedSpan(span);
            span = this.markGenkitFeature(span);
            span = this.markGenkitModel(span);
            span = this.normalizeLabels(span);
            return span;
        });
    }
    tickTelemetry(span) {
        const attributes = span.attributes;
        if (!Object.keys(attributes).includes("genkit:type")) {
            return;
        }
        const type = attributes["genkit:type"];
        const subtype = attributes["genkit:metadata:subtype"];
        const isRoot = !!span.attributes["genkit:isRoot"];
        import_path.pathsTelemetry.tick(span, this.logInputAndOutput, this.projectId);
        if (isRoot) {
            import_feature.featuresTelemetry.tick(span, this.logInputAndOutput, this.projectId);
            span.attributes["genkit:rootState"] = span.attributes["genkit:state"];
        } else {
            if (type === "action" && subtype === "model") {
                import_generate.generateTelemetry.tick(span, this.logInputAndOutput, this.projectId);
            }
            if (type === "action" && subtype === "tool") {}
            if (type === "action" || type === "flow" || type == "flowStep" || type == "util") {
                import_action.actionTelemetry.tick(span, this.logInputAndOutput, this.projectId);
            }
        }
        if (type === "userEngagement") {
            import_engagement.engagementTelemetry.tick(span, this.logInputAndOutput, this.projectId);
        }
    }
    redactInputOutput(span) {
        const hasInput = "genkit:input" in span.attributes;
        const hasOutput = "genkit:output" in span.attributes;
        return !hasInput && !hasOutput ? span : {
            ...span,
            spanContext: span.spanContext,
            attributes: {
                ...span.attributes,
                "genkit:input": "<redacted>",
                "genkit:output": "<redacted>"
            }
        };
    }
    // This is a workaround for GCP Trace to mark a span with a red
    // exclamation mark indicating that it is an error.
    markErrorSpanAsError(span) {
        return span.status.code !== import_api.SpanStatusCode.ERROR ? span : {
            ...span,
            spanContext: span.spanContext,
            attributes: {
                ...span.attributes,
                "/http/status_code": "599"
            }
        };
    }
    normalizeLabels(span) {
        const normalized = {};
        for (const [key, value] of Object.entries(span.attributes)){
            normalized[key.replace(/\:/g, "/")] = value;
        }
        return {
            ...span,
            spanContext: span.spanContext,
            attributes: normalized
        };
    }
    markFailedSpan(span) {
        if (span.attributes["genkit:isFailureSource"]) {
            span.attributes["genkit:failedSpan"] = span.attributes["genkit:name"];
            span.attributes["genkit:failedPath"] = span.attributes["genkit:path"];
        }
        return span;
    }
    markGenkitFeature(span) {
        if (span.attributes["genkit:isRoot"] && !!span.attributes["genkit:name"]) {
            span.attributes["genkit:feature"] = span.attributes["genkit:name"];
        }
        return span;
    }
    markGenkitModel(span) {
        if (span.attributes["genkit:metadata:subtype"] === "model" && !!span.attributes["genkit:name"]) {
            span.attributes["genkit:model"] = span.attributes["genkit:name"];
        }
        return span;
    }
}
function getErrorHandler(shouldLogFn, helpText) {
    let instructionsLogged = false;
    return (err)=>{
        const defaultLogger = import_logging.logger.defaultLogger;
        if (err && shouldLogFn(err)) {
            if (!instructionsLogged) {
                instructionsLogged = true;
                defaultLogger.error(`Unable to send telemetry to Google Cloud: ${err.message}

${helpText}
`);
            }
        } else if (err) {
            defaultLogger.error(`Unable to send telemetry to Google Cloud: ${err}`);
        }
    };
}
function __getMetricExporterForTesting() {
    return metricExporter;
}
function __getSpanExporterForTesting() {
    return spanExporter.getExporter();
}
function __forceFlushSpansForTesting() {
    spanProcessor.forceFlush();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GcpOpenTelemetry,
    __forceFlushSpansForTesting,
    __getMetricExporterForTesting,
    __getSpanExporterForTesting
}); //# sourceMappingURL=gcpOpenTelemetry.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/defaults.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var defaults_exports = {};
__export(defaults_exports, {
    TelemetryConfigs: ()=>TelemetryConfigs
});
module.exports = __toCommonJS(defaults_exports);
var import_sdk_trace_base = __turbopack_context__.r("[project]/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
const TelemetryConfigs = {
    defaults: (overrides = {})=>{
        return (0, import_genkit.isDevEnv)() ? TelemetryConfigs.developmentDefaults(overrides) : TelemetryConfigs.productionDefaults(overrides);
    },
    developmentDefaults: (overrides = {})=>{
        const defaults = {
            sampler: new import_sdk_trace_base.AlwaysOnSampler(),
            autoInstrumentation: true,
            autoInstrumentationConfig: {
                "@opentelemetry/instrumentation-dns": {
                    enabled: false
                }
            },
            instrumentations: [],
            metricExportIntervalMillis: 5e3,
            metricExportTimeoutMillis: 5e3,
            disableMetrics: false,
            disableTraces: false,
            exportInputAndOutput: !overrides.disableLoggingInputAndOutput,
            export: !!overrides.forceDevExport
        };
        return {
            ...defaults,
            ...overrides
        };
    },
    productionDefaults: (overrides = {})=>{
        const defaults = {
            sampler: new import_sdk_trace_base.AlwaysOnSampler(),
            autoInstrumentation: true,
            autoInstrumentationConfig: {
                "@opentelemetry/instrumentation-dns": {
                    enabled: false
                }
            },
            instrumentations: [],
            metricExportIntervalMillis: 3e5,
            metricExportTimeoutMillis: 3e5,
            disableMetrics: false,
            disableTraces: false,
            exportInputAndOutput: !overrides.disableLoggingInputAndOutput,
            export: true
        };
        return {
            ...defaults,
            ...overrides
        };
    }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    TelemetryConfigs
}); //# sourceMappingURL=defaults.js.map
}}),
"[project]/node_modules/@genkit-ai/google-cloud/lib/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var index_exports = {};
__export(index_exports, {
    enableGoogleCloudTelemetry: ()=>enableGoogleCloudTelemetry
});
module.exports = __toCommonJS(index_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/genkit/lib/tracing.js [app-rsc] (ecmascript)");
var import_auth = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/auth.js [app-rsc] (ecmascript)");
var import_gcpLogger = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/gcpLogger.js [app-rsc] (ecmascript)");
var import_gcpOpenTelemetry = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/gcpOpenTelemetry.js [app-rsc] (ecmascript)");
var import_defaults = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/telemetry/defaults.js [app-rsc] (ecmascript)");
__reExport(index_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/gcpLogger.js [app-rsc] (ecmascript)"), module.exports);
__reExport(index_exports, __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/gcpOpenTelemetry.js [app-rsc] (ecmascript)"), module.exports);
function enableGoogleCloudTelemetry(options) {
    return (0, import_tracing.enableTelemetry)(configureGcpPlugin(options).then(async (pluginConfig)=>{
        import_logging.logger.init(await new import_gcpLogger.GcpLogger(pluginConfig).getLogger((0, import_genkit.getCurrentEnv)()));
        return new import_gcpOpenTelemetry.GcpOpenTelemetry(pluginConfig).getConfig();
    }));
}
async function configureGcpPlugin(options) {
    const envOptions = await (0, import_auth.credentialsFromEnvironment)();
    return {
        projectId: options?.projectId || envOptions.projectId,
        credentials: options?.credentials || envOptions.credentials,
        ...import_defaults.TelemetryConfigs.defaults(options)
    };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    enableGoogleCloudTelemetry,
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/gcpLogger.js [app-rsc] (ecmascript)"),
    ...__turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/gcpOpenTelemetry.js [app-rsc] (ecmascript)")
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@genkit-ai/firebase/lib/firestore-retriever.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var firestore_retriever_exports = {};
__export(firestore_retriever_exports, {
    defineFirestoreRetriever: ()=>defineFirestoreRetriever
});
module.exports = __toCommonJS(firestore_retriever_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
function toContent(d, contentField) {
    if (typeof contentField === "function") {
        return contentField(d);
    }
    return [
        {
            text: d.get(contentField)
        }
    ];
}
function toDocuments(result, vectorField, contentField, metadataFields) {
    return result.docs.map((d)=>{
        const out = {
            content: toContent(d, contentField)
        };
        if (typeof metadataFields === "function") {
            out.metadata = metadataFields(d);
            return out;
        }
        out.metadata = {
            id: d.id
        };
        if (metadataFields) {
            for (const field of metadataFields){
                out.metadata[field] = d.get(field);
            }
            return out;
        }
        out.metadata = d.data();
        delete out.metadata[vectorField];
        if (typeof contentField === "string") delete out.metadata[contentField];
        return out;
    });
}
function defineFirestoreRetriever(ai, config) {
    const { name, label, firestore, embedder, collection, vectorField, metadataFields, contentField, distanceMeasure, distanceThreshold, distanceResultField } = config;
    return ai.defineRetriever({
        name,
        info: {
            label: label || `Firestore - ${name}`
        },
        configSchema: import_genkit.z.object({
            where: import_genkit.z.record(import_genkit.z.any()).optional(),
            /** Max number of results to return. Defaults to 10. */ limit: import_genkit.z.number().optional(),
            /* Supply or override the distanceMeasure */ distanceMeasure: import_genkit.z.enum([
                "COSINE",
                "DOT_PRODUCT",
                "EUCLIDEAN"
            ]).optional(),
            /* Supply or override the distanceThreshold */ distanceThreshold: import_genkit.z.number().optional(),
            /* Supply or override the metadata field where distances are stored. */ distanceResultField: import_genkit.z.string().optional(),
            /* Supply or override the collection for retrieval. */ collection: import_genkit.z.string().optional()
        })
    }, async (content, options)=>{
        options = options || {};
        if (!options.collection && !collection) {
            throw new Error("Must specify a collection to query in Firestore retriever.");
        }
        let query = firestore.collection(options.collection || collection);
        for(const field in options.where || {}){
            query = query.where(field, "==", options.where[field]);
        }
        const queryVector = (await ai.embed({
            embedder,
            content
        }))[0].embedding;
        const result = await query.findNearest({
            vectorField,
            queryVector,
            limit: options.limit || 10,
            distanceMeasure: options.distanceMeasure || distanceMeasure || "COSINE",
            distanceResultField: options.distanceResultField || distanceResultField,
            distanceThreshold: options.distanceThreshold || distanceThreshold
        }).get();
        return {
            documents: toDocuments(result, vectorField, contentField, metadataFields)
        };
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    defineFirestoreRetriever
}); //# sourceMappingURL=firestore-retriever.js.map
}}),
"[project]/node_modules/@genkit-ai/firebase/lib/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var index_exports = {};
__export(index_exports, {
    defineFirestoreRetriever: ()=>import_firestore_retriever.defineFirestoreRetriever,
    enableFirebaseTelemetry: ()=>enableFirebaseTelemetry
});
module.exports = __toCommonJS(index_exports);
var import_google_cloud = __turbopack_context__.r("[project]/node_modules/@genkit-ai/google-cloud/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_firestore_retriever = __turbopack_context__.r("[project]/node_modules/@genkit-ai/firebase/lib/firestore-retriever.js [app-rsc] (ecmascript)");
/**
 * @license
 *
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ async function enableFirebaseTelemetry(options) {
    import_logging.logger.debug("Initializing Firebase Genkit Monitoring.");
    await (0, import_google_cloud.enableGoogleCloudTelemetry)(options);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    defineFirestoreRetriever,
    enableFirebaseTelemetry
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var common_exports = {};
__export(common_exports, {
    getApiKeyFromEnvVar: ()=>getApiKeyFromEnvVar
});
module.exports = __toCommonJS(common_exports);
var import_process = __toESM(__turbopack_context__.r("[externals]/process [external] (process, cjs)"));
function getApiKeyFromEnvVar() {
    return import_process.default.env.GEMINI_API_KEY || import_process.default.env.GOOGLE_API_KEY || import_process.default.env.GOOGLE_GENAI_API_KEY;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    getApiKeyFromEnvVar
}); //# sourceMappingURL=common.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/embedder.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var embedder_exports = {};
__export(embedder_exports, {
    GeminiEmbeddingConfigSchema: ()=>GeminiEmbeddingConfigSchema,
    SUPPORTED_MODELS: ()=>SUPPORTED_MODELS,
    TaskTypeSchema: ()=>TaskTypeSchema,
    defineGoogleAIEmbedder: ()=>defineGoogleAIEmbedder,
    textEmbedding004: ()=>textEmbedding004,
    textEmbeddingGecko001: ()=>textEmbeddingGecko001
});
module.exports = __toCommonJS(embedder_exports);
var import_generative_ai = __turbopack_context__.r("[project]/node_modules/@google/generative-ai/dist/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_embedder = __turbopack_context__.r("[project]/node_modules/genkit/lib/embedder.js [app-rsc] (ecmascript)");
var import_common = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)");
const TaskTypeSchema = import_genkit.z.enum([
    "RETRIEVAL_DOCUMENT",
    "RETRIEVAL_QUERY",
    "SEMANTIC_SIMILARITY",
    "CLASSIFICATION",
    "CLUSTERING"
]);
const GeminiEmbeddingConfigSchema = import_genkit.z.object({
    /** Override the API key provided at plugin initialization. */ apiKey: import_genkit.z.string().optional(),
    /**
   * The `task_type` parameter is defined as the intended downstream application to help the model
   * produce better quality embeddings.
   **/ taskType: TaskTypeSchema.optional(),
    title: import_genkit.z.string().optional(),
    version: import_genkit.z.string().optional(),
    /**
   * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.
   * By default, the model generates embeddings with 768 dimensions. Models such as
   * `text-embedding-004`, `text-embedding-005`, and `text-multilingual-embedding-002`
   * allow the output dimensionality to be adjusted between 1 and 768.
   * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.
   **/ outputDimensionality: import_genkit.z.number().min(1).max(768).optional()
});
const textEmbeddingGecko001 = (0, import_embedder.embedderRef)({
    name: "googleai/embedding-001",
    configSchema: GeminiEmbeddingConfigSchema,
    info: {
        dimensions: 768,
        label: "Google Gen AI - Text Embedding Gecko (Legacy)",
        supports: {
            input: [
                "text"
            ]
        }
    }
});
const textEmbedding004 = (0, import_embedder.embedderRef)({
    name: "googleai/text-embedding-004",
    configSchema: GeminiEmbeddingConfigSchema,
    info: {
        dimensions: 768,
        label: "Google Gen AI - Text Embedding 001",
        supports: {
            input: [
                "text"
            ]
        }
    }
});
const SUPPORTED_MODELS = {
    "embedding-001": textEmbeddingGecko001,
    "text-embedding-004": textEmbedding004
};
function defineGoogleAIEmbedder(ai, name, pluginOptions) {
    let apiKey;
    if (pluginOptions.apiKey !== false) {
        apiKey = pluginOptions?.apiKey || (0, import_common.getApiKeyFromEnvVar)();
        if (!apiKey) throw new Error("Please pass in the API key or set either GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai");
    }
    const embedder = SUPPORTED_MODELS[name] ?? (0, import_embedder.embedderRef)({
        name,
        configSchema: GeminiEmbeddingConfigSchema,
        info: {
            dimensions: 768,
            label: `Google AI - ${name}`,
            supports: {
                input: [
                    "text",
                    "image",
                    "video"
                ]
            }
        }
    });
    const apiModelName = embedder.name.startsWith("googleai/") ? embedder.name.substring("googleai/".length) : embedder.name;
    return ai.defineEmbedder({
        name: embedder.name,
        configSchema: GeminiEmbeddingConfigSchema,
        info: embedder.info
    }, async (input, options)=>{
        if (pluginOptions.apiKey === false && !options?.apiKey) {
            throw new import_genkit.GenkitError({
                status: "INVALID_ARGUMENT",
                message: "GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time."
            });
        }
        const client = new import_generative_ai.GoogleGenerativeAI(options?.apiKey || apiKey).getGenerativeModel({
            model: options?.version || embedder.config?.version || embedder.version || apiModelName
        });
        const embeddings = await Promise.all(input.map(async (doc)=>{
            const response = await client.embedContent({
                taskType: options?.taskType,
                title: options?.title,
                content: {
                    role: "",
                    parts: [
                        {
                            text: doc.text
                        }
                    ]
                },
                outputDimensionality: options?.outputDimensionality
            });
            const values = response.embedding.values;
            return {
                embedding: values
            };
        }));
        return {
            embeddings
        };
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GeminiEmbeddingConfigSchema,
    SUPPORTED_MODELS,
    TaskTypeSchema,
    defineGoogleAIEmbedder,
    textEmbedding004,
    textEmbeddingGecko001
}); //# sourceMappingURL=embedder.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/constants.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var constants_exports = {};
__export(constants_exports, {
    CONTEXT_CACHE_SUPPORTED_MODELS: ()=>CONTEXT_CACHE_SUPPORTED_MODELS,
    DEFAULT_TTL: ()=>DEFAULT_TTL,
    INVALID_ARGUMENT_MESSAGES: ()=>INVALID_ARGUMENT_MESSAGES
});
module.exports = __toCommonJS(constants_exports);
const CONTEXT_CACHE_SUPPORTED_MODELS = [
    "gemini-1.5-flash-001",
    "gemini-1.5-pro-001"
];
const INVALID_ARGUMENT_MESSAGES = {
    modelVersion: `Model version is required for context caching, supported only in ${CONTEXT_CACHE_SUPPORTED_MODELS.join(",")} models.`,
    tools: "Context caching cannot be used simultaneously with tools.",
    codeExecution: "Context caching cannot be used simultaneously with code execution."
};
const DEFAULT_TTL = 300;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    CONTEXT_CACHE_SUPPORTED_MODELS,
    DEFAULT_TTL,
    INVALID_ARGUMENT_MESSAGES
}); //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var types_exports = {};
__export(types_exports, {
    cacheConfigDetailsSchema: ()=>cacheConfigDetailsSchema,
    cacheConfigSchema: ()=>cacheConfigSchema
});
module.exports = __toCommonJS(types_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
const cacheConfigSchema = import_genkit.z.union([
    import_genkit.z.boolean(),
    import_genkit.z.object({
        ttlSeconds: import_genkit.z.number().optional()
    }).passthrough()
]);
const cacheConfigDetailsSchema = import_genkit.z.object({
    cacheConfig: cacheConfigSchema,
    endOfCachedContents: import_genkit.z.number()
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    cacheConfigDetailsSchema,
    cacheConfigSchema
}); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var utils_exports = {};
__export(utils_exports, {
    calculateTTL: ()=>calculateTTL,
    extractCacheConfig: ()=>extractCacheConfig,
    findLastIndex: ()=>findLastIndex,
    generateCacheKey: ()=>generateCacheKey,
    getContentForCache: ()=>getContentForCache,
    lookupContextCache: ()=>lookupContextCache,
    validateContextCacheRequest: ()=>validateContextCacheRequest
});
module.exports = __toCommonJS(utils_exports);
var import_crypto = __toESM(__turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)"));
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_constants = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/constants.js [app-rsc] (ecmascript)");
var import_types = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/types.js [app-rsc] (ecmascript)");
function generateCacheKey(request) {
    return import_crypto.default.createHash("sha256").update(JSON.stringify(request)).digest("hex");
}
function getContentForCache(request, chatRequest, modelVersion, cacheConfigDetails) {
    if (!modelVersion) {
        throw new Error("No model version provided for context caching");
    }
    if (!chatRequest.history?.length) {
        throw new Error("No history provided for context caching");
    }
    validateHistoryLength(request, chatRequest);
    const { endOfCachedContents, cacheConfig } = cacheConfigDetails;
    const cachedContent = {
        model: modelVersion,
        contents: chatRequest.history.slice(0, endOfCachedContents + 1)
    };
    chatRequest.history = chatRequest.history.slice(endOfCachedContents + 1);
    return {
        cachedContent,
        chatRequest,
        cacheConfig
    };
}
function validateHistoryLength(request, chatRequest) {
    if (chatRequest.history?.length !== request.messages.length - 1) {
        throw new import_genkit.GenkitError({
            status: "INTERNAL",
            message: "Genkit request history and Gemini chat request history length do not match"
        });
    }
}
async function lookupContextCache(cacheManager, cacheKey, maxPages = 100, pageSize = 100) {
    let currentPage = 0;
    let pageToken;
    try {
        while(currentPage < maxPages){
            const { cachedContents, nextPageToken } = await cacheManager.list({
                pageSize,
                pageToken
            });
            const found = cachedContents?.find((content)=>content.displayName === cacheKey);
            if (found) return found;
            if (!nextPageToken) break;
            pageToken = nextPageToken;
            currentPage++;
        }
    } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown Network Error";
        throw new import_genkit.GenkitError({
            status: "INTERNAL",
            message: `Error looking up context cache: ${message}`
        });
    }
    return null;
}
const extractCacheConfig = (request)=>{
    const endOfCachedContents = findLastIndex(request.messages, (message)=>!!message.metadata?.cache);
    return endOfCachedContents === -1 ? null : {
        endOfCachedContents,
        cacheConfig: import_types.cacheConfigSchema.parse(request.messages[endOfCachedContents].metadata?.cache)
    };
};
function validateContextCacheRequest(request, modelVersion) {
    if (!modelVersion || !import_constants.CONTEXT_CACHE_SUPPORTED_MODELS.includes(modelVersion)) {
        throw new import_genkit.GenkitError({
            status: "INVALID_ARGUMENT",
            message: import_constants.INVALID_ARGUMENT_MESSAGES.modelVersion
        });
    }
    if (request.tools?.length) throw new import_genkit.GenkitError({
        status: "INVALID_ARGUMENT",
        message: import_constants.INVALID_ARGUMENT_MESSAGES.tools
    });
    if (request.config?.codeExecution) throw new import_genkit.GenkitError({
        status: "INVALID_ARGUMENT",
        message: import_constants.INVALID_ARGUMENT_MESSAGES.codeExecution
    });
    return true;
}
function findLastIndex(array, callback) {
    for(let i = array.length - 1; i >= 0; i--){
        if (callback(array[i], i, array)) return i;
    }
    return -1;
}
function calculateTTL(cacheConfig) {
    if (cacheConfig.cacheConfig === true) {
        return import_constants.DEFAULT_TTL;
    }
    if (cacheConfig.cacheConfig === false) {
        return 0;
    }
    return cacheConfig.cacheConfig.ttlSeconds || import_constants.DEFAULT_TTL;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    calculateTTL,
    extractCacheConfig,
    findLastIndex,
    generateCacheKey,
    getContentForCache,
    lookupContextCache,
    validateContextCacheRequest
}); //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/context-caching/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var context_caching_exports = {};
__export(context_caching_exports, {
    handleCacheIfNeeded: ()=>handleCacheIfNeeded,
    handleContextCache: ()=>handleContextCache
});
module.exports = __toCommonJS(context_caching_exports);
var import_server = __turbopack_context__.r("[project]/node_modules/@google/generative-ai/dist/server/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_logging = __turbopack_context__.r("[project]/node_modules/genkit/lib/logging.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/utils.js [app-rsc] (ecmascript)");
async function handleContextCache(apiKey, request, chatRequest, modelVersion, cacheConfigDetails) {
    const cacheManager = new import_server.GoogleAICacheManager(apiKey);
    const { cachedContent, chatRequest: newChatRequest } = (0, import_utils.getContentForCache)(request, chatRequest, modelVersion, cacheConfigDetails);
    cachedContent.model = modelVersion;
    const cacheKey = (0, import_utils.generateCacheKey)(cachedContent);
    cachedContent.displayName = cacheKey;
    let cache = await (0, import_utils.lookupContextCache)(cacheManager, cacheKey);
    import_logging.logger.debug(`Cache hit: ${cache ? "true" : "false"}`);
    if (!cache) {
        try {
            import_logging.logger.debug("No cache found, creating one.");
            const createParams = {
                ...cachedContent,
                ttlSeconds: (0, import_utils.calculateTTL)(cacheConfigDetails)
            };
            cache = await cacheManager.create(createParams);
            import_logging.logger.debug(`Created new cache entry with key: ${cacheKey}`);
        } catch (cacheError) {
            import_logging.logger.error(`Failed to create cache with key ${cacheKey}: ${cacheError}`);
            throw new import_genkit.GenkitError({
                status: "INTERNAL",
                message: `Failed to create cache: ${cacheError}`
            });
        }
    }
    if (!cache) {
        throw new import_genkit.GenkitError({
            status: "INTERNAL",
            message: "Failed to use context cache feature"
        });
    }
    return {
        cache,
        newChatRequest
    };
}
async function handleCacheIfNeeded(apiKey, request, chatRequest, modelVersion, cacheConfigDetails) {
    if (!cacheConfigDetails || !(0, import_utils.validateContextCacheRequest)(request, modelVersion)) {
        return {
            chatRequest,
            cache: null
        };
    }
    const { cache, newChatRequest } = await handleContextCache(apiKey, request, chatRequest, modelVersion, cacheConfigDetails);
    return {
        chatRequest: newChatRequest,
        cache
    };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    handleCacheIfNeeded,
    handleContextCache
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/gemini.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var gemini_exports = {};
__export(gemini_exports, {
    GENERIC_GEMINI_MODEL: ()=>GENERIC_GEMINI_MODEL,
    GeminiConfigSchema: ()=>GeminiConfigSchema,
    GeminiGemmaConfigSchema: ()=>GeminiGemmaConfigSchema,
    GeminiTtsConfigSchema: ()=>GeminiTtsConfigSchema,
    SUPPORTED_GEMINI_MODELS: ()=>SUPPORTED_GEMINI_MODELS,
    aggregateResponses: ()=>aggregateResponses,
    cleanSchema: ()=>cleanSchema,
    defineGoogleAIModel: ()=>defineGoogleAIModel,
    fromGeminiCandidate: ()=>fromGeminiCandidate,
    gemini: ()=>gemini,
    gemini10Pro: ()=>gemini10Pro,
    gemini15Flash: ()=>gemini15Flash,
    gemini15Flash8b: ()=>gemini15Flash8b,
    gemini15Pro: ()=>gemini15Pro,
    gemini20Flash: ()=>gemini20Flash,
    gemini20FlashExp: ()=>gemini20FlashExp,
    gemini20FlashLite: ()=>gemini20FlashLite,
    gemini20ProExp0205: ()=>gemini20ProExp0205,
    gemini25Flash: ()=>gemini25Flash,
    gemini25FlashPreview0417: ()=>gemini25FlashPreview0417,
    gemini25FlashPreviewTts: ()=>gemini25FlashPreviewTts,
    gemini25Pro: ()=>gemini25Pro,
    gemini25ProExp0325: ()=>gemini25ProExp0325,
    gemini25ProPreview0325: ()=>gemini25ProPreview0325,
    gemini25ProPreviewTts: ()=>gemini25ProPreviewTts,
    gemma312bit: ()=>gemma312bit,
    gemma31bit: ()=>gemma31bit,
    gemma327bit: ()=>gemma327bit,
    gemma34bit: ()=>gemma34bit,
    gemma3ne4bit: ()=>gemma3ne4bit,
    toGeminiMessage: ()=>toGeminiMessage,
    toGeminiSystemInstruction: ()=>toGeminiSystemInstruction,
    toGeminiTool: ()=>toGeminiTool
});
module.exports = __toCommonJS(gemini_exports);
var import_generative_ai = __turbopack_context__.r("[project]/node_modules/@google/generative-ai/dist/index.js [app-rsc] (ecmascript)");
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_model = __turbopack_context__.r("[project]/node_modules/genkit/lib/model.js [app-rsc] (ecmascript)");
var import_middleware = __turbopack_context__.r("[project]/node_modules/genkit/lib/middleware.js [app-rsc] (ecmascript)");
var import_tracing = __turbopack_context__.r("[project]/node_modules/genkit/lib/tracing.js [app-rsc] (ecmascript)");
var import_common = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)");
var import_context_caching = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/index.js [app-rsc] (ecmascript)");
var import_utils = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/context-caching/utils.js [app-rsc] (ecmascript)");
const SafetySettingsSchema = import_genkit.z.object({
    category: import_genkit.z.enum([
        "HARM_CATEGORY_UNSPECIFIED",
        "HARM_CATEGORY_HATE_SPEECH",
        "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        "HARM_CATEGORY_HARASSMENT",
        "HARM_CATEGORY_DANGEROUS_CONTENT",
        "HARM_CATEGORY_CIVIC_INTEGRITY"
    ]),
    threshold: import_genkit.z.enum([
        "BLOCK_LOW_AND_ABOVE",
        "BLOCK_MEDIUM_AND_ABOVE",
        "BLOCK_ONLY_HIGH",
        "BLOCK_NONE"
    ])
});
const VoiceConfigSchema = import_genkit.z.object({
    prebuiltVoiceConfig: import_genkit.z.object({
        // TODO: Make this an array of objects so we can also specify the description
        // for each voiceName.
        voiceName: import_genkit.z.union([
            import_genkit.z.enum([
                "Zephyr",
                "Puck",
                "Charon",
                "Kore",
                "Fenrir",
                "Leda",
                "Orus",
                "Aoede",
                "Callirrhoe",
                "Autonoe",
                "Enceladus",
                "Iapetus",
                "Umbriel",
                "Algieba",
                "Despina",
                "Erinome",
                "Algenib",
                "Rasalgethi",
                "Laomedeia",
                "Achernar",
                "Alnilam",
                "Schedar",
                "Gacrux",
                "Pulcherrima",
                "Achird",
                "Zubenelgenubi",
                "Vindemiatrix",
                "Sadachbia",
                "Sadaltager",
                "Sulafat"
            ]),
            // To allow any new string values
            import_genkit.z.string()
        ]).describe("Name of the preset voice to use").optional()
    }).describe("Configuration for the prebuilt speaker to use").passthrough().optional()
}).describe("Configuration for the voice to use").passthrough();
const GeminiConfigSchema = import_model.GenerationCommonConfigSchema.extend({
    temperature: import_genkit.z.number().min(0).max(2).describe(import_model.GenerationCommonConfigDescriptions.temperature + " The default value is 1.0.").optional(),
    topP: import_genkit.z.number().min(0).max(1).describe(import_model.GenerationCommonConfigDescriptions.topP + " The default value is 0.95.").optional(),
    apiKey: import_genkit.z.string().describe("Overrides the plugin-configured API key, if specified.").optional(),
    safetySettings: import_genkit.z.array(SafetySettingsSchema).describe("Adjust how likely you are to see responses that could be harmful. Content is blocked based on the probability that it is harmful.").optional(),
    codeExecution: import_genkit.z.union([
        import_genkit.z.boolean(),
        import_genkit.z.object({}).strict()
    ]).describe("Enables the model to generate and run code.").optional(),
    contextCache: import_genkit.z.boolean().describe("Context caching allows you to save and reuse precomputed input tokens that you wish to use repeatedly.").optional(),
    functionCallingConfig: import_genkit.z.object({
        mode: import_genkit.z.enum([
            "MODE_UNSPECIFIED",
            "AUTO",
            "ANY",
            "NONE"
        ]).optional(),
        allowedFunctionNames: import_genkit.z.array(import_genkit.z.string()).optional()
    }).describe("Controls how the model uses the provided tools (function declarations). With AUTO (Default) mode, the model decides whether to generate a natural language response or suggest a function call based on the prompt and context. With ANY, the model is constrained to always predict a function call and guarantee function schema adherence. With NONE, the model is prohibited from making function calls.").optional(),
    responseModalities: import_genkit.z.array(import_genkit.z.enum([
        "TEXT",
        "IMAGE",
        "AUDIO"
    ])).describe("The modalities to be used in response. Only supported for 'gemini-2.0-flash-exp' model at present.").optional(),
    googleSearchRetrieval: import_genkit.z.union([
        import_genkit.z.boolean(),
        import_genkit.z.object({}).passthrough()
    ]).describe("Retrieve public web data for grounding, powered by Google Search.").optional()
}).passthrough();
const GeminiGemmaConfigSchema = GeminiConfigSchema.extend({
    temperature: import_genkit.z.number().min(0).max(1).describe(import_model.GenerationCommonConfigDescriptions.temperature + " The default value is 1.0.").optional()
}).passthrough();
const GeminiTtsConfigSchema = GeminiConfigSchema.extend({
    speechConfig: import_genkit.z.object({
        voiceConfig: VoiceConfigSchema.optional(),
        multiSpeakerVoiceConfig: import_genkit.z.object({
            speakerVoiceConfigs: import_genkit.z.array(import_genkit.z.object({
                speaker: import_genkit.z.string().describe("Name of the speaker to use"),
                voiceConfig: VoiceConfigSchema
            }).describe("Configuration for a single speaker in a multi speaker setup").passthrough()).describe("Configuration for all the enabled speaker voices")
        }).describe("Configuration for multi-speaker setup").passthrough().optional()
    }).describe("Speech generation config").passthrough().optional()
}).passthrough();
const gemini10Pro = (0, import_model.modelRef)({
    name: "googleai/gemini-1.0-pro",
    info: {
        label: "Google AI - Gemini Pro",
        versions: [
            "gemini-pro",
            "gemini-1.0-pro-latest",
            "gemini-1.0-pro-001"
        ],
        supports: {
            multiturn: true,
            media: false,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini15Pro = (0, import_model.modelRef)({
    name: "googleai/gemini-1.5-pro",
    info: {
        label: "Google AI - Gemini 1.5 Pro",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        },
        versions: [
            "gemini-1.5-pro-latest",
            "gemini-1.5-pro-001",
            "gemini-1.5-pro-002"
        ]
    },
    configSchema: GeminiConfigSchema
});
const gemini15Flash = (0, import_model.modelRef)({
    name: "googleai/gemini-1.5-flash",
    info: {
        label: "Google AI - Gemini 1.5 Flash",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools",
            // @ts-ignore
            contextCache: true
        },
        versions: [
            "gemini-1.5-flash-latest",
            "gemini-1.5-flash-001",
            "gemini-1.5-flash-002"
        ]
    },
    configSchema: GeminiConfigSchema
});
const gemini15Flash8b = (0, import_model.modelRef)({
    name: "googleai/gemini-1.5-flash-8b",
    info: {
        label: "Google AI - Gemini 1.5 Flash",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        },
        versions: [
            "gemini-1.5-flash-8b-latest",
            "gemini-1.5-flash-8b-001"
        ]
    },
    configSchema: GeminiConfigSchema
});
const gemini20Flash = (0, import_model.modelRef)({
    name: "googleai/gemini-2.0-flash",
    info: {
        label: "Google AI - Gemini 2.0 Flash",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini20FlashExp = (0, import_model.modelRef)({
    name: "googleai/gemini-2.0-flash-exp",
    info: {
        label: "Google AI - Gemini 2.0 Flash (Experimental)",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini20FlashLite = (0, import_model.modelRef)({
    name: "googleai/gemini-2.0-flash-lite",
    info: {
        label: "Google AI - Gemini 2.0 Flash Lite",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini20ProExp0205 = (0, import_model.modelRef)({
    name: "googleai/gemini-2.0-pro-exp-02-05",
    info: {
        label: "Google AI - Gemini 2.0 Pro Exp 02-05",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini25FlashPreview0417 = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-flash-preview-04-17",
    info: {
        label: "Google AI - Gemini 2.5 Flash Preview 04-17",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini25FlashPreviewTts = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-flash-preview-tts",
    info: {
        label: "Google AI - Gemini 2.5 Flash Preview TTS",
        versions: [],
        supports: {
            multiturn: false,
            media: false,
            tools: false,
            toolChoice: false,
            systemRole: false,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiTtsConfigSchema
});
const gemini25ProExp0325 = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-pro-exp-03-25",
    info: {
        label: "Google AI - Gemini 2.5 Pro Exp 03-25",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini25ProPreview0325 = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-pro-preview-03-25",
    info: {
        label: "Google AI - Gemini 2.5 Pro Preview 03-25",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini25ProPreviewTts = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-pro-preview-tts",
    info: {
        label: "Google AI - Gemini 2.5 Pro Preview TTS",
        versions: [],
        supports: {
            multiturn: false,
            media: false,
            tools: false,
            toolChoice: false,
            systemRole: false,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiTtsConfigSchema
});
const gemini25Pro = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-pro",
    info: {
        label: "Google AI - Gemini 2.5 Pro",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemini25Flash = (0, import_model.modelRef)({
    name: "googleai/gemini-2.5-flash",
    info: {
        label: "Google AI - Gemini 2.5 Flash",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiConfigSchema
});
const gemma312bit = (0, import_model.modelRef)({
    name: "googleai/gemma-3-12b-it",
    info: {
        label: "Google AI - Gemma 3 12B",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiGemmaConfigSchema
});
const gemma31bit = (0, import_model.modelRef)({
    name: "googleai/gemma-3-1b-it",
    info: {
        label: "Google AI - Gemma 3 1B",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiGemmaConfigSchema
});
const gemma327bit = (0, import_model.modelRef)({
    name: "googleai/gemma-3-27b-it",
    info: {
        label: "Google AI - Gemma 3 27B",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiGemmaConfigSchema
});
const gemma34bit = (0, import_model.modelRef)({
    name: "googleai/gemma-3-4b-it",
    info: {
        label: "Google AI - Gemma 3 4B",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiGemmaConfigSchema
});
const gemma3ne4bit = (0, import_model.modelRef)({
    name: "googleai/gemma-3n-e4b-it",
    info: {
        label: "Google AI - Gemma 3n E4B",
        versions: [],
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    },
    configSchema: GeminiGemmaConfigSchema
});
const SUPPORTED_GEMINI_MODELS = {
    "gemini-1.5-pro": gemini15Pro,
    "gemini-1.5-flash": gemini15Flash,
    "gemini-1.5-flash-8b": gemini15Flash8b,
    "gemini-2.0-pro-exp-02-05": gemini20ProExp0205,
    "gemini-2.0-flash": gemini20Flash,
    "gemini-2.0-flash-lite": gemini20FlashLite,
    "gemini-2.0-flash-exp": gemini20FlashExp,
    "gemini-2.5-pro-exp-03-25": gemini25ProExp0325,
    "gemini-2.5-pro-preview-03-25": gemini25ProPreview0325,
    "gemini-2.5-pro-preview-tts": gemini25ProPreviewTts,
    "gemini-2.5-flash-preview-04-17": gemini25FlashPreview0417,
    "gemini-2.5-flash-preview-tts": gemini25FlashPreviewTts,
    "gemini-2.5-flash": gemini25Flash,
    "gemini-2.5-pro": gemini25Pro,
    "gemma-3-12b-it": gemma312bit,
    "gemma-3-1b-it": gemma31bit,
    "gemma-3-27b-it": gemma327bit,
    "gemma-3-4b-it": gemma34bit,
    "gemma-3n-e4b-it": gemma3ne4bit
};
const GENERIC_GEMINI_MODEL = (0, import_model.modelRef)({
    name: "googleai/gemini",
    configSchema: GeminiConfigSchema,
    info: {
        label: "Google Gemini",
        supports: {
            multiturn: true,
            media: true,
            tools: true,
            toolChoice: true,
            systemRole: true,
            constrained: "no-tools"
        }
    }
});
function longestMatchingPrefix(version, potentialMatches) {
    return potentialMatches.filter((p)=>version.startsWith(p)).reduce((longest, current)=>current.length > longest.length ? current : longest, "");
}
function gemini(version, options = {}) {
    const nearestModel = nearestGeminiModelRef(version);
    return (0, import_model.modelRef)({
        name: `googleai/${version}`,
        config: options,
        configSchema: GeminiConfigSchema,
        info: {
            ...nearestModel.info,
            // If exact suffix match for a known model, use its label, otherwise create a new label
            label: nearestModel.name.endsWith(version) ? nearestModel.info?.label : `Google AI - ${version}`
        }
    });
}
function nearestGeminiModelRef(version, options = {}) {
    const matchingKey = longestMatchingPrefix(version, Object.keys(SUPPORTED_GEMINI_MODELS));
    if (matchingKey) {
        return SUPPORTED_GEMINI_MODELS[matchingKey].withConfig({
            ...options,
            version
        });
    }
    return GENERIC_GEMINI_MODEL.withConfig({
        ...options,
        version
    });
}
function toGeminiRole(role, model) {
    switch(role){
        case "user":
            return "user";
        case "model":
            return "model";
        case "system":
            if (model?.info?.supports?.systemRole) {
                throw new Error("system role is only supported for a single message in the first position");
            } else {
                throw new Error("system role is not supported");
            }
        case "tool":
            return "function";
        default:
            return "user";
    }
}
function convertSchemaProperty(property) {
    if (!property || !property.type) {
        return void 0;
    }
    const baseSchema = {};
    if (property.description) {
        baseSchema.description = property.description;
    }
    if (property.enum) {
        baseSchema.type = import_generative_ai.SchemaType.STRING;
        baseSchema.enum = property.enum;
    }
    if (property.nullable) {
        baseSchema.nullable = property.nullable;
    }
    let propertyType;
    if (Array.isArray(property.type)) {
        const types = property.type;
        if (types.includes("null")) {
            baseSchema.nullable = true;
        }
        propertyType = types.find((t)=>t !== "null");
    } else {
        propertyType = property.type;
    }
    if (propertyType === "object") {
        const nestedProperties = {};
        Object.keys(property.properties).forEach((key)=>{
            nestedProperties[key] = convertSchemaProperty(property.properties[key]);
        });
        return {
            ...baseSchema,
            type: import_generative_ai.SchemaType.OBJECT,
            properties: nestedProperties,
            required: property.required
        };
    } else if (propertyType === "array") {
        return {
            ...baseSchema,
            type: import_generative_ai.SchemaType.ARRAY,
            items: convertSchemaProperty(property.items)
        };
    } else {
        const schemaType = import_generative_ai.SchemaType[propertyType.toUpperCase()];
        if (!schemaType) {
            throw new import_genkit.GenkitError({
                status: "INVALID_ARGUMENT",
                message: `Unsupported property type ${propertyType.toUpperCase()}`
            });
        }
        return {
            ...baseSchema,
            type: schemaType
        };
    }
}
function toGeminiTool(tool) {
    const declaration = {
        name: tool.name.replace(/\//g, "__"),
        // Gemini throws on '/' in tool name
        description: tool.description,
        parameters: convertSchemaProperty(tool.inputSchema)
    };
    return declaration;
}
function toInlineData(part) {
    const dataUrl = part.media.url;
    const b64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);
    const contentType = part.media.contentType || dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
    return {
        inlineData: {
            mimeType: contentType,
            data: b64Data
        }
    };
}
function toFileData(part) {
    if (!part.media.contentType) throw new Error("Must supply a `contentType` when sending File URIs to Gemini.");
    return {
        fileData: {
            mimeType: part.media.contentType,
            fileUri: part.media.url
        }
    };
}
function fromInlineData(inlinePart) {
    if (!inlinePart.inlineData || !inlinePart.inlineData.hasOwnProperty("mimeType") || !inlinePart.inlineData.hasOwnProperty("data")) {
        throw new Error("Invalid InlineDataPart: missing required properties");
    }
    const { mimeType, data } = inlinePart.inlineData;
    const dataUrl = `data:${mimeType};base64,${data}`;
    return {
        media: {
            url: dataUrl,
            contentType: mimeType
        }
    };
}
function toFunctionCall(part) {
    if (!part?.toolRequest?.input) {
        throw Error("Invalid ToolRequestPart: input was missing.");
    }
    return {
        functionCall: {
            name: part.toolRequest.name,
            args: part.toolRequest.input
        }
    };
}
function fromFunctionCall(part, ref) {
    if (!part.functionCall) {
        throw Error("Invalid FunctionCallPart");
    }
    return {
        toolRequest: {
            name: part.functionCall.name,
            input: part.functionCall.args,
            ref
        }
    };
}
function toFunctionResponse(part) {
    if (!part?.toolResponse?.output) {
        throw Error("Invalid ToolResponsePart: output was missing.");
    }
    return {
        functionResponse: {
            name: part.toolResponse.name,
            response: {
                name: part.toolResponse.name,
                content: part.toolResponse.output
            }
        }
    };
}
function fromFunctionResponse(part) {
    if (!part.functionResponse) {
        throw new Error("Invalid FunctionResponsePart.");
    }
    return {
        toolResponse: {
            name: part.functionResponse.name.replace(/__/g, "/"),
            // restore slashes
            output: part.functionResponse.response
        }
    };
}
function fromExecutableCode(part) {
    if (!part.executableCode) {
        throw new Error("Invalid GeminiPart: missing executableCode");
    }
    return {
        custom: {
            executableCode: {
                language: part.executableCode.language,
                code: part.executableCode.code
            }
        }
    };
}
function fromCodeExecutionResult(part) {
    if (!part.codeExecutionResult) {
        throw new Error("Invalid GeminiPart: missing codeExecutionResult");
    }
    return {
        custom: {
            codeExecutionResult: {
                outcome: part.codeExecutionResult.outcome,
                output: part.codeExecutionResult.output
            }
        }
    };
}
function fromThought(part) {
    return {
        reasoning: part.text || "",
        metadata: {
            thoughtSignature: part.thoughtSignature
        }
    };
}
function toCustomPart(part) {
    if (!part.custom) {
        throw new Error("Invalid GeminiPart: missing custom");
    }
    if (part.custom.codeExecutionResult) {
        return {
            codeExecutionResult: part.custom.codeExecutionResult
        };
    }
    if (part.custom.executableCode) {
        return {
            executableCode: part.custom.executableCode
        };
    }
    throw new Error("Unsupported Custom Part type");
}
function toThought(part) {
    const outPart = {
        thought: true
    };
    if (part.metadata?.thoughtSignature) outPart.thoughtSignature = part.metadata.thoughtSignature;
    if (part.reasoning?.length) outPart.text = part.reasoning;
    return outPart;
}
function toGeminiPart(part) {
    if (part.text !== void 0) return {
        text: part.text || " "
    };
    if (part.media) {
        if (part.media.url.startsWith("data:")) return toInlineData(part);
        return toFileData(part);
    }
    if (part.toolRequest) return toFunctionCall(part);
    if (part.toolResponse) return toFunctionResponse(part);
    if (part.custom) return toCustomPart(part);
    if (typeof part.reasoning === "string") return toThought(part);
    throw new Error("Unsupported Part type" + JSON.stringify(part));
}
function fromGeminiPart(part, jsonMode, ref) {
    if ("thought" in part) return fromThought(part);
    if (typeof part.text === "string") return {
        text: part.text
    };
    if (part.inlineData) return fromInlineData(part);
    if (part.functionCall) return fromFunctionCall(part, ref);
    if (part.functionResponse) return fromFunctionResponse(part);
    if (part.executableCode) return fromExecutableCode(part);
    if (part.codeExecutionResult) return fromCodeExecutionResult(part);
    throw new Error("Unsupported GeminiPart type: " + JSON.stringify(part));
}
function toGeminiMessage(message, model) {
    let sortedParts = message.content;
    if (message.role === "tool") {
        sortedParts = [
            ...message.content
        ].sort((a, b)=>{
            const aRef = a.toolResponse?.ref;
            const bRef = b.toolResponse?.ref;
            if (!aRef && !bRef) return 0;
            if (!aRef) return 1;
            if (!bRef) return -1;
            return Number.parseInt(aRef, 10) - Number.parseInt(bRef, 10);
        });
    }
    return {
        role: toGeminiRole(message.role, model),
        parts: sortedParts.map(toGeminiPart)
    };
}
function toGeminiSystemInstruction(message) {
    return {
        role: "user",
        parts: message.content.map(toGeminiPart)
    };
}
function fromGeminiFinishReason(reason) {
    if (!reason) return "unknown";
    switch(reason){
        case "STOP":
            return "stop";
        case "MAX_TOKENS":
            return "length";
        case "SAFETY":
        // blocked for safety
        case "RECITATION":
            return "blocked";
        default:
            return "unknown";
    }
}
function fromGeminiCandidate(candidate, jsonMode = false) {
    const parts = candidate.content?.parts || [];
    const genkitCandidate = {
        index: candidate.index || 0,
        message: {
            role: "model",
            content: parts.map((part, index)=>fromGeminiPart(part, jsonMode, index.toString()))
        },
        finishReason: fromGeminiFinishReason(candidate.finishReason),
        finishMessage: candidate.finishMessage,
        custom: {
            safetyRatings: candidate.safetyRatings,
            citationMetadata: candidate.citationMetadata
        }
    };
    return genkitCandidate;
}
function cleanSchema(schema) {
    const out = structuredClone(schema);
    for(const key in out){
        if (key === "$schema" || key === "additionalProperties") {
            delete out[key];
            continue;
        }
        if (typeof out[key] === "object") {
            out[key] = cleanSchema(out[key]);
        }
        if (key === "type" && Array.isArray(out[key])) {
            out[key] = out[key].find((t)=>t !== "null");
        }
    }
    return out;
}
function defineGoogleAIModel({ ai, name, apiKey: apiKeyOption, apiVersion, baseUrl, info, defaultConfig, debugTraces }) {
    let apiKey;
    if (apiKeyOption !== false) {
        apiKey = apiKeyOption || (0, import_common.getApiKeyFromEnvVar)();
        if (!apiKey) {
            throw new import_genkit.GenkitError({
                status: "FAILED_PRECONDITION",
                message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
            });
        }
    }
    const apiModelName = name.startsWith("googleai/") ? name.substring("googleai/".length) : name;
    const model = SUPPORTED_GEMINI_MODELS[apiModelName] ?? (0, import_model.modelRef)({
        name: `googleai/${apiModelName}`,
        info: {
            label: `Google AI - ${apiModelName}`,
            supports: {
                multiturn: true,
                media: true,
                tools: true,
                systemRole: true,
                output: [
                    "text",
                    "json"
                ]
            },
            ...info
        },
        configSchema: GeminiConfigSchema
    });
    const middleware = [];
    if (model.info?.supports?.media) {
        middleware.push((0, import_middleware.downloadRequestMedia)({
            maxBytes: 1024 * 1024 * 10,
            // don't downlaod files that have been uploaded using the Files API
            filter: (part)=>{
                try {
                    const url = new URL(part.media.url);
                    if (// Gemini can handle these URLs
                    [
                        "generativelanguage.googleapis.com",
                        "www.youtube.com",
                        "youtube.com",
                        "youtu.be"
                    ].includes(url.hostname)) return false;
                } catch  {}
                return true;
            }
        }));
    }
    return ai.defineModel({
        name: model.name,
        ...model.info,
        configSchema: model.configSchema,
        use: middleware
    }, async (request, sendChunk)=>{
        const options = {
            apiClient: import_genkit.GENKIT_CLIENT_HEADER
        };
        if (apiVersion) {
            options.apiVersion = apiVersion;
        }
        if (apiVersion) {
            options.baseUrl = baseUrl;
        }
        const requestConfig = {
            ...defaultConfig,
            ...request.config
        };
        const messages = [
            ...request.messages
        ];
        if (messages.length === 0) throw new Error("No messages provided.");
        let systemInstruction = void 0;
        if (model.info?.supports?.systemRole) {
            const systemMessage = messages.find((m)=>m.role === "system");
            if (systemMessage) {
                messages.splice(messages.indexOf(systemMessage), 1);
                systemInstruction = toGeminiSystemInstruction(systemMessage);
            }
        }
        const tools = [];
        if (request.tools?.length) {
            tools.push({
                functionDeclarations: request.tools.map(toGeminiTool)
            });
        }
        const { apiKey: apiKeyFromConfig, safetySettings: safetySettingsFromConfig, codeExecution: codeExecutionFromConfig, version: versionFromConfig, functionCallingConfig, googleSearchRetrieval, tools: toolsFromConfig, ...restOfConfigOptions } = requestConfig;
        if (codeExecutionFromConfig) {
            tools.push({
                codeExecution: request.config.codeExecution === true ? {} : request.config.codeExecution
            });
        }
        if (toolsFromConfig) {
            tools.push(...toolsFromConfig);
        }
        if (googleSearchRetrieval) {
            tools.push({
                googleSearch: googleSearchRetrieval === true ? {} : googleSearchRetrieval
            });
        }
        let toolConfig;
        if (functionCallingConfig) {
            toolConfig = {
                functionCallingConfig: {
                    allowedFunctionNames: functionCallingConfig.allowedFunctionNames,
                    mode: toFunctionModeEnum(functionCallingConfig.mode)
                }
            };
        } else if (request.toolChoice) {
            toolConfig = {
                functionCallingConfig: {
                    mode: toGeminiFunctionModeEnum(request.toolChoice)
                }
            };
        }
        const jsonMode = request.output?.format === "json" || request.output?.contentType === "application/json" && tools.length === 0;
        const generationConfig = {
            ...restOfConfigOptions,
            candidateCount: request.candidates || void 0,
            responseMimeType: jsonMode ? "application/json" : void 0
        };
        if (request.output?.constrained && jsonMode) {
            generationConfig.responseSchema = cleanSchema(request.output.schema);
        }
        const msg = toGeminiMessage(messages[messages.length - 1], model);
        const fromJSONModeScopedGeminiCandidate = (candidate)=>{
            return fromGeminiCandidate(candidate, jsonMode);
        };
        const chatRequest = {
            systemInstruction,
            generationConfig,
            tools: tools.length ? tools : void 0,
            toolConfig,
            history: messages.slice(0, -1).map((message)=>toGeminiMessage(message, model)),
            safetySettings: safetySettingsFromConfig
        };
        const modelVersion = versionFromConfig || model.version || apiModelName;
        const cacheConfigDetails = (0, import_utils.extractCacheConfig)(request);
        const { chatRequest: updatedChatRequest, cache } = await (0, import_context_caching.handleCacheIfNeeded)(apiKey, request, chatRequest, modelVersion, cacheConfigDetails);
        if (!apiKeyFromConfig && !apiKey) {
            throw new import_genkit.GenkitError({
                status: "INVALID_ARGUMENT",
                message: "GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time."
            });
        }
        const client = new import_generative_ai.GoogleGenerativeAI(apiKeyFromConfig || apiKey);
        let genModel;
        if (cache) {
            genModel = client.getGenerativeModelFromCachedContent(cache, {
                model: modelVersion
            }, options);
        } else {
            genModel = client.getGenerativeModel({
                model: modelVersion
            }, options);
        }
        const callGemini = async ()=>{
            let response;
            if (sendChunk) {
                const result = await genModel.startChat(updatedChatRequest).sendMessageStream(msg.parts, options);
                const chunks = [];
                for await (const item of result.stream){
                    chunks.push(item);
                    item.candidates?.forEach((candidate)=>{
                        const c = fromJSONModeScopedGeminiCandidate(candidate);
                        sendChunk({
                            index: c.index,
                            content: c.message.content
                        });
                    });
                }
                response = aggregateResponses(chunks);
            } else {
                const result = await genModel.startChat(updatedChatRequest).sendMessage(msg.parts, options);
                response = result.response;
            }
            const candidates = response.candidates || [];
            if (response.candidates?.["undefined"]) {
                candidates.push(response.candidates["undefined"]);
            }
            if (!candidates.length) {
                throw new import_genkit.GenkitError({
                    status: "FAILED_PRECONDITION",
                    message: "No valid candidates returned."
                });
            }
            const candidateData = candidates.map(fromJSONModeScopedGeminiCandidate) || [];
            return {
                candidates: candidateData,
                custom: response,
                usage: {
                    ...(0, import_model.getBasicUsageStats)(request.messages, candidateData),
                    inputTokens: response.usageMetadata?.promptTokenCount,
                    outputTokens: response.usageMetadata?.candidatesTokenCount,
                    totalTokens: response.usageMetadata?.totalTokenCount,
                    cachedContentTokens: response.usageMetadata?.cachedContentTokenCount
                }
            };
        };
        return debugTraces ? await (0, import_tracing.runInNewSpan)(ai.registry, {
            metadata: {
                name: sendChunk ? "sendMessageStream" : "sendMessage"
            }
        }, async (metadata)=>{
            metadata.input = {
                sdk: "@google/generative-ai",
                cache,
                model: genModel.model,
                chatOptions: updatedChatRequest,
                parts: msg.parts,
                options
            };
            const response = await callGemini();
            metadata.output = response.custom;
            return response;
        }) : await callGemini();
    });
}
function toFunctionModeEnum(configEnum) {
    if (configEnum === void 0) {
        return void 0;
    }
    switch(configEnum){
        case "MODE_UNSPECIFIED":
            {
                return import_generative_ai.FunctionCallingMode.MODE_UNSPECIFIED;
            }
        case "ANY":
            {
                return import_generative_ai.FunctionCallingMode.ANY;
            }
        case "AUTO":
            {
                return import_generative_ai.FunctionCallingMode.AUTO;
            }
        case "NONE":
            {
                return import_generative_ai.FunctionCallingMode.NONE;
            }
        default:
            throw new Error(`unsupported function calling mode: ${configEnum}`);
    }
}
function toGeminiFunctionModeEnum(genkitMode) {
    if (genkitMode === void 0) {
        return void 0;
    }
    switch(genkitMode){
        case "required":
            {
                return import_generative_ai.FunctionCallingMode.ANY;
            }
        case "auto":
            {
                return import_generative_ai.FunctionCallingMode.AUTO;
            }
        case "none":
            {
                return import_generative_ai.FunctionCallingMode.NONE;
            }
        default:
            throw new Error(`unsupported function calling mode: ${genkitMode}`);
    }
}
function aggregateResponses(responses) {
    const lastResponse = responses[responses.length - 1];
    const aggregatedResponse = {
        promptFeedback: lastResponse?.promptFeedback
    };
    for (const response of responses){
        if (response.candidates) {
            let candidateIndex = 0;
            for (const candidate of response.candidates){
                if (!aggregatedResponse.candidates) {
                    aggregatedResponse.candidates = [];
                }
                if (!aggregatedResponse.candidates[candidateIndex]) {
                    aggregatedResponse.candidates[candidateIndex] = {
                        index: candidateIndex
                    };
                }
                aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
                aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
                aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
                aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
                aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
                if (candidate.content && candidate.content.parts) {
                    if (!aggregatedResponse.candidates[candidateIndex].content) {
                        aggregatedResponse.candidates[candidateIndex].content = {
                            role: candidate.content.role || "user",
                            parts: []
                        };
                    }
                    for (const part of candidate.content.parts){
                        const newPart = {};
                        if (part.text) {
                            newPart.text = part.text;
                        }
                        if (part.functionCall) {
                            newPart.functionCall = part.functionCall;
                        }
                        if (part.executableCode) {
                            newPart.executableCode = part.executableCode;
                        }
                        if (part.codeExecutionResult) {
                            newPart.codeExecutionResult = part.codeExecutionResult;
                        }
                        if (Object.keys(newPart).length === 0) {
                            newPart.text = "";
                        }
                        aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
                    }
                }
            }
            candidateIndex++;
        }
        if (response.usageMetadata) {
            aggregatedResponse.usageMetadata = response.usageMetadata;
        }
    }
    return aggregatedResponse;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GENERIC_GEMINI_MODEL,
    GeminiConfigSchema,
    GeminiGemmaConfigSchema,
    GeminiTtsConfigSchema,
    SUPPORTED_GEMINI_MODELS,
    aggregateResponses,
    cleanSchema,
    defineGoogleAIModel,
    fromGeminiCandidate,
    gemini,
    gemini10Pro,
    gemini15Flash,
    gemini15Flash8b,
    gemini15Pro,
    gemini20Flash,
    gemini20FlashExp,
    gemini20FlashLite,
    gemini20ProExp0205,
    gemini25Flash,
    gemini25FlashPreview0417,
    gemini25FlashPreviewTts,
    gemini25Pro,
    gemini25ProExp0325,
    gemini25ProPreview0325,
    gemini25ProPreviewTts,
    gemma312bit,
    gemma31bit,
    gemma327bit,
    gemma34bit,
    gemma3ne4bit,
    toGeminiMessage,
    toGeminiSystemInstruction,
    toGeminiTool
}); //# sourceMappingURL=gemini.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/predict.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var predict_exports = {};
__export(predict_exports, {
    checkOp: ()=>checkOp,
    predictModel: ()=>predictModel
});
module.exports = __toCommonJS(predict_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
function predictEndpoint(options) {
    return `https://generativelanguage.googleapis.com/${options.apiVersion}/models/${options.model}:${options.method}?key=${options.apiKey}`;
}
function opCheckEndpoint(options) {
    return `https://generativelanguage.googleapis.com/${options.apiVersion}/${options.operation}?key=${options.apiKey}`;
}
function predictModel(model, apiKey, method) {
    return async (instances, parameters)=>{
        const fetch = (await __turbopack_context__.r("[project]/node_modules/node-fetch/src/index.js [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i)).default;
        const req = {
            instances,
            parameters
        };
        const response = await fetch(predictEndpoint({
            model,
            apiVersion: "v1beta",
            apiKey,
            method
        }), {
            method: "POST",
            body: JSON.stringify(req),
            headers: {
                "Content-Type": "application/json",
                "X-Goog-Api-Client": import_genkit.GENKIT_CLIENT_HEADER
            }
        });
        if (!response.ok) {
            throw new Error(`Error from Gemini AI predict: HTTP ${response.status}: ${await response.text()}`);
        }
        return await response.json();
    };
}
async function checkOp(operation, apiKey) {
    const fetch = (await __turbopack_context__.r("[project]/node_modules/node-fetch/src/index.js [app-rsc] (ecmascript, async loader)")(__turbopack_context__.i)).default;
    const response = await fetch(opCheckEndpoint({
        apiVersion: "v1beta",
        operation,
        apiKey
    }), {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
            "X-Goog-Api-Client": import_genkit.GENKIT_CLIENT_HEADER
        }
    });
    if (!response.ok) {
        throw new Error(`Error from operation API: HTTP ${response.status}: ${await response.text()}`);
    }
    return await response.json();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    checkOp,
    predictModel
}); //# sourceMappingURL=predict.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/imagen.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var imagen_exports = {};
__export(imagen_exports, {
    GENERIC_IMAGEN_INFO: ()=>GENERIC_IMAGEN_INFO,
    ImagenConfigSchema: ()=>ImagenConfigSchema,
    defineImagenModel: ()=>defineImagenModel
});
module.exports = __toCommonJS(imagen_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_model = __turbopack_context__.r("[project]/node_modules/genkit/lib/model.js [app-rsc] (ecmascript)");
var import_common = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)");
var import_predict = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/predict.js [app-rsc] (ecmascript)");
const ImagenConfigSchema = import_genkit.z.object({
    numberOfImages: import_genkit.z.number().describe("The number of images to generate, from 1 to 4 (inclusive). The default is 1.").optional(),
    aspectRatio: import_genkit.z.enum([
        "1:1",
        "9:16",
        "16:9",
        "3:4",
        "4:3"
    ]).describe("Desired aspect ratio of the output image.").optional(),
    personGeneration: import_genkit.z.enum([
        "dont_allow",
        "allow_adult",
        "allow_all"
    ]).describe("Control if/how images of people will be generated by the model.").optional()
}).passthrough();
function toParameters(request) {
    const out = {
        sampleCount: request.config?.numberOfImages ?? 1,
        ...request?.config
    };
    for(const k in out){
        if (!out[k]) delete out[k];
    }
    return out;
}
function extractText(request) {
    return request.messages.at(-1).content.map((c)=>c.text || "").join("");
}
function extractBaseImage(request) {
    return request.messages.at(-1)?.content.find((p)=>!!p.media)?.media?.url.split(",")[1];
}
const GENERIC_IMAGEN_INFO = {
    label: `Google AI - Generic Imagen`,
    supports: {
        media: true,
        multiturn: false,
        tools: false,
        systemRole: false,
        output: [
            "media"
        ]
    }
};
function defineImagenModel(ai, name, apiKey) {
    if (apiKey !== false) {
        apiKey = apiKey || (0, import_common.getApiKeyFromEnvVar)();
        if (!apiKey) {
            throw new import_genkit.GenkitError({
                status: "FAILED_PRECONDITION",
                message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
            });
        }
    }
    const modelName = `googleai/${name}`;
    const model = (0, import_model.modelRef)({
        name: modelName,
        info: {
            ...GENERIC_IMAGEN_INFO,
            label: `Google AI - ${name}`
        },
        configSchema: ImagenConfigSchema
    });
    return ai.defineModel({
        name: modelName,
        ...model.info,
        configSchema: ImagenConfigSchema
    }, async (request)=>{
        const instance = {
            prompt: extractText(request)
        };
        const baseImage = extractBaseImage(request);
        if (baseImage) {
            instance.image = {
                bytesBase64Encoded: baseImage
            };
        }
        const predictClient = (0, import_predict.predictModel)(model.version || name, apiKey, "predict");
        const response = await predictClient([
            instance
        ], toParameters(request));
        if (!response.predictions || response.predictions.length == 0) {
            throw new Error("Model returned no predictions. Possibly due to content filters.");
        }
        const message = {
            role: "model",
            content: []
        };
        response.predictions.forEach((p, i)=>{
            const b64data = p.bytesBase64Encoded;
            const mimeType = p.mimeType;
            message.content.push({
                media: {
                    url: `data:${mimeType};base64,${b64data}`,
                    contentType: mimeType
                }
            });
        });
        return {
            finishReason: "stop",
            message,
            usage: (0, import_model.getBasicUsageStats)(request.messages, message),
            custom: response
        };
    });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GENERIC_IMAGEN_INFO,
    ImagenConfigSchema,
    defineImagenModel
}); //# sourceMappingURL=imagen.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/list-models.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var list_models_exports = {};
__export(list_models_exports, {
    listModels: ()=>listModels
});
module.exports = __toCommonJS(list_models_exports);
async function listModels(baseUrl, apiKey) {
    const res = await fetch(`${baseUrl}/v1beta/models?pageSize=1000&key=${apiKey}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json"
        }
    });
    const modelResponse = JSON.parse(await res.text());
    return modelResponse.models;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    listModels
}); //# sourceMappingURL=list-models.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/veo.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var veo_exports = {};
__export(veo_exports, {
    GENERIC_VEO_INFO: ()=>GENERIC_VEO_INFO,
    VeoConfigSchema: ()=>VeoConfigSchema,
    defineVeoModel: ()=>defineVeoModel
});
module.exports = __toCommonJS(veo_exports);
var import_genkit = __turbopack_context__.r("[project]/node_modules/genkit/lib/index.js [app-rsc] (ecmascript)");
var import_model = __turbopack_context__.r("[project]/node_modules/genkit/lib/model.js [app-rsc] (ecmascript)");
var import_common = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)");
var import_predict = __turbopack_context__.r("[project]/node_modules/@genkit-ai/googleai/lib/predict.js [app-rsc] (ecmascript)");
const VeoConfigSchema = import_genkit.z.object({
    // NOTE: Documentation notes numberOfVideos parameter to pick the number of
    // output videos, but this setting does not seem to work
    negativePrompt: import_genkit.z.string().optional(),
    aspectRatio: import_genkit.z.enum([
        "9:16",
        "16:9"
    ]).describe("Desired aspect ratio of the output video.").optional(),
    personGeneration: import_genkit.z.enum([
        "dont_allow",
        "allow_adult",
        "allow_all"
    ]).describe("Control if/how images of people will be generated by the model.").optional(),
    durationSeconds: import_genkit.z.number().step(1).min(5).max(8).describe("Length of each output video in seconds, between 5 and 8.").optional(),
    enhance_prompt: import_genkit.z.boolean().describe("Enable or disable the prompt rewriter. Enabled by default.").optional()
}).passthrough();
function extractText(request) {
    return request.messages.at(-1).content.map((c)=>c.text || "").join("");
}
function toParameters(request) {
    const out = {
        ...request?.config
    };
    for(const k in out){
        if (!out[k]) delete out[k];
    }
    return out;
}
function extractImage(request) {
    const media = request.messages.at(-1)?.content.find((p)=>!!p.media)?.media;
    if (media) {
        const img = media?.url.split(",")[1];
        return {
            bytesBase64Encoded: img,
            mimeType: media.contentType
        };
    }
    return void 0;
}
const GENERIC_VEO_INFO = {
    label: `Google AI - Generic Veo`,
    supports: {
        media: true,
        multiturn: false,
        tools: false,
        systemRole: false,
        output: [
            "media"
        ],
        longRunning: true
    }
};
function defineVeoModel(ai, name, apiKey) {
    if (apiKey !== false) {
        apiKey = apiKey || (0, import_common.getApiKeyFromEnvVar)();
        if (!apiKey) {
            throw new import_genkit.GenkitError({
                status: "FAILED_PRECONDITION",
                message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
            });
        }
    }
    const modelName = `googleai/${name}`;
    const model = (0, import_model.modelRef)({
        name: modelName,
        info: {
            ...GENERIC_VEO_INFO,
            label: `Google AI - ${name}`
        },
        configSchema: VeoConfigSchema
    });
    return ai.defineBackgroundModel({
        name: modelName,
        ...model.info,
        configSchema: VeoConfigSchema,
        async start (request) {
            const instance = {
                prompt: extractText(request)
            };
            const image = extractImage(request);
            if (image) {
                instance.image = image;
            }
            const predictClient = (0, import_predict.predictModel)(model.version || name, apiKey, "predictLongRunning");
            const response = await predictClient([
                instance
            ], toParameters(request));
            return toGenkitOp(response);
        },
        async check (operation) {
            const newOp = await (0, import_predict.checkOp)(operation.id, apiKey);
            return toGenkitOp(newOp);
        }
    });
}
function toGenkitOp(apiOp) {
    const res = {
        id: apiOp.name
    };
    if (apiOp.done !== void 0) {
        res.done = apiOp.done;
    }
    if (apiOp.error) {
        res.error = {
            message: apiOp.error.message
        };
    }
    if (apiOp.response && apiOp.response.generateVideoResponse && apiOp.response.generateVideoResponse.generatedSamples) {
        res.output = {
            finishReason: "stop",
            raw: apiOp.response,
            message: {
                role: "model",
                content: apiOp.response.generateVideoResponse.generatedSamples.map((s)=>{
                    return {
                        media: {
                            url: s.video.uri
                        }
                    };
                })
            }
        };
    }
    return res;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    GENERIC_VEO_INFO,
    VeoConfigSchema,
    defineVeoModel
}); //# sourceMappingURL=veo.js.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/index.mjs [app-rsc] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>index_default),
    "googleAI": (()=>googleAI),
    "googleAIPlugin": (()=>googleAIPlugin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/index.mjs [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/common.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$logging$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/logging.mjs [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$core$2f$lib$2f$logging$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/core/lib/logging.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$model$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/model.mjs [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$ai$2f$lib$2f$model$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/ai/lib/model.mjs [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$plugin$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/plugin.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/embedder.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/gemini.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$imagen$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/imagen.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$list$2d$models$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/list-models.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$veo$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/veo.js [app-rsc] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
async function initializer(ai, options) {
    let apiVersions = [
        "v1"
    ];
    if (options?.apiVersion) {
        if (Array.isArray(options?.apiVersion)) {
            apiVersions = options?.apiVersion;
        } else {
            apiVersions = [
                options?.apiVersion
            ];
        }
    }
    if (apiVersions.includes("v1beta")) {
        Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_GEMINI_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])({
                ai,
                name,
                apiKey: options?.apiKey,
                apiVersion: "v1beta",
                baseUrl: options?.baseUrl,
                debugTraces: options?.experimental_debugTraces
            }));
    }
    if (apiVersions.includes("v1")) {
        Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_GEMINI_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])({
                ai,
                name,
                apiKey: options?.apiKey,
                apiVersion: void 0,
                baseUrl: options?.baseUrl,
                debugTraces: options?.experimental_debugTraces
            }));
        Object.keys(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SUPPORTED_MODELS"]).forEach((name)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIEmbedder"])(ai, name, {
                apiKey: options?.apiKey
            }));
    }
    if (options?.models) {
        for (const modelOrRef of options?.models){
            const modelName = typeof modelOrRef === "string" ? modelOrRef : // strip out the `googleai/` prefix
            modelOrRef.name.split("/")[1];
            const modelRef2 = typeof modelOrRef === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["gemini"])(modelOrRef) : modelOrRef;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])({
                ai,
                name: modelName,
                apiKey: options?.apiKey,
                baseUrl: options?.baseUrl,
                info: {
                    ...modelRef2.info,
                    label: `Google AI - ${modelName}`
                },
                debugTraces: options?.experimental_debugTraces
            });
        }
    }
}
async function resolver(ai, actionType, actionName, options) {
    if (actionType === "embedder") {
        resolveEmbedder(ai, actionName, options);
    } else if (actionName.startsWith("veo")) {
        if (actionType === "background-model") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$veo$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineVeoModel"])(ai, actionName, options?.apiKey);
        }
    } else if (actionType === "model") {
        resolveModel(ai, actionName, options);
    }
}
function resolveModel(ai, actionName, options) {
    if (actionName.startsWith("imagen")) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$imagen$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineImagenModel"])(ai, actionName, options?.apiKey);
        return;
    }
    const modelRef2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["gemini"])(actionName);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIModel"])({
        ai,
        name: modelRef2.name,
        apiKey: options?.apiKey,
        baseUrl: options?.baseUrl,
        info: {
            ...modelRef2.info,
            label: `Google AI - ${actionName}`
        },
        debugTraces: options?.experimental_debugTraces
    });
}
function resolveEmbedder(ai, actionName, options) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["defineGoogleAIEmbedder"])(ai, `googleai/${actionName}`, {
        apiKey: options?.apiKey
    });
}
async function listActions(options) {
    const apiKey = options?.apiKey || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getApiKeyFromEnvVar"])();
    if (!apiKey) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$core$2f$lib$2f$logging$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["logger"].error("Pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.");
        return [];
    }
    const models = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$list$2d$models$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["listModels"])(options?.baseUrl || "https://generativelanguage.googleapis.com", apiKey);
    return [
        // Imagen
        ...models.filter((m)=>m.supportedGenerationMethods.includes("predict") && m.name.includes("imagen")).filter((m)=>!m.description || !m.description.includes("deprecated")).map((m)=>{
            const name = m.name.split("/").at(-1);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["modelActionMetadata"])({
                name: `googleai/${name}`,
                info: {
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$imagen$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["GENERIC_IMAGEN_INFO"]
                },
                configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$imagen$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ImagenConfigSchema"]
            });
        }),
        // Veo
        ...models.filter((m)=>m.supportedGenerationMethods.includes("predictLongRunning") && m.name.includes("veo")).filter((m)=>!m.description || !m.description.includes("deprecated")).map((m)=>{
            const name = m.name.split("/").at(-1);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["modelActionMetadata"])({
                name: `googleai/${name}`,
                info: {
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$veo$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["GENERIC_VEO_INFO"]
                },
                configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$veo$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VeoConfigSchema"],
                background: true
            });
        }),
        // Models
        ...models.filter((m)=>m.supportedGenerationMethods.includes("generateContent")).filter((m)=>!m.description || !m.description.includes("deprecated")).map((m)=>{
            const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["gemini"])(m.name.startsWith("models/") ? m.name.substring("models/".length) : m.name);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["modelActionMetadata"])({
                name: ref.name,
                info: ref.info,
                configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["GeminiConfigSchema"]
            });
        }),
        // Embedders
        ...models.filter((m)=>m.supportedGenerationMethods.includes("embedContent")).filter((m)=>!m.description || !m.description.includes("deprecated")).map((m)=>{
            const name = "googleai/" + (m.name.startsWith("models/") ? m.name.substring("models/".length) : m.name);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["embedderActionMetadata"])({
                name,
                configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["GeminiEmbeddingConfigSchema"],
                info: {
                    dimensions: 768,
                    label: `Google Gen AI - ${name}`,
                    supports: {
                        input: [
                            "text"
                        ]
                    }
                }
            });
        })
    ];
}
function googleAIPlugin(options) {
    let listActionsCache;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$plugin$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["genkitPlugin"])("googleai", async (ai)=>await initializer(ai, options), async (ai, actionType, actionName)=>await resolver(ai, actionType, actionName, options), async ()=>{
        if (listActionsCache) return listActionsCache;
        listActionsCache = await listActions(options);
        return listActionsCache;
    });
}
const googleAI = googleAIPlugin;
googleAI.model = (name, config)=>{
    if (name.startsWith("imagen")) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$ai$2f$lib$2f$model$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["modelRef"])({
            name: `googleai/${name}`,
            config,
            configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$imagen$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ImagenConfigSchema"]
        });
    }
    if (name.startsWith("veo")) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$ai$2f$lib$2f$model$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["modelRef"])({
            name: `googleai/${name}`,
            config,
            configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$veo$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["VeoConfigSchema"]
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$ai$2f$lib$2f$model$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["modelRef"])({
        name: `googleai/${name}`,
        config,
        configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["GeminiConfigSchema"]
    });
};
googleAI.embedder = (name, config)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["embedderRef"])({
        name: `googleai/${name}`,
        config,
        configSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["GeminiEmbeddingConfigSchema"]
    });
};
var index_default = googleAI;
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@genkit-ai/googleai/lib/index.mjs [app-rsc] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/index.mjs [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$logging$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/logging.mjs [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$model$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/model.mjs [app-rsc] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$genkit$2f$lib$2f$plugin$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/genkit/lib/plugin.mjs [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$common$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/common.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$embedder$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/embedder.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$gemini$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/gemini.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$imagen$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/imagen.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$list$2d$models$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/list-models.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$veo$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/veo.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$genkit$2d$ai$2f$googleai$2f$lib$2f$index$2e$mjs__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@genkit-ai/googleai/lib/index.mjs [app-rsc] (ecmascript) <locals>");
}}),

};

//# sourceMappingURL=node_modules_%40genkit-ai_2d5823b9._.js.map