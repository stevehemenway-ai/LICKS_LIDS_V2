module.exports = {

"[project]/node_modules/@google-cloud/promisify/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* eslint-disable prefer-rest-params */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.promisify = promisify;
exports.promisifyAll = promisifyAll;
exports.callbackify = callbackify;
exports.callbackifyAll = callbackifyAll;
/**
 * Wraps a callback style function to conditionally return a promise.
 *
 * @param {function} originalMethod - The method to promisify.
 * @param {object=} options - Promise options.
 * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.
 * @return {function} wrapped
 */ function promisify(originalMethod, options) {
    if (originalMethod.promisified_) {
        return originalMethod;
    }
    options = options || {};
    const slice = Array.prototype.slice;
    // tslint:disable-next-line:no-any
    const wrapper = function() {
        let last;
        for(last = arguments.length - 1; last >= 0; last--){
            const arg = arguments[last];
            if (typeof arg === 'undefined') {
                continue; // skip trailing undefined.
            }
            if (typeof arg !== 'function') {
                break; // non-callback last argument found.
            }
            return originalMethod.apply(this, arguments);
        }
        // peel trailing undefined.
        const args = slice.call(arguments, 0, last + 1);
        // tslint:disable-next-line:variable-name
        let PromiseCtor = Promise;
        // Because dedupe will likely create a single install of
        // @google-cloud/common to be shared amongst all modules, we need to
        // localize it at the Service level.
        if (this && this.Promise) {
            PromiseCtor = this.Promise;
        }
        return new PromiseCtor((resolve, reject)=>{
            // tslint:disable-next-line:no-any
            args.push((...args)=>{
                const callbackArgs = slice.call(args);
                const err = callbackArgs.shift();
                if (err) {
                    return reject(err);
                }
                if (options.singular && callbackArgs.length === 1) {
                    resolve(callbackArgs[0]);
                } else {
                    resolve(callbackArgs);
                }
            });
            originalMethod.apply(this, args);
        });
    };
    wrapper.promisified_ = true;
    return wrapper;
}
/**
 * Promisifies certain Class methods. This will not promisify private or
 * streaming methods.
 *
 * @param {module:common/service} Class - Service class.
 * @param {object=} options - Configuration object.
 */ // tslint:disable-next-line:variable-name
function promisifyAll(Class, options) {
    const exclude = options && options.exclude || [];
    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);
    const methods = ownPropertyNames.filter((methodName)=>{
        // clang-format off
        return !exclude.includes(methodName) && typeof Class.prototype[methodName] === 'function' && // is it a function?
        !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) // is it promisable?
        ;
    // clang-format on
    });
    methods.forEach((methodName)=>{
        const originalMethod = Class.prototype[methodName];
        if (!originalMethod.promisified_) {
            Class.prototype[methodName] = exports.promisify(originalMethod, options);
        }
    });
}
/**
 * Wraps a promisy type function to conditionally call a callback function.
 *
 * @param {function} originalMethod - The method to callbackify.
 * @param {object=} options - Callback options.
 * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.
 * @return {function} wrapped
 */ function callbackify(originalMethod) {
    if (originalMethod.callbackified_) {
        return originalMethod;
    }
    // tslint:disable-next-line:no-any
    const wrapper = function() {
        if (typeof arguments[arguments.length - 1] !== 'function') {
            return originalMethod.apply(this, arguments);
        }
        const cb = Array.prototype.pop.call(arguments);
        originalMethod.apply(this, arguments).then(// tslint:disable-next-line:no-any
        (res)=>{
            res = Array.isArray(res) ? res : [
                res
            ];
            cb(null, ...res);
        }, (err)=>cb(err));
    };
    wrapper.callbackified_ = true;
    return wrapper;
}
/**
 * Callbackifies certain Class methods. This will not callbackify private or
 * streaming methods.
 *
 * @param {module:common/service} Class - Service class.
 * @param {object=} options - Configuration object.
 */ function callbackifyAll(// tslint:disable-next-line:variable-name
Class, options) {
    const exclude = options && options.exclude || [];
    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);
    const methods = ownPropertyNames.filter((methodName)=>{
        // clang-format off
        return !exclude.includes(methodName) && typeof Class.prototype[methodName] === 'function' && // is it a function?
        !/^_|(Stream|_)|^constructor$/.test(methodName) // is it callbackifyable?
        ;
    // clang-format on
    });
    methods.forEach((methodName)=>{
        const originalMethod = Class.prototype[methodName];
        if (!originalMethod.callbackified_) {
            Class.prototype[methodName] = exports.callbackify(originalMethod);
        }
    });
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/projectify/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MissingProjectIdError = exports.replaceProjectIdToken = void 0;
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
// Copyright 2014 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * Populate the `{{projectId}}` placeholder.
 *
 * @throws {Error} If a projectId is required, but one is not provided.
 *
 * @param {*} - Any input value that may contain a placeholder. Arrays and objects will be looped.
 * @param {string} projectId - A projectId. If not provided
 * @return {*} - The original argument with all placeholders populated.
 */ // eslint-disable-next-line  @typescript-eslint/no-explicit-any
function replaceProjectIdToken(value, projectId) {
    if (Array.isArray(value)) {
        value = value.map((v)=>replaceProjectIdToken(v, projectId));
    }
    if (value !== null && typeof value === 'object' && !(value instanceof Buffer) && !(value instanceof stream_1.Stream) && typeof value.hasOwnProperty === 'function') {
        for(const opt in value){
            // eslint-disable-next-line no-prototype-builtins
            if (value.hasOwnProperty(opt)) {
                value[opt] = replaceProjectIdToken(value[opt], projectId);
            }
        }
    }
    if (typeof value === 'string' && value.indexOf('{{projectId}}') > -1) {
        if (!projectId || projectId === '{{projectId}}') {
            throw new MissingProjectIdError();
        }
        value = value.replace(/{{projectId}}/g, projectId);
    }
    return value;
}
exports.replaceProjectIdToken = replaceProjectIdToken;
/**
 * Custom error type for missing project ID errors.
 */ class MissingProjectIdError extends Error {
    constructor(){
        super(...arguments);
        this.message = `Sorry, we cannot connect to Cloud Services without a project
    ID. You may specify one with an environment variable named
    "GOOGLE_CLOUD_PROJECT".`.replace(/ +/g, ' ');
    }
}
exports.MissingProjectIdError = MissingProjectIdError; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/common/build/src/service.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Service = exports.DEFAULT_PROJECT_ID_TOKEN = void 0;
/*!
 * @module common/service
 */ const arrify = __turbopack_context__.r("[project]/node_modules/arrify/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/util.js [app-rsc] (ecmascript)");
exports.DEFAULT_PROJECT_ID_TOKEN = '{{projectId}}';
class Service {
    /**
     * Service is a base class, meant to be inherited from by a "service," like
     * BigQuery or Storage.
     *
     * This handles making authenticated requests by exposing a `makeReq_`
     * function.
     *
     * @constructor
     * @alias module:common/service
     *
     * @param {object} config - Configuration object.
     * @param {string} config.baseUrl - The base URL to make API requests to.
     * @param {string[]} config.scopes - The scopes required for the request.
     * @param {object=} options - [Configuration object](#/docs).
     */ constructor(config, options = {}){
        this.baseUrl = config.baseUrl;
        this.apiEndpoint = config.apiEndpoint;
        this.timeout = options.timeout;
        this.globalInterceptors = arrify(options.interceptors_);
        this.interceptors = [];
        this.packageJson = config.packageJson;
        this.projectId = options.projectId || exports.DEFAULT_PROJECT_ID_TOKEN;
        this.projectIdRequired = config.projectIdRequired !== false;
        this.providedUserAgent = options.userAgent;
        const reqCfg = extend({}, config, {
            projectIdRequired: this.projectIdRequired,
            projectId: this.projectId,
            authClient: options.authClient,
            credentials: options.credentials,
            keyFile: options.keyFilename,
            email: options.email,
            token: options.token
        });
        this.makeAuthenticatedRequest = util_1.util.makeAuthenticatedRequestFactory(reqCfg);
        this.authClient = this.makeAuthenticatedRequest.authClient;
        this.getCredentials = this.makeAuthenticatedRequest.getCredentials;
        const isCloudFunctionEnv = !!process.env.FUNCTION_NAME;
        if (isCloudFunctionEnv) {
            this.interceptors.push({
                request (reqOpts) {
                    reqOpts.forever = false;
                    return reqOpts;
                }
            });
        }
    }
    /**
     * Return the user's custom request interceptors.
     */ getRequestInterceptors() {
        // Interceptors should be returned in the order they were assigned.
        return [].slice.call(this.globalInterceptors).concat(this.interceptors).filter((interceptor)=>typeof interceptor.request === 'function').map((interceptor)=>interceptor.request);
    }
    getProjectId(callback) {
        if (!callback) {
            return this.getProjectIdAsync();
        }
        this.getProjectIdAsync().then((p)=>callback(null, p), callback);
    }
    async getProjectIdAsync() {
        const projectId = await this.authClient.getProjectId();
        if (this.projectId === exports.DEFAULT_PROJECT_ID_TOKEN && projectId) {
            this.projectId = projectId;
        }
        return this.projectId;
    }
    request_(reqOpts, callback) {
        reqOpts = extend(true, {}, reqOpts, {
            timeout: this.timeout
        });
        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;
        const uriComponents = [
            this.baseUrl
        ];
        if (this.projectIdRequired) {
            if (reqOpts.projectId) {
                uriComponents.push('projects');
                uriComponents.push(reqOpts.projectId);
            } else {
                uriComponents.push('projects');
                uriComponents.push(this.projectId);
            }
        }
        uriComponents.push(reqOpts.uri);
        if (isAbsoluteUrl) {
            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));
        }
        reqOpts.uri = uriComponents.map((uriComponent)=>{
            const trimSlashesRegex = /^\/*|\/*$/g;
            return uriComponent.replace(trimSlashesRegex, '');
        }).join('/')// Some URIs have colon separators.
        // Bad: https://.../projects/:list
        // Good: https://.../projects:list
        .replace(/\/:/g, ':');
        const requestInterceptors = this.getRequestInterceptors();
        arrify(reqOpts.interceptors_).forEach((interceptor)=>{
            if (typeof interceptor.request === 'function') {
                requestInterceptors.push(interceptor.request);
            }
        });
        requestInterceptors.forEach((requestInterceptor)=>{
            reqOpts = requestInterceptor(reqOpts);
        });
        delete reqOpts.interceptors_;
        const pkg = this.packageJson;
        let userAgent = util_1.util.getUserAgentFromPackageJson(pkg);
        if (this.providedUserAgent) {
            userAgent = `${this.providedUserAgent} ${userAgent}`;
        }
        reqOpts.headers = extend({}, reqOpts.headers, {
            'User-Agent': userAgent,
            'x-goog-api-client': `gl-node/${process.versions.node} gccl/${pkg.version}`
        });
        if (reqOpts.shouldReturnStream) {
            return this.makeAuthenticatedRequest(reqOpts);
        } else {
            this.makeAuthenticatedRequest(reqOpts, callback);
        }
    }
    /**
     * Make an authenticated API request.
     *
     * @param {object} reqOpts - Request options that are passed to `request`.
     * @param {string} reqOpts.uri - A URI relative to the baseUrl.
     * @param {function} callback - The callback function passed to `request`.
     */ request(reqOpts, callback) {
        Service.prototype.request_.call(this, reqOpts, callback);
    }
    /**
     * Make an authenticated API request.
     *
     * @param {object} reqOpts - Request options that are passed to `request`.
     * @param {string} reqOpts.uri - A URI relative to the baseUrl.
     */ requestStream(reqOpts) {
        const opts = extend(true, reqOpts, {
            shouldReturnStream: true
        });
        return Service.prototype.request_.call(this, opts);
    }
}
exports.Service = Service; //# sourceMappingURL=service.js.map
}}),
"[project]/node_modules/@google-cloud/common/build/src/util.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2014 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.util = exports.Util = exports.PartialFailureError = exports.ApiError = void 0;
/*!
 * @module common/util
 */ const projectify_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/projectify/build/src/index.js [app-rsc] (ecmascript)");
const htmlEntities = __turbopack_context__.r("[project]/node_modules/html-entities/dist/commonjs/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const google_auth_library_1 = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-rsc] (ecmascript)");
const retryRequest = __turbopack_context__.r("[project]/node_modules/retry-request/index.js [app-rsc] (ecmascript)");
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const teeny_request_1 = __turbopack_context__.r("[project]/node_modules/teeny-request/build/src/index.js [app-rsc] (ecmascript)");
const service_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/service.js [app-rsc] (ecmascript)");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const duplexify = __turbopack_context__.r("[project]/node_modules/duplexify/index.js [app-rsc] (ecmascript)");
const requestDefaults = {
    timeout: 60000,
    gzip: true,
    forever: true,
    pool: {
        maxSockets: Infinity
    }
};
/**
 * Default behavior: Automatically retry retriable server errors.
 *
 * @const {boolean}
 * @private
 */ const AUTO_RETRY_DEFAULT = true;
/**
 * Default behavior: Only attempt to retry retriable errors 3 times.
 *
 * @const {number}
 * @private
 */ const MAX_RETRY_DEFAULT = 3;
/**
 * Custom error type for API errors.
 *
 * @param {object} errorBody - Error object.
 */ class ApiError extends Error {
    constructor(errorBodyOrMessage){
        super();
        if (typeof errorBodyOrMessage !== 'object') {
            this.message = errorBodyOrMessage || '';
            return;
        }
        const errorBody = errorBodyOrMessage;
        this.code = errorBody.code;
        this.errors = errorBody.errors;
        this.response = errorBody.response;
        try {
            this.errors = JSON.parse(this.response.body).error.errors;
        } catch (e) {
            this.errors = errorBody.errors;
        }
        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);
        Error.captureStackTrace(this);
    }
    /**
     * Pieces together an error message by combining all unique error messages
     * returned from a single GoogleError
     *
     * @private
     *
     * @param {GoogleErrorBody} err The original error.
     * @param {GoogleInnerError[]} [errors] Inner errors, if any.
     * @returns {string}
     */ static createMultiErrorMessage(err, errors) {
        const messages = new Set();
        if (err.message) {
            messages.add(err.message);
        }
        if (errors && errors.length) {
            errors.forEach(({ message })=>messages.add(message));
        } else if (err.response && err.response.body) {
            messages.add(htmlEntities.decode(err.response.body.toString()));
        } else if (!err.message) {
            messages.add('A failure occurred during this request.');
        }
        let messageArr = Array.from(messages);
        if (messageArr.length > 1) {
            messageArr = messageArr.map((message, i)=>`    ${i + 1}. ${message}`);
            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\n');
            messageArr.push('\n');
        }
        return messageArr.join('\n');
    }
}
exports.ApiError = ApiError;
/**
 * Custom error type for partial errors returned from the API.
 *
 * @param {object} b - Error object.
 */ class PartialFailureError extends Error {
    constructor(b){
        super();
        const errorObject = b;
        this.errors = errorObject.errors;
        this.name = 'PartialFailureError';
        this.response = errorObject.response;
        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);
    }
}
exports.PartialFailureError = PartialFailureError;
class Util {
    constructor(){
        this.ApiError = ApiError;
        this.PartialFailureError = PartialFailureError;
    }
    /**
     * No op.
     *
     * @example
     * function doSomething(callback) {
     *   callback = callback || noop;
     * }
     */ noop() {}
    /**
     * Uniformly process an API response.
     *
     * @param {*} err - Error value.
     * @param {*} resp - Response value.
     * @param {*} body - Body value.
     * @param {function} callback - The callback function.
     */ handleResp(err, resp, body, callback) {
        callback = callback || util.noop;
        const parsedResp = extend(true, {
            err: err || null
        }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));
        // Assign the parsed body to resp.body, even if { json: false } was passed
        // as a request option.
        // We assume that nobody uses the previously unparsed value of resp.body.
        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {
            parsedResp.resp.body = parsedResp.body;
        }
        if (parsedResp.err && resp) {
            parsedResp.err.response = resp;
        }
        callback(parsedResp.err, parsedResp.body, parsedResp.resp);
    }
    /**
     * Sniff an incoming HTTP response message for errors.
     *
     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.
     * @return {object} parsedHttpRespMessage - The parsed response.
     * @param {?error} parsedHttpRespMessage.err - An error detected.
     * @param {object} parsedHttpRespMessage.resp - The original response object.
     */ parseHttpRespMessage(httpRespMessage) {
        const parsedHttpRespMessage = {
            resp: httpRespMessage
        };
        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {
            // Unknown error. Format according to ApiError standard.
            parsedHttpRespMessage.err = new ApiError({
                errors: new Array(),
                code: httpRespMessage.statusCode,
                message: httpRespMessage.statusMessage,
                response: httpRespMessage
            });
        }
        return parsedHttpRespMessage;
    }
    /**
     * Parse the response body from an HTTP request.
     *
     * @param {object} body - The response body.
     * @return {object} parsedHttpRespMessage - The parsed response.
     * @param {?error} parsedHttpRespMessage.err - An error detected.
     * @param {object} parsedHttpRespMessage.body - The original body value provided
     *     will try to be JSON.parse'd. If it's successful, the parsed value will
     * be returned here, otherwise the original value and an error will be returned.
     */ parseHttpRespBody(body) {
        const parsedHttpRespBody = {
            body
        };
        if (typeof body === 'string') {
            try {
                parsedHttpRespBody.body = JSON.parse(body);
            } catch (err) {
                parsedHttpRespBody.body = body;
            }
        }
        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {
            // Error from JSON API.
            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);
        }
        return parsedHttpRespBody;
    }
    /**
     * Take a Duplexify stream, fetch an authenticated connection header, and
     * create an outgoing writable stream.
     *
     * @param {Duplexify} dup - Duplexify stream.
     * @param {object} options - Configuration object.
     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.
     * @param {object} options.metadata - Metadata to send at the head of the request.
     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.
     * @param {string=} options.request.method - Default: "POST".
     * @param {string=} options.request.qs.uploadType - Default: "multipart".
     * @param {string=} options.streamContentType - Default: "application/octet-stream".
     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.
     */ makeWritableStream(dup, options, onComplete) {
        onComplete = onComplete || util.noop;
        const writeStream = new ProgressStream();
        writeStream.on('progress', (evt)=>dup.emit('progress', evt));
        dup.setWritable(writeStream);
        const defaultReqOpts = {
            method: 'POST',
            qs: {
                uploadType: 'multipart'
            },
            timeout: 0,
            maxRetries: 0
        };
        const metadata = options.metadata || {};
        const reqOpts = extend(true, defaultReqOpts, options.request, {
            multipart: [
                {
                    'Content-Type': 'application/json',
                    body: JSON.stringify(metadata)
                },
                {
                    'Content-Type': metadata.contentType || 'application/octet-stream',
                    body: writeStream
                }
            ]
        });
        options.makeAuthenticatedRequest(reqOpts, {
            onAuthenticated (err, authenticatedReqOpts) {
                if (err) {
                    dup.destroy(err);
                    return;
                }
                const request = teeny_request_1.teenyRequest.defaults(requestDefaults);
                request(authenticatedReqOpts, (err, resp, body)=>{
                    util.handleResp(err, resp, body, (err, data)=>{
                        if (err) {
                            dup.destroy(err);
                            return;
                        }
                        dup.emit('response', resp);
                        onComplete(data);
                    });
                });
            }
        });
    }
    /**
     * Returns true if the API request should be retried, given the error that was
     * given the first time the request was attempted. This is used for rate limit
     * related errors as well as intermittent server errors.
     *
     * @param {error} err - The API error to check if it is appropriate to retry.
     * @return {boolean} True if the API request should be retried, false otherwise.
     */ shouldRetryRequest(err) {
        if (err) {
            if ([
                408,
                429,
                500,
                502,
                503,
                504
            ].indexOf(err.code) !== -1) {
                return true;
            }
            if (err.errors) {
                for (const e of err.errors){
                    const reason = e.reason;
                    if (reason === 'rateLimitExceeded') {
                        return true;
                    }
                    if (reason === 'userRateLimitExceeded') {
                        return true;
                    }
                    if (reason && reason.includes('EAI_AGAIN')) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Get a function for making authenticated requests.
     *
     * @param {object} config - Configuration object.
     * @param {boolean=} config.autoRetry - Automatically retry requests if the
     *     response is related to rate limits or certain intermittent server
     * errors. We will exponentially backoff subsequent requests by default.
     * (default: true)
     * @param {object=} config.credentials - Credentials object.
     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.
     * @param {boolean=} config.useAuthWithCustomEndpoint - If true, will authenticate when using a custom endpoint. Default: false.
     * @param {string=} config.email - Account email address, required for PEM/P12 usage.
     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)
     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.
     * @param {array} config.scopes - Array of scopes required for the API.
     */ makeAuthenticatedRequestFactory(config) {
        const googleAutoAuthConfig = extend({}, config);
        if (googleAutoAuthConfig.projectId === service_1.DEFAULT_PROJECT_ID_TOKEN) {
            delete googleAutoAuthConfig.projectId;
        }
        let authClient;
        if (googleAutoAuthConfig.authClient instanceof google_auth_library_1.GoogleAuth) {
            // Use an existing `GoogleAuth`
            authClient = googleAutoAuthConfig.authClient;
        } else {
            // Pass an `AuthClient` to `GoogleAuth`, if available
            const config = {
                ...googleAutoAuthConfig,
                authClient: googleAutoAuthConfig.authClient
            };
            authClient = new google_auth_library_1.GoogleAuth(config);
        }
        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {
            let stream;
            let projectId;
            const reqConfig = extend({}, config);
            let activeRequest_;
            if (!optionsOrCallback) {
                stream = duplexify();
                reqConfig.stream = stream;
            }
            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;
            const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;
            async function setProjectId() {
                projectId = await authClient.getProjectId();
            }
            const onAuthenticated = async (err, authenticatedReqOpts)=>{
                const authLibraryError = err;
                const autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;
                if (autoAuthFailed) {
                    // Even though authentication failed, the API might not actually
                    // care.
                    authenticatedReqOpts = reqOpts;
                }
                if (!err || autoAuthFailed) {
                    try {
                        // Try with existing `projectId` value
                        authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);
                        err = null;
                    } catch (e) {
                        if (e instanceof projectify_1.MissingProjectIdError) {
                            // A `projectId` was required, but we don't have one.
                            try {
                                // Attempt to get the `projectId`
                                await setProjectId();
                                authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);
                                err = null;
                            } catch (e) {
                                // Re-use the "Could not load the default credentials error" if
                                // auto auth failed.
                                err = err || e;
                            }
                        } else {
                            // Some other error unrelated to missing `projectId`
                            err = err || e;
                        }
                    }
                }
                if (err) {
                    if (stream) {
                        stream.destroy(err);
                    } else {
                        const fn = options && options.onAuthenticated ? options.onAuthenticated : callback;
                        fn(err);
                    }
                    return;
                }
                if (options && options.onAuthenticated) {
                    options.onAuthenticated(null, authenticatedReqOpts);
                } else {
                    activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params)=>{
                        if (apiResponseError && apiResponseError.code === 401 && authLibraryError) {
                            // Re-use the "Could not load the default credentials error" if
                            // the API request failed due to missing credentials.
                            apiResponseError = authLibraryError;
                        }
                        callback(apiResponseError, ...params);
                    });
                }
            };
            const prepareRequest = async ()=>{
                try {
                    const getProjectId = async ()=>{
                        if (config.projectId && config.projectId !== service_1.DEFAULT_PROJECT_ID_TOKEN) {
                            // The user provided a project ID. We don't need to check with the
                            // auth client, it could be incorrect.
                            return config.projectId;
                        }
                        if (config.projectIdRequired === false) {
                            // A projectId is not required. Return the default.
                            return service_1.DEFAULT_PROJECT_ID_TOKEN;
                        }
                        return setProjectId();
                    };
                    const authorizeRequest = async ()=>{
                        if (reqConfig.customEndpoint && !reqConfig.useAuthWithCustomEndpoint) {
                            // Using a custom API override. Do not use `google-auth-library` for
                            // authentication. (ex: connecting to a local Datastore server)
                            return reqOpts;
                        } else {
                            return authClient.authorizeRequest(reqOpts);
                        }
                    };
                    const [_projectId, authorizedReqOpts] = await Promise.all([
                        getProjectId(),
                        authorizeRequest()
                    ]);
                    if (_projectId) {
                        projectId = _projectId;
                    }
                    return onAuthenticated(null, authorizedReqOpts);
                } catch (e) {
                    return onAuthenticated(e);
                }
            };
            prepareRequest();
            if (stream) {
                return stream;
            }
            return {
                abort () {
                    setImmediate(()=>{
                        if (activeRequest_) {
                            activeRequest_.abort();
                            activeRequest_ = null;
                        }
                    });
                }
            };
        }
        const mar = makeAuthenticatedRequest;
        mar.getCredentials = authClient.getCredentials.bind(authClient);
        mar.authClient = authClient;
        return mar;
    }
    /**
     * Make a request through the `retryRequest` module with built-in error
     * handling and exponential back off.
     *
     * @param {object} reqOpts - Request options in the format `request` expects.
     * @param {object=} config - Configuration object.
     * @param {boolean=} config.autoRetry - Automatically retry requests if the
     *     response is related to rate limits or certain intermittent server
     * errors. We will exponentially backoff subsequent requests by default.
     * (default: true)
     * @param {number=} config.maxRetries - Maximum number of automatic retries
     *     attempted before returning the error. (default: 3)
     * @param {object=} config.request - HTTP module for request calls.
     * @param {function} callback - The callback function.
     */ makeRequest(reqOpts, config, callback) {
        var _a, _b, _c, _d, _e, _f, _g;
        let autoRetryValue = AUTO_RETRY_DEFAULT;
        if (config.autoRetry !== undefined && ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined) {
            throw new ApiError('autoRetry is deprecated. Use retryOptions.autoRetry instead.');
        } else if (config.autoRetry !== undefined) {
            autoRetryValue = config.autoRetry;
        } else if (((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry) !== undefined) {
            autoRetryValue = config.retryOptions.autoRetry;
        }
        let maxRetryValue = MAX_RETRY_DEFAULT;
        if (config.maxRetries && ((_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetries)) {
            throw new ApiError('maxRetries is deprecated. Use retryOptions.maxRetries instead.');
        } else if (config.maxRetries) {
            maxRetryValue = config.maxRetries;
        } else if ((_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.maxRetries) {
            maxRetryValue = config.retryOptions.maxRetries;
        }
        const options = {
            request: teeny_request_1.teenyRequest.defaults(requestDefaults),
            retries: autoRetryValue !== false ? maxRetryValue : 0,
            noResponseRetries: autoRetryValue !== false ? maxRetryValue : 0,
            shouldRetryFn (httpRespMessage) {
                var _a, _b;
                const err = util.parseHttpRespMessage(httpRespMessage).err;
                if ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryableErrorFn) {
                    return err && ((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryableErrorFn(err));
                }
                return err && util.shouldRetryRequest(err);
            },
            maxRetryDelay: (_e = config.retryOptions) === null || _e === void 0 ? void 0 : _e.maxRetryDelay,
            retryDelayMultiplier: (_f = config.retryOptions) === null || _f === void 0 ? void 0 : _f.retryDelayMultiplier,
            totalTimeout: (_g = config.retryOptions) === null || _g === void 0 ? void 0 : _g.totalTimeout
        };
        if (typeof reqOpts.maxRetries === 'number') {
            options.retries = reqOpts.maxRetries;
        }
        if (!config.stream) {
            return retryRequest(reqOpts, options, (err, response, body)=>{
                util.handleResp(err, response, body, callback);
            });
        }
        const dup = config.stream;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let requestStream;
        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';
        if (isGetRequest) {
            requestStream = retryRequest(reqOpts, options);
            dup.setReadable(requestStream);
        } else {
            // Streaming writable HTTP requests cannot be retried.
            requestStream = options.request(reqOpts);
            dup.setWritable(requestStream);
        }
        // Replay the Request events back to the stream.
        requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));
        dup.abort = requestStream.abort;
        return dup;
    }
    /**
     * Decorate the options about to be made in a request.
     *
     * @param {object} reqOpts - The options to be passed to `request`.
     * @param {string} projectId - The project ID.
     * @return {object} reqOpts - The decorated reqOpts.
     */ decorateRequest(reqOpts, projectId) {
        delete reqOpts.autoPaginate;
        delete reqOpts.autoPaginateVal;
        delete reqOpts.objectMode;
        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {
            delete reqOpts.qs.autoPaginate;
            delete reqOpts.qs.autoPaginateVal;
            reqOpts.qs = (0, projectify_1.replaceProjectIdToken)(reqOpts.qs, projectId);
        }
        if (Array.isArray(reqOpts.multipart)) {
            reqOpts.multipart = reqOpts.multipart.map((part)=>{
                return (0, projectify_1.replaceProjectIdToken)(part, projectId);
            });
        }
        if (reqOpts.json !== null && typeof reqOpts.json === 'object') {
            delete reqOpts.json.autoPaginate;
            delete reqOpts.json.autoPaginateVal;
            reqOpts.json = (0, projectify_1.replaceProjectIdToken)(reqOpts.json, projectId);
        }
        reqOpts.uri = (0, projectify_1.replaceProjectIdToken)(reqOpts.uri, projectId);
        return reqOpts;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isCustomType(unknown, module) {
        function getConstructorName(obj) {
            return obj.constructor && obj.constructor.name.toLowerCase();
        }
        const moduleNameParts = module.split('/');
        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();
        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();
        if (subModuleName && getConstructorName(unknown) !== subModuleName) {
            return false;
        }
        let walkingModule = unknown;
        // eslint-disable-next-line no-constant-condition
        while(true){
            if (getConstructorName(walkingModule) === parentModuleName) {
                return true;
            }
            walkingModule = walkingModule.parent;
            if (!walkingModule) {
                return false;
            }
        }
    }
    /**
     * Create a properly-formatted User-Agent string from a package.json file.
     *
     * @param {object} packageJson - A module's package.json file.
     * @return {string} userAgent - The formatted User-Agent string.
     */ getUserAgentFromPackageJson(packageJson) {
        const hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.
        .replace('/', '-'); // For UA spec-compliance purposes.
        return hyphenatedPackageName + '/' + packageJson.version;
    }
    /**
     * Given two parameters, figure out if this is either:
     *  - Just a callback function
     *  - An options object, and then a callback function
     * @param optionsOrCallback An options object or callback.
     * @param cb A potentially undefined callback.
     */ maybeOptionsOrCallback(optionsOrCallback, cb) {
        return typeof optionsOrCallback === 'function' ? [
            {},
            optionsOrCallback
        ] : [
            optionsOrCallback,
            cb
        ];
    }
}
exports.Util = Util;
/**
 * Basic Passthrough Stream that records the number of bytes read
 * every time the cursor is moved.
 */ class ProgressStream extends stream_1.Transform {
    constructor(){
        super(...arguments);
        this.bytesRead = 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _transform(chunk, encoding, callback) {
        this.bytesRead += chunk.length;
        this.emit('progress', {
            bytesWritten: this.bytesRead,
            contentLength: '*'
        });
        this.push(chunk);
        callback();
    }
}
const util = new Util();
exports.util = util; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@google-cloud/common/build/src/service-object.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceObject = void 0;
/*!
 * @module common/service-object
 */ const promisify_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/promisify/build/src/index.js [app-rsc] (ecmascript)");
const arrify = __turbopack_context__.r("[project]/node_modules/arrify/index.js [app-rsc] (ecmascript)");
const events_1 = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/util.js [app-rsc] (ecmascript)");
/**
 * ServiceObject is a base class, meant to be inherited from by a "service
 * object," like a BigQuery dataset or Storage bucket.
 *
 * Most of the time, these objects share common functionality; they can be
 * created or deleted, and you can get or set their metadata.
 *
 * By inheriting from this class, a service object will be extended with these
 * shared behaviors. Note that any method can be overridden when the service
 * object requires specific behavior.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
class ServiceObject extends events_1.EventEmitter {
    /*
     * @constructor
     * @alias module:common/service-object
     *
     * @private
     *
     * @param {object} config - Configuration object.
     * @param {string} config.baseUrl - The base URL to make API requests to.
     * @param {string} config.createMethod - The method which creates this object.
     * @param {string=} config.id - The identifier of the object. For example, the
     *     name of a Storage bucket or Pub/Sub topic.
     * @param {object=} config.methods - A map of each method name that should be inherited.
     * @param {object} config.methods[].reqOpts - Default request options for this
     *     particular method. A common use case is when `setMetadata` requires a
     *     `PUT` method to override the default `PATCH`.
     * @param {object} config.parent - The parent service instance. For example, an
     *     instance of Storage if the object is Bucket.
     */ constructor(config){
        super();
        this.metadata = {};
        this.baseUrl = config.baseUrl;
        this.parent = config.parent; // Parent class.
        this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc).
        this.createMethod = config.createMethod;
        this.methods = config.methods || {};
        this.interceptors = [];
        this.pollIntervalMs = config.pollIntervalMs;
        this.projectId = config.projectId;
        if (config.methods) {
            // This filters the ServiceObject instance (e.g. a "File") to only have
            // the configured methods. We make a couple of exceptions for core-
            // functionality ("request()" and "getRequestInterceptors()")
            Object.getOwnPropertyNames(ServiceObject.prototype).filter((methodName)=>{
                return(// All ServiceObjects need `request` and `getRequestInterceptors`.
                // clang-format off
                !/^request/.test(methodName) && !/^getRequestInterceptors/.test(methodName) && // clang-format on
                // The ServiceObject didn't redefine the method.
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this[methodName] === // eslint-disable-next-line @typescript-eslint/no-explicit-any
                ServiceObject.prototype[methodName] && // This method isn't wanted.
                !config.methods[methodName]);
            }).forEach((methodName)=>{
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this[methodName] = undefined;
            });
        }
    }
    create(optionsOrCallback, callback) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const args = [
            this.id
        ];
        if (typeof optionsOrCallback === 'function') {
            callback = optionsOrCallback;
        }
        if (typeof optionsOrCallback === 'object') {
            args.push(optionsOrCallback);
        }
        // Wrap the callback to return *this* instance of the object, not the
        // newly-created one.
        // tslint: disable-next-line no-any
        function onCreate(...args) {
            const [err, instance] = args;
            if (!err) {
                self.metadata = instance.metadata;
                args[1] = self; // replace the created `instance` with this one.
            }
            callback(...args);
        }
        args.push(onCreate);
        // eslint-disable-next-line prefer-spread
        this.createMethod.apply(null, args);
    }
    delete(optionsOrCallback, cb) {
        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const ignoreNotFound = options.ignoreNotFound;
        delete options.ignoreNotFound;
        const methodConfig = typeof this.methods.delete === 'object' && this.methods.delete || {};
        const reqOpts = extend(true, {
            method: 'DELETE',
            uri: ''
        }, methodConfig.reqOpts, {
            qs: options
        });
        // The `request` method may have been overridden to hold any special
        // behavior. Ensure we call the original `request` method.
        ServiceObject.prototype.request.call(this, reqOpts, (err, ...args)=>{
            if (err) {
                if (err.code === 404 && ignoreNotFound) {
                    err = null;
                }
            }
            callback(err, ...args);
        });
    }
    exists(optionsOrCallback, cb) {
        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        this.get(options, (err)=>{
            if (err) {
                if (err.code === 404) {
                    callback(null, false);
                } else {
                    callback(err);
                }
                return;
            }
            callback(null, true);
        });
    }
    get(optionsOrCallback, cb) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const [opts, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const options = Object.assign({}, opts);
        const autoCreate = options.autoCreate && typeof this.create === 'function';
        delete options.autoCreate;
        function onCreate(err, instance, apiResponse) {
            if (err) {
                if (err.code === 409) {
                    self.get(options, callback);
                    return;
                }
                callback(err, null, apiResponse);
                return;
            }
            callback(null, instance, apiResponse);
        }
        this.getMetadata(options, (err, metadata)=>{
            if (err) {
                if (err.code === 404 && autoCreate) {
                    const args = [];
                    if (Object.keys(options).length > 0) {
                        args.push(options);
                    }
                    args.push(onCreate);
                    self.create(...args);
                    return;
                }
                callback(err, null, metadata);
                return;
            }
            callback(null, self, metadata);
        });
    }
    getMetadata(optionsOrCallback, cb) {
        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const methodConfig = typeof this.methods.getMetadata === 'object' && this.methods.getMetadata || {};
        const reqOpts = extend(true, {
            uri: ''
        }, methodConfig.reqOpts, {
            qs: options
        });
        // The `request` method may have been overridden to hold any special
        // behavior. Ensure we call the original `request` method.
        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res)=>{
            this.metadata = body;
            callback(err, this.metadata, res);
        });
    }
    /**
     * Return the user's custom request interceptors.
     */ getRequestInterceptors() {
        // Interceptors should be returned in the order they were assigned.
        const localInterceptors = this.interceptors.filter((interceptor)=>typeof interceptor.request === 'function').map((interceptor)=>interceptor.request);
        return this.parent.getRequestInterceptors().concat(localInterceptors);
    }
    setMetadata(metadata, optionsOrCallback, cb) {
        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);
        const methodConfig = typeof this.methods.setMetadata === 'object' && this.methods.setMetadata || {};
        const reqOpts = extend(true, {}, {
            method: 'PATCH',
            uri: ''
        }, methodConfig.reqOpts, {
            json: metadata,
            qs: options
        });
        // The `request` method may have been overridden to hold any special
        // behavior. Ensure we call the original `request` method.
        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res)=>{
            this.metadata = body;
            callback(err, this.metadata, res);
        });
    }
    request_(reqOpts, callback) {
        reqOpts = extend(true, {}, reqOpts);
        if (this.projectId) {
            reqOpts.projectId = this.projectId;
        }
        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;
        const uriComponents = [
            this.baseUrl,
            this.id || '',
            reqOpts.uri
        ];
        if (isAbsoluteUrl) {
            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));
        }
        reqOpts.uri = uriComponents.filter((x)=>x.trim()) // Limit to non-empty strings.
        .map((uriComponent)=>{
            const trimSlashesRegex = /^\/*|\/*$/g;
            return uriComponent.replace(trimSlashesRegex, '');
        }).join('/');
        const childInterceptors = arrify(reqOpts.interceptors_);
        const localInterceptors = [].slice.call(this.interceptors);
        reqOpts.interceptors_ = childInterceptors.concat(localInterceptors);
        if (reqOpts.shouldReturnStream) {
            return this.parent.requestStream(reqOpts);
        }
        this.parent.request(reqOpts, callback);
    }
    request(reqOpts, callback) {
        this.request_(reqOpts, callback);
    }
    /**
     * Make an authenticated API request.
     *
     * @param {object} reqOpts - Request options that are passed to `request`.
     * @param {string} reqOpts.uri - A URI relative to the baseUrl.
     */ requestStream(reqOpts) {
        const opts = extend(true, reqOpts, {
            shouldReturnStream: true
        });
        return this.request_(opts);
    }
}
exports.ServiceObject = ServiceObject;
(0, promisify_1.promisifyAll)(ServiceObject, {
    exclude: [
        'getRequestInterceptors'
    ]
}); //# sourceMappingURL=service-object.js.map
}}),
"[project]/node_modules/@google-cloud/common/build/src/operation.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2016 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Operation = void 0;
/*!
 * @module common/operation
 */ const service_object_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/service-object.js [app-rsc] (ecmascript)");
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class Operation extends service_object_1.ServiceObject {
    /**
     * An Operation object allows you to interact with APIs that take longer to
     * process things.
     *
     * @constructor
     * @alias module:common/operation
     *
     * @param {object} config - Configuration object.
     * @param {module:common/service|module:common/serviceObject|module:common/grpcService|module:common/grpcServiceObject} config.parent - The parent object.
     */ constructor(config){
        const methods = {
            /**
             * Checks to see if an operation exists.
             */ exists: true,
            /**
             * Retrieves the operation.
             */ get: true,
            /**
             * Retrieves metadata for the operation.
             */ getMetadata: {
                reqOpts: {
                    name: config.id
                }
            }
        };
        config = Object.assign({
            baseUrl: ''
        }, config);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        config.methods = config.methods || methods;
        super(config);
        this.completeListeners = 0;
        this.hasActiveListeners = false;
        this.listenForEvents_();
    }
    /**
     * Wraps the `complete` and `error` events in a Promise.
     *
     * @return {Promise}
     */ promise() {
        return new Promise((resolve, reject)=>{
            this.on('error', reject).on('complete', (metadata)=>{
                resolve([
                    metadata
                ]);
            });
        });
    }
    /**
     * Begin listening for events on the operation. This method keeps track of how
     * many "complete" listeners are registered and removed, making sure polling
     * is handled automatically.
     *
     * As long as there is one active "complete" listener, the connection is open.
     * When there are no more listeners, the polling stops.
     *
     * @private
     */ listenForEvents_() {
        this.on('newListener', (event)=>{
            if (event === 'complete') {
                this.completeListeners++;
                if (!this.hasActiveListeners) {
                    this.hasActiveListeners = true;
                    this.startPolling_();
                }
            }
        });
        this.on('removeListener', (event)=>{
            if (event === 'complete' && --this.completeListeners === 0) {
                this.hasActiveListeners = false;
            }
        });
    }
    /**
     * Poll for a status update. Returns null for an incomplete
     * status, and metadata for a complete status.
     *
     * @private
     */ poll_(callback) {
        this.getMetadata((err, body)=>{
            if (err || body.error) {
                callback(err || body.error);
                return;
            }
            if (!body.done) {
                callback(null);
                return;
            }
            callback(null, body);
        });
    }
    /**
     * Poll `getMetadata` to check the operation's status. This runs a loop to
     * ping the API on an interval.
     *
     * Note: This method is automatically called once a "complete" event handler
     * is registered on the operation.
     *
     * @private
     */ async startPolling_() {
        if (!this.hasActiveListeners) {
            return;
        }
        try {
            const metadata = await (0, util_1.promisify)(this.poll_.bind(this))();
            if (!metadata) {
                setTimeout(this.startPolling_.bind(this), this.pollIntervalMs || 500);
                return;
            }
            this.emit('complete', metadata);
        } catch (err) {
            this.emit('error', err);
        }
    }
}
exports.Operation = Operation; //# sourceMappingURL=operation.js.map
}}),
"[project]/node_modules/@google-cloud/common/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2016 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.util = exports.ApiError = exports.ServiceObject = exports.Service = exports.Operation = void 0;
/**
 * @type {module:common/operation}
 * @private
 */ var operation_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/operation.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Operation", {
    enumerable: true,
    get: function() {
        return operation_1.Operation;
    }
});
/**
 * @type {module:common/service}
 * @private
 */ var service_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/service.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Service", {
    enumerable: true,
    get: function() {
        return service_1.Service;
    }
});
/**
 * @type {module:common/serviceObject}
 * @private
 */ var service_object_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/service-object.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "ServiceObject", {
    enumerable: true,
    get: function() {
        return service_object_1.ServiceObject;
    }
});
/**
 * @type {module:common/util}
 * @private
 */ var util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/util.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "ApiError", {
    enumerable: true,
    get: function() {
        return util_1.ApiError;
    }
});
Object.defineProperty(exports, "util", {
    enumerable: true,
    get: function() {
        return util_1.util;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/paginator/build/src/resource-stream.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceStream = void 0;
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
class ResourceStream extends stream_1.Transform {
    constructor(args, requestFn){
        const options = Object.assign({
            objectMode: true
        }, args.streamOptions);
        super(options);
        this._ended = false;
        this._maxApiCalls = args.maxApiCalls === -1 ? Infinity : args.maxApiCalls;
        this._nextQuery = args.query;
        this._reading = false;
        this._requestFn = requestFn;
        this._requestsMade = 0;
        this._resultsToSend = args.maxResults === -1 ? Infinity : args.maxResults;
        this._otherArgs = [];
    }
    /* eslint-disable  @typescript-eslint/no-explicit-any */ end(...args) {
        this._ended = true;
        return super.end(...args);
    }
    _read() {
        if (this._reading) {
            return;
        }
        this._reading = true;
        // Wrap in a try/catch to catch input linting errors, e.g.
        // an invalid BigQuery query. These errors are thrown in an
        // async fashion, which makes them un-catchable by the user.
        try {
            this._requestFn(this._nextQuery, (err, results, nextQuery, ...otherArgs)=>{
                if (err) {
                    this.destroy(err);
                    return;
                }
                this._otherArgs = otherArgs;
                this._nextQuery = nextQuery;
                if (this._resultsToSend !== Infinity) {
                    results = results.splice(0, this._resultsToSend);
                    this._resultsToSend -= results.length;
                }
                let more = true;
                for (const result of results){
                    if (this._ended) {
                        break;
                    }
                    more = this.push(result);
                }
                const isFinished = !this._nextQuery || this._resultsToSend < 1;
                const madeMaxCalls = ++this._requestsMade >= this._maxApiCalls;
                if (isFinished || madeMaxCalls) {
                    this.end();
                }
                if (more && !this._ended) {
                    setImmediate(()=>this._read());
                }
                this._reading = false;
            });
        } catch (e) {
            this.destroy(e);
        }
    }
}
exports.ResourceStream = ResourceStream; //# sourceMappingURL=resource-stream.js.map
}}),
"[project]/node_modules/@google-cloud/paginator/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceStream = exports.paginator = exports.Paginator = void 0;
/*!
 * @module common/paginator
 */ const arrify = __turbopack_context__.r("[project]/node_modules/arrify/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const resource_stream_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/paginator/build/src/resource-stream.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "ResourceStream", {
    enumerable: true,
    get: function() {
        return resource_stream_1.ResourceStream;
    }
});
/*! Developer Documentation
 *
 * paginator is used to auto-paginate `nextQuery` methods as well as
 * streamifying them.
 *
 * Before:
 *
 *   search.query('done=true', function(err, results, nextQuery) {
 *     search.query(nextQuery, function(err, results, nextQuery) {});
 *   });
 *
 * After:
 *
 *   search.query('done=true', function(err, results) {});
 *
 * Methods to extend should be written to accept callbacks and return a
 * `nextQuery`.
 */ class Paginator {
    /**
     * Cache the original method, then overwrite it on the Class's prototype.
     *
     * @param {function} Class - The parent class of the methods to extend.
     * @param {string|string[]} methodNames - Name(s) of the methods to extend.
     */ // tslint:disable-next-line:variable-name
    extend(Class, methodNames) {
        methodNames = arrify(methodNames);
        methodNames.forEach((methodName)=>{
            const originalMethod = Class.prototype[methodName];
            // map the original method to a private member
            Class.prototype[methodName + '_'] = originalMethod;
            // overwrite the original to auto-paginate
            /* eslint-disable  @typescript-eslint/no-explicit-any */ Class.prototype[methodName] = function(...args) {
                const parsedArguments = paginator.parseArguments_(args);
                return paginator.run_(parsedArguments, originalMethod.bind(this));
            };
        });
    }
    /**
     * Wraps paginated API calls in a readable object stream.
     *
     * This method simply calls the nextQuery recursively, emitting results to a
     * stream. The stream ends when `nextQuery` is null.
     *
     * `maxResults` will act as a cap for how many results are fetched and emitted
     * to the stream.
     *
     * @param {string} methodName - Name of the method to streamify.
     * @return {function} - Wrapped function.
     */ /* eslint-disable  @typescript-eslint/no-explicit-any */ streamify(methodName) {
        return function(/* eslint-disable  @typescript-eslint/no-explicit-any */ ...args) {
            const parsedArguments = paginator.parseArguments_(args);
            const originalMethod = this[methodName + '_'] || this[methodName];
            return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));
        };
    }
    /**
     * Parse a pseudo-array `arguments` for a query and callback.
     *
     * @param {array} args - The original `arguments` pseduo-array that the original
     *     method received.
     */ /* eslint-disable  @typescript-eslint/no-explicit-any */ parseArguments_(args) {
        let query;
        let autoPaginate = true;
        let maxApiCalls = -1;
        let maxResults = -1;
        let callback;
        const firstArgument = args[0];
        const lastArgument = args[args.length - 1];
        if (typeof firstArgument === 'function') {
            callback = firstArgument;
        } else {
            query = firstArgument;
        }
        if (typeof lastArgument === 'function') {
            callback = lastArgument;
        }
        if (typeof query === 'object') {
            query = extend(true, {}, query);
            // Check if the user only asked for a certain amount of results.
            if (query.maxResults && typeof query.maxResults === 'number') {
                // `maxResults` is used API-wide.
                maxResults = query.maxResults;
            } else if (typeof query.pageSize === 'number') {
                // `pageSize` is Pub/Sub's `maxResults`.
                maxResults = query.pageSize;
            }
            if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {
                maxApiCalls = query.maxApiCalls;
                delete query.maxApiCalls;
            }
            // maxResults is the user specified limit.
            if (maxResults !== -1 || query.autoPaginate === false) {
                autoPaginate = false;
            }
        }
        const parsedArguments = {
            query: query || {},
            autoPaginate,
            maxApiCalls,
            maxResults,
            callback
        };
        parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);
        delete parsedArguments.streamOptions.autoPaginate;
        delete parsedArguments.streamOptions.maxResults;
        delete parsedArguments.streamOptions.pageSize;
        return parsedArguments;
    }
    /**
     * This simply checks to see if `autoPaginate` is set or not, if it's true
     * then we buffer all results, otherwise simply call the original method.
     *
     * @param {array} parsedArguments - Parsed arguments from the original method
     *     call.
     * @param {object=|string=} parsedArguments.query - Query object. This is most
     *     commonly an object, but to make the API more simple, it can also be a
     *     string in some places.
     * @param {function=} parsedArguments.callback - Callback function.
     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.
     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.
     * @param {number} parsedArguments.maxResults - Maximum results to return.
     * @param {function} originalMethod - The cached method that accepts a callback
     *     and returns `nextQuery` to receive more results.
     */ run_(parsedArguments, originalMethod) {
        const query = parsedArguments.query;
        const callback = parsedArguments.callback;
        if (!parsedArguments.autoPaginate) {
            return originalMethod(query, callback);
        }
        const results = new Array();
        let otherArgs = [];
        const promise = new Promise((resolve, reject)=>{
            const stream = paginator.runAsStream_(parsedArguments, originalMethod);
            stream.on('error', reject).on('data', (data)=>results.push(data)).on('end', ()=>{
                otherArgs = stream._otherArgs || [];
                resolve(results);
            });
        });
        if (!callback) {
            return promise.then((results)=>[
                    results,
                    query,
                    ...otherArgs
                ]);
        }
        promise.then((results)=>callback(null, results, query, ...otherArgs), (err)=>callback(err));
    }
    /**
     * This method simply calls the nextQuery recursively, emitting results to a
     * stream. The stream ends when `nextQuery` is null.
     *
     * `maxResults` will act as a cap for how many results are fetched and emitted
     * to the stream.
     *
     * @param {object=|string=} parsedArguments.query - Query object. This is most
     *     commonly an object, but to make the API more simple, it can also be a
     *     string in some places.
     * @param {function=} parsedArguments.callback - Callback function.
     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.
     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.
     * @param {number} parsedArguments.maxResults - Maximum results to return.
     * @param {function} originalMethod - The cached method that accepts a callback
     *     and returns `nextQuery` to receive more results.
     * @return {stream} - Readable object stream.
     */ /* eslint-disable  @typescript-eslint/no-explicit-any */ runAsStream_(parsedArguments, originalMethod) {
        return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);
    }
}
exports.Paginator = Paginator;
const paginator = new Paginator();
exports.paginator = paginator; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/logging/node_modules/dot-prop/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const isObj = __turbopack_context__.r("[project]/node_modules/is-obj/index.js [app-rsc] (ecmascript)");
const disallowedKeys = new Set([
    '__proto__',
    'prototype',
    'constructor'
]);
const isValidPath = (pathSegments)=>!pathSegments.some((segment)=>disallowedKeys.has(segment));
function getPathSegments(path) {
    const pathArray = path.split('.');
    const parts = [];
    for(let i = 0; i < pathArray.length; i++){
        let p = pathArray[i];
        while(p[p.length - 1] === '\\' && pathArray[i + 1] !== undefined){
            p = p.slice(0, -1) + '.';
            p += pathArray[++i];
        }
        parts.push(p);
    }
    if (!isValidPath(parts)) {
        return [];
    }
    return parts;
}
module.exports = {
    get (object, path, value) {
        if (!isObj(object) || typeof path !== 'string') {
            return value === undefined ? object : value;
        }
        const pathArray = getPathSegments(path);
        if (pathArray.length === 0) {
            return;
        }
        for(let i = 0; i < pathArray.length; i++){
            object = object[pathArray[i]];
            if (object === undefined || object === null) {
                // `object` is either `undefined` or `null` so we want to stop the loop, and
                // if this is not the last bit of the path, and
                // if it did't return `undefined`
                // it would return `null` if `object` is `null`
                // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
                if (i !== pathArray.length - 1) {
                    return value;
                }
                break;
            }
        }
        return object === undefined ? value : object;
    },
    set (object, path, value) {
        if (!isObj(object) || typeof path !== 'string') {
            return object;
        }
        const root = object;
        const pathArray = getPathSegments(path);
        for(let i = 0; i < pathArray.length; i++){
            const p = pathArray[i];
            if (!isObj(object[p])) {
                object[p] = {};
            }
            if (i === pathArray.length - 1) {
                object[p] = value;
            }
            object = object[p];
        }
        return root;
    },
    delete (object, path) {
        if (!isObj(object) || typeof path !== 'string') {
            return false;
        }
        const pathArray = getPathSegments(path);
        for(let i = 0; i < pathArray.length; i++){
            const p = pathArray[i];
            if (i === pathArray.length - 1) {
                delete object[p];
                return true;
            }
            object = object[p];
            if (!isObj(object)) {
                return false;
            }
        }
    },
    has (object, path) {
        if (!isObj(object) || typeof path !== 'string') {
            return false;
        }
        const pathArray = getPathSegments(path);
        if (pathArray.length === 0) {
            return false;
        }
        // eslint-disable-next-line unicorn/no-for-loop
        for(let i = 0; i < pathArray.length; i++){
            if (isObj(object)) {
                if (!(pathArray[i] in object)) {
                    return false;
                }
                object = object[pathArray[i]];
            } else {
                return false;
            }
        }
        return true;
    }
};
}}),
"[project]/node_modules/@google-cloud/logging-winston/build/src/common.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2016 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoggingCommon = exports.NODEJS_WINSTON_DEFAULT_LIBRARY_VERSION = exports.LOGGING_SAMPLED_KEY = exports.LOGGING_SPAN_KEY = exports.LOGGING_TRACE_KEY = void 0;
exports.getCurrentTraceFromAgent = getCurrentTraceFromAgent;
exports.getNodejsLibraryVersion = getNodejsLibraryVersion;
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const logging_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/index.js [app-rsc] (ecmascript)");
const instrumentation_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/instrumentation.js [app-rsc] (ecmascript)");
const mapValues = __turbopack_context__.r("[project]/node_modules/lodash.mapvalues/index.js [app-rsc] (ecmascript)");
// Map of npm output levels to Cloud Logging levels.
// See https://github.com/winstonjs/winston#logging-levels for more info.
const NPM_LEVEL_NAME_TO_CODE = {
    error: 3,
    warn: 4,
    info: 6,
    http: 6,
    verbose: 7,
    debug: 7,
    silly: 7
};
// Map of Cloud Logging levels.
const CLOUD_LOGGING_LEVEL_CODE_TO_NAME = {
    0: 'emergency',
    1: 'alert',
    2: 'critical',
    3: 'error',
    4: 'warning',
    5: 'notice',
    6: 'info',
    7: 'debug'
};
/*!
 * Log entry data key to allow users to indicate a trace for the request.
 */ exports.LOGGING_TRACE_KEY = 'logging.googleapis.com/trace';
/*!
 * Log entry data key to allow users to indicate a spanId for the request.
 */ exports.LOGGING_SPAN_KEY = 'logging.googleapis.com/spanId';
/*!
 * Log entry data key to allow users to indicate a traceSampled flag for the request.
 */ exports.LOGGING_SAMPLED_KEY = 'logging.googleapis.com/trace_sampled';
/**
 * Default library version to be used
 * Using release-please annotations to update DEFAULT_INSTRUMENTATION_VERSION with latest version.
 * See https://github.com/googleapis/release-please/blob/main/docs/customizing.md#updating-arbitrary-files
 */ exports.NODEJS_WINSTON_DEFAULT_LIBRARY_VERSION = '6.0.1'; // {x-release-please-version}
/*!
 * Gets the current fully qualified trace ID when available from the
 * @google-cloud/trace-agent library in the LogEntry.trace field format of:
 * "projects/[PROJECT-ID]/traces/[TRACE-ID]".
 */ function getCurrentTraceFromAgent() {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const agent = global._google_trace_agent;
    if (!agent || !agent.getCurrentContextId || !agent.getWriterProjectId) {
        return null;
    }
    const traceId = agent.getCurrentContextId();
    if (!traceId) {
        return null;
    }
    const traceProjectId = agent.getWriterProjectId();
    if (!traceProjectId) {
        return null;
    }
    return `projects/${traceProjectId}/traces/${traceId}`;
}
class LoggingCommon {
    constructor(options){
        var _a, _b;
        options = Object.assign({
            scopes: [
                'https://www.googleapis.com/auth/logging.write'
            ]
        }, options);
        this.logName = options.logName || 'winston_log';
        this.inspectMetadata = options.inspectMetadata === true;
        this.levels = options.levels || NPM_LEVEL_NAME_TO_CODE;
        this.redirectToStdout = (_a = options.redirectToStdout) !== null && _a !== void 0 ? _a : false;
        if (!this.redirectToStdout) {
            this.cloudLog = new logging_1.Logging(options).log(this.logName, {
                removeCircular: true,
                // See: https://cloud.google.com/logging/quotas, a log size of
                // 250,000 has been chosen to keep us comfortably within the
                // 256,000 limit.
                maxEntrySize: options.maxEntrySize || 250000
            });
        } else {
            const logSyncOptions = {
                useMessageField: (_b = options.useMessageField) !== null && _b !== void 0 ? _b : true
            };
            this.cloudLog = new logging_1.Logging(options).logSync(this.logName, undefined, logSyncOptions);
        }
        this.resource = options.resource;
        this.serviceContext = options.serviceContext;
        this.prefix = options.prefix;
        this.labels = options.labels;
        this.defaultCallback = options.defaultCallback;
    }
    log(level, message, metadata, callback) {
        metadata = metadata || {};
        // First create instrumentation record if it is never written before
        let instrumentationEntry;
        if (!(0, instrumentation_1.setInstrumentationStatus)(true)) {
            instrumentationEntry = (0, instrumentation_1.createDiagnosticEntry)('nodejs-winston', getNodejsLibraryVersion());
            // Update instrumentation record resource, logName and timestamp
            instrumentationEntry.metadata.resource = this.resource;
            instrumentationEntry.metadata.logName = metadata.logName;
            instrumentationEntry.metadata.timestamp = metadata.timestamp;
        }
        message = message || '';
        const hasMetadata = Object.keys(metadata).length;
        if (this.levels[level] === undefined) {
            throw new Error('Unknown log level: ' + level);
        }
        const levelCode = this.levels[level];
        const cloudLevel = CLOUD_LOGGING_LEVEL_CODE_TO_NAME[levelCode];
        const data = {};
        // Cloud Logs Viewer picks up the summary line from the `message`
        // property of the jsonPayload.
        // https://cloud.google.com/logging/docs/view/logs_viewer_v2#expanding.
        //
        // For error messages at severity 'error' and higher,
        // Error Reporting will pick up error messages if the full stack trace is
        // included in the textPayload or the message property of the jsonPayload.
        // https://cloud.google.com/error-reporting/docs/formatting-error-messages
        // We prefer to format messages as jsonPayload (by putting it as a message
        // property on an object) as that works and is accepted by Error Reporting
        // in far more resource types.
        //
        if (metadata.stack) {
            message += (message ? ' ' : '') + metadata.stack;
            data.serviceContext = this.serviceContext;
        }
        data.message = this.prefix ? `[${this.prefix}] ` : '';
        data.message += message;
        const entryMetadata = {
            resource: this.resource
        };
        // If the metadata contains a logName property, promote it to the entry
        // metadata.
        if (metadata.logName) {
            entryMetadata.logName = metadata.logName;
        }
        // If the metadata contains a httpRequest property, promote it to the
        // entry metadata. This allows Cloud Logging to use request log formatting.
        // https://cloud.google.com/logging/docs/reference/v2/rpc/google.logging.type#google.logging.type.HttpRequest
        // Note that the httpRequest field must properly validate as HttpRequest
        // proto message, or the log entry would be rejected by the API. We no do
        // validation here.
        if (metadata.httpRequest) {
            entryMetadata.httpRequest = metadata.httpRequest;
        }
        // If the metadata contains a timestamp property, promote it to the entry
        // metadata. As Winston 3 buffers logs when a transport (such as this one)
        // invokes its log callback asynchronously, a timestamp assigned at log time
        // is more accurate than one assigned in a transport.
        if (metadata.timestamp instanceof Date) {
            entryMetadata.timestamp = metadata.timestamp;
        }
        // If the metadata contains a labels property, promote it to the entry
        // metadata.
        // https://cloud.google.com/logging/docs/reference/v2/rpc/google.logging.v2#logentry
        if (this.labels || metadata.labels) {
            entryMetadata.labels = !this.labels ? metadata.labels : Object.assign({}, this.labels, metadata.labels);
        }
        const trace = metadata[exports.LOGGING_TRACE_KEY] || getCurrentTraceFromAgent();
        if (trace) {
            entryMetadata.trace = trace;
        }
        const spanId = metadata[exports.LOGGING_SPAN_KEY];
        if (spanId) {
            entryMetadata.spanId = spanId;
        }
        if (exports.LOGGING_SAMPLED_KEY in metadata) {
            entryMetadata.traceSampled = metadata[exports.LOGGING_SAMPLED_KEY] === true;
        }
        // we have tests that assert that metadata is always passed.
        // not sure if its correct but for now we always set it even if it has
        // nothing in it
        data.metadata = this.inspectMetadata ? mapValues(metadata, util.inspect) : metadata;
        if (hasMetadata) {
            // clean entryMetadata props
            delete data.metadata[exports.LOGGING_TRACE_KEY];
            delete data.metadata[exports.LOGGING_SPAN_KEY];
            delete data.metadata[exports.LOGGING_SAMPLED_KEY];
            delete data.metadata.httpRequest;
            delete data.metadata.labels;
            delete data.metadata.timestamp;
            delete data.metadata.logName;
        }
        const entries = [];
        entries.push(this.entry(entryMetadata, data));
        // Check if instrumentation entry needs to be added as well
        if (instrumentationEntry) {
            // Make sure instrumentation entry is updated by underlying logger
            instrumentationEntry = this.entry(instrumentationEntry.metadata, instrumentationEntry.data);
            if (levelCode !== NPM_LEVEL_NAME_TO_CODE.info) {
                // We using info level for diagnostic records
                this.cloudLog[CLOUD_LOGGING_LEVEL_CODE_TO_NAME[NPM_LEVEL_NAME_TO_CODE.info]]([
                    instrumentationEntry
                ], this.defaultCallback);
            } else entries.push(instrumentationEntry);
        }
        // Make sure that both callbacks are called in case if provided
        const newCallback = (err, apiResponse)=>{
            let callbackError;
            if (callback) {
                try {
                    callback(err, apiResponse);
                } catch (error) {
                    callbackError = error;
                }
            }
            if (this.defaultCallback) {
                this.defaultCallback(err, apiResponse);
            }
            // In case if original error was null and callback thrown exception, rethrow it to make sure
            // we do not swallow it since upon success the exceptions normally should not be thrown. Also
            // we should retrhrow callbackError when defaultCallback was not provided to keep
            // prevous behaviour intact
            if ((!this.defaultCallback || err === null) && callbackError) {
                throw callbackError;
            }
        };
        this.cloudLog[cloudLevel](entries, newCallback);
        // The LogSync class does not supports callback. However Writable class always
        // provides onwrite() callback which needs to be called after each log is written,
        // so the stream would remove writing state. Since this.defaultCallback can also be set, we
        // should call it explicitly as well.
        if (this.redirectToStdout) {
            newCallback(null, undefined);
        }
    }
    entry(metadata, data) {
        if (this.redirectToStdout) {
            return this.cloudLog.entry(metadata, data);
        }
        return this.cloudLog.entry(metadata, data);
    }
}
exports.LoggingCommon = LoggingCommon;
// LOGGING_TRACE_KEY is Cloud Logging specific and has the format:
// logging.googleapis.com/trace
LoggingCommon.LOGGING_TRACE_KEY = exports.LOGGING_TRACE_KEY;
// LOGGING_TRACE_KEY is Cloud Logging specific and has the format:
// logging.googleapis.com/spanId
LoggingCommon.LOGGING_SPAN_KEY = exports.LOGGING_SPAN_KEY;
function getNodejsLibraryVersion() {
    return exports.NODEJS_WINSTON_DEFAULT_LIBRARY_VERSION;
} //# sourceMappingURL=common.js.map
}}),
"[project]/node_modules/@google-cloud/logging-winston/build/src/middleware/make-child-logger.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeChildLogger = makeChildLogger;
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/index.js [app-rsc] (ecmascript)");
function makeChildLogger(logger, trace, span, sampled) {
    return logger.child({
        [index_1.LOGGING_TRACE_KEY]: trace,
        [index_1.LOGGING_SPAN_KEY]: span,
        [index_1.LOGGING_SAMPLED_KEY]: sampled
    });
} //# sourceMappingURL=make-child-logger.js.map
}}),
"[project]/node_modules/@google-cloud/logging-winston/build/src/middleware/express.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.REQUEST_LOG_SUFFIX = void 0;
exports.makeMiddleware = makeMiddleware;
const logging_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/index.js [app-rsc] (ecmascript)");
const google_auth_library_1 = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-rsc] (ecmascript)");
const common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/common.js [app-rsc] (ecmascript)");
const index_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/index.js [app-rsc] (ecmascript)");
const make_child_logger_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/middleware/make-child-logger.js [app-rsc] (ecmascript)");
exports.REQUEST_LOG_SUFFIX = '_reqlog';
async function makeMiddleware(logger, optionsOrTransport, skipParentEntryForCloudRun) {
    let transport;
    // If no custom transports are provided, use default or instantiate one.
    const cloudTransport = logger.transports.find((t)=>t instanceof index_1.LoggingWinston);
    // If user provides a custom transport, always add it to the logger.
    if (optionsOrTransport instanceof index_1.LoggingWinston) {
        transport = optionsOrTransport;
        logger.add(transport);
    } else if (cloudTransport && !optionsOrTransport) {
        // Check if logger already contains a Cloud transport
        transport = cloudTransport;
    } else {
        const options = {
            logName: 'winston_log',
            ...optionsOrTransport
        };
        transport = new index_1.LoggingWinston(options);
        logger.add(transport);
    }
    const auth = (transport.common.redirectToStdout ? transport.common.cloudLog : transport.common.cloudLog).logging.auth;
    const [env, projectId] = await Promise.all([
        auth.getEnv(),
        auth.getProjectId()
    ]);
    // Unless we are running on Google App Engine or Cloud Functions, generate a
    // parent request log entry that all the request specific logs ("app logs")
    // will nest under. GAE and GCF generate the parent request logs
    // automatically.
    // Cloud Run also generates the parent request log automatically, but skipping
    // the parent request entry has to be explicity enabled until the next major
    // release in which we can change the default behavior.
    let emitRequestLogEntry;
    if (env !== google_auth_library_1.GCPEnv.APP_ENGINE && env !== google_auth_library_1.GCPEnv.CLOUD_FUNCTIONS && (env !== google_auth_library_1.GCPEnv.CLOUD_RUN || !skipParentEntryForCloudRun)) {
        const requestLogName = logging_1.Log.formatName_(projectId, `${transport.common.logName}${exports.REQUEST_LOG_SUFFIX}`);
        emitRequestLogEntry = (httpRequest, trace, span, sampled)=>{
            logger.info({
                // The request logs must have a log name distinct from the app logs
                // for log correlation to work.
                logName: requestLogName,
                [common_1.LOGGING_TRACE_KEY]: trace,
                [common_1.LOGGING_SPAN_KEY]: span,
                [common_1.LOGGING_SAMPLED_KEY]: sampled,
                httpRequest,
                message: httpRequest.requestUrl || 'http request'
            });
        };
    }
    return logging_1.middleware.express.makeMiddleware(projectId, (trace, span, sampled)=>(0, make_child_logger_1.makeChildLogger)(logger, trace, span, sampled), emitRequestLogEntry);
} //# sourceMappingURL=express.js.map
}}),
"[project]/node_modules/@google-cloud/logging-winston/build/src/default-metadata.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDefaultMetadataForTracing = getDefaultMetadataForTracing;
const common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/common.js [app-rsc] (ecmascript)");
/**
 * Returns an object that can be passed to Winston.createLogger as defaultMeta
 * to allow log-trace correlation with Winston 3. Log-trace correlation with
 * Winston 3 is broken because the trace ID to be correlated with a log isn't
 * evaluated when the log function is called, but rather when the log is
 * written, which happens at some future point where the trace ID may no longer
 * be accurate. To circumvent this, we take advantage of the fact that
 * defaultMeta is copied when a log function is called, and use a dynamic
 * property getter to evaluate the trace ID upon that copy.
 *
 * We apply the same principle for timestamps, which is not strictly necessary
 * for tracing but allows for more accurate timestamps in general.
 *
 * If there are other default metadata fields with which the return value of
 * this function must be merged, this object MUST be the base object. In other
 * words, do not use the return value of this function as the non-first argument
 * to Object.assign, or it will not work.
 *
 * See https://github.com/googleapis/nodejs-logging-winston/issues/287 for
 * more information.
 */ function getDefaultMetadataForTracing() {
    const agent = global._google_trace_agent;
    // Enable log-trace correlation if the Trace Agent API is compatible.
    const enableThunkAgent = !!(agent && agent.getCurrentContextId && agent.getWriterProjectId);
    const defaultMeta = {};
    // Make defaultMeta.timestamp return the current timestamp any time it's
    // accessed.
    Object.defineProperty(defaultMeta, 'timestamp', {
        enumerable: true,
        get: ()=>new Date()
    });
    if (enableThunkAgent) {
        // Make defaultMeta[LOGGING_TRACE_KEY] return the current trace ID any time
        // it's accessed.
        const loggingTraceKey = common_1.LOGGING_TRACE_KEY;
        Object.defineProperty(defaultMeta, loggingTraceKey, {
            enumerable: true,
            get: ()=>{
                const traceId = agent.getCurrentContextId();
                if (!traceId) {
                    return null;
                }
                const traceProjectId = agent.getWriterProjectId();
                if (!traceProjectId) {
                    return null;
                }
                return `projects/${traceProjectId}/traces/${traceId}`;
            }
        });
    }
    return defaultMeta;
} //# sourceMappingURL=default-metadata.js.map
}}),
"[project]/node_modules/@google-cloud/logging-winston/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2017 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LOGGING_SAMPLED_KEY = exports.LOGGING_SPAN_KEY = exports.LOGGING_TRACE_KEY = exports.LoggingWinston = exports.getCurrentTraceFromAgent = exports.getDefaultMetadataForTracing = exports.express = void 0;
const TransportStream = __turbopack_context__.r("[project]/node_modules/winston-transport/index.js [app-rsc] (ecmascript)");
const common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/common.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getCurrentTraceFromAgent", {
    enumerable: true,
    get: function() {
        return common_1.getCurrentTraceFromAgent;
    }
});
const express = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/middleware/express.js [app-rsc] (ecmascript)");
exports.express = express;
const default_metadata_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging-winston/build/src/default-metadata.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getDefaultMetadataForTracing", {
    enumerable: true,
    get: function() {
        return default_metadata_1.getDefaultMetadataForTracing;
    }
});
const LEVEL = Symbol.for('level');
/**
 * This module provides support for streaming your winston logs to
 * [Cloud Logging](https://cloud.google.com/logging).
 *
 * @class
 *
 * @param {object} [options]
 * @param {object} [options.level] The default log level. Winston will filter
 *     messages with a severity lower than this.
 * @param {object} [options.levels] Custom logging levels as supported by
 *     winston. This list is used to translate your log level to the Cloud
 *     Logging level. Each property should have an integer value between 0 (most
 *     severe) and 7 (least severe). If you are passing a list of levels to your
 *     winston logger, you should provide the same list here.
 * @param {boolean} [options.inspectMetadata=false] Serialize winston-provided log
 *     metadata using `util.inspect`.
 * @param {string} [options.logName=winston_log] The name of the log that will receive
 *     messages written to this transport.
 * @param {object} [options.resource] The monitored resource that the transport
 *     corresponds to. On Google Cloud Platform, this is detected automatically,
 *     but you may optionally specify a specific monitored resource. For more
 *     information see the
 *     [official documentation]{@link
 * https://cloud.google.com/logging/docs/api/reference/rest/v2/MonitoredResource}.
 * @param {object} [options.serviceContext] For logged errors, we provide this
 *     as the service context. For more information see
 *     [this guide]{@link
 * https://cloud.google.com/error-reporting/docs/formatting-error-messages} and
 * the [official documentation]{@link
 * https://cloud.google.com/error-reporting/reference/rest/v1beta1/ServiceContext}.
 * @param {string} [options.serviceContext.service] An identifier of the
 *     service, such as the name of the executable, job, or Google App Engine
 *     service name.
 * @param {string} [options.serviceContext.version] Represents the version of
 *     the service.
 * @param {string} [options.projectId] The project ID from the Google Cloud
 *     Console, e.g. 'grape-spaceship-123'. We will also check the environment
 *     variable `GCLOUD_PROJECT` for your project ID. If your app is running in
 *     an environment which supports {@link
 * https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application
 * Application Default Credentials}, your project ID will be detected
 * automatically.
 * @param {string} [options.keyFilename] Full path to the a .json, .pem, or .p12
 *     key downloaded from the Google Cloud Console. If you provide a path
 *     to a JSON file, the `projectId` option above is not necessary. NOTE: .pem
 *     and .p12 require you to specify the `email` option as well.
 * @param {string} [options.email] Account email address. Required when using a
 *     .pem or .p12 keyFilename.
 * @param {object} [options.credentials] Credentials object.
 * @param {string} [options.credentials.client_email]
 * @param {string} [options.credentials.private_key]
 * @param {boolean} [options.autoRetry=true] Automatically retry requests if the
 *     response is related to rate limits or certain intermittent server errors.
 *     We will exponentially backoff subsequent requests by default.
 * @param {number} [options.maxRetries=3] Maximum number of automatic retries
 *     attempted before returning the error.
 * @param {constructor} [options.promise] Custom promise module to use instead
 *     of native Promises.
 *
 * @example <caption>Import the client library</caption>
 * const {LoggingWinston} = require('@google-cloud/logging-winston');
 *
 * @example <caption>Create a client that uses <a
 * href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application
 * Default Credentials (ADC)</a>:</caption> const loggingWinston = new
 * LoggingWinston();
 *
 * @example <caption>Create a client with <a
 * href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicit
 * credentials</a>:</caption> const loggingWinston = new LoggingWinston({
 *   projectId: 'your-project-id',
 *   keyFilename: '/path/to/keyfile.json'
 * });
 *
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:logging_winston_quickstart
 * Full quickstart example:
 */ class LoggingWinston extends TransportStream {
    constructor(options){
        options = options || {};
        super({
            level: options.level,
            format: options.format,
            silent: options.silent,
            handleExceptions: options.handleExceptions,
            handleRejections: options.handleRejections
        });
        this.common = new common_1.LoggingCommon(options);
    }
    // eslint-disable-next-line
    log(info, callback) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { message, level, splat, stack, ...metadata } = info;
        // If the whole message is an error we have to manually copy the stack into
        // metadata. Errors dont have enumerable properties so they don't
        // destructure.
        if (stack) metadata.stack = stack;
        this.common.log(info[LEVEL] || level, message, metadata || {}, callback);
    }
}
exports.LoggingWinston = LoggingWinston;
LoggingWinston.LOGGING_TRACE_KEY = common_1.LOGGING_TRACE_KEY;
LoggingWinston.LOGGING_SPAN_KEY = common_1.LOGGING_SPAN_KEY;
LoggingWinston.LOGGING_SAMPLED_KEY = common_1.LOGGING_SAMPLED_KEY;
// LOGGING_TRACE_KEY is Cloud Logging specific and has the format:
// logging.googleapis.com/trace
// For more information, see: https://cloud.google.com/logging/docs/reference/v2/rpc/google.logging.v2#logentry
exports.LOGGING_TRACE_KEY = common_1.LOGGING_TRACE_KEY;
// LOGGING_SPAN_KEY is Cloud Logging specific and has the format:
// logging.googleapis.com/spanId
// For more information, see: https://cloud.google.com/logging/docs/reference/v2/rpc/google.logging.v2#logentry
exports.LOGGING_SPAN_KEY = common_1.LOGGING_SPAN_KEY;
// LOGGING_SAMPLED_KEY is Cloud Logging specific and has the format:
// logging.googleapis.com/trace_sampled
// The value of this field must be either true or false. For more information,
// see traceSampled on the LogEntry page:	https://cloud.google.com/logging/docs/reference/v2/rpc/google.logging.v2#logentry
exports.LOGGING_SAMPLED_KEY = common_1.LOGGING_SAMPLED_KEY; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/external-types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=external-types.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValueType = exports.MetricKind = void 0;
/**
 * The kind of measurement. It describes how the data is reported.
 */ var MetricKind;
(function(MetricKind) {
    MetricKind["UNSPECIFIED"] = "METRIC_KIND_UNSPECIFIED";
    MetricKind["GAUGE"] = "GAUGE";
    MetricKind["DELTA"] = "DELTA";
    MetricKind["CUMULATIVE"] = "CUMULATIVE";
})(MetricKind = exports.MetricKind || (exports.MetricKind = {}));
/** The value type of a metric. */ var ValueType;
(function(ValueType) {
    ValueType["VALUE_TYPE_UNSPECIFIED"] = "VALUE_TYPE_UNSPECIFIED";
    ValueType["INT64"] = "INT64";
    ValueType["DOUBLE"] = "DOUBLE";
    ValueType["DISTRIBUTION"] = "DISTRIBUTION";
})(ValueType = exports.ValueType || (exports.ValueType = {})); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/utils.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.numbersToStrings = exports.exp2 = exports.mountProjectIdPath = exports.partitionList = void 0;
/** Returns the minimum number of arrays of max size chunkSize, partitioned from the given array. */ function partitionList(list, chunkSize) {
    const listCopy = [
        ...list
    ];
    const results = [];
    while(listCopy.length){
        results.push(listCopy.splice(0, chunkSize));
    }
    return results;
}
exports.partitionList = partitionList;
/** Mounts the GCP project id path */ function mountProjectIdPath(projectId) {
    return `projects/${projectId}`;
}
exports.mountProjectIdPath = mountProjectIdPath;
/**
 * Returns the result of 2^value
 */ function exp2(value) {
    return Math.pow(2, value);
}
exports.exp2 = exp2;
/**
 * Map array of numbers to strings
 *
 * @param values an array of numbers
 * @returns a list of strings for those integers
 */ function numbersToStrings(values) {
    return values.map((value)=>value.toString());
}
exports.numbersToStrings = numbersToStrings; //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/transform.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._TEST_ONLY = exports.createTimeSeries = exports.transformMetricDescriptor = void 0;
const sdk_metrics_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/sdk-metrics/build/esm/index.js [app-rsc] (ecmascript)");
const api_1 = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/types.js [app-rsc] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/utils.js [app-rsc] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const precise_date_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/precise-date/build/src/index.js [app-rsc] (ecmascript)");
/**
 *
 * @param metric the MetricData to create a descriptor for
 * @param metricPrefix prefix to add to metric names
 * @param displayNamePrefix prefix to add to display name in the descriptor
 * @returns the GCM MetricDescriptor or null if the MetricData was empty
 */ function transformMetricDescriptor(metric, metricPrefix) {
    const { descriptor: { name, description, unit } } = metric;
    return {
        type: transformMetricType(metricPrefix, name),
        description,
        displayName: name,
        metricKind: transformMetricKind(metric),
        valueType: transformValueType(metric),
        unit,
        labels: transformLabelDescriptors(metric)
    };
}
exports.transformMetricDescriptor = transformMetricDescriptor;
function transformLabelDescriptors(metric) {
    if (metric.dataPoints.length === 0) {
        return [];
    }
    const attrs = metric.dataPoints[0].attributes;
    return Object.keys(attrs).map((key)=>({
            key: normalizeLabelKey(key),
            description: ''
        }));
}
/** Transforms Metric type. */ function transformMetricType(metricPrefix, name) {
    return path.posix.join(metricPrefix, name);
}
/** Transforms a OpenTelemetry instrument type to a GCM MetricKind. */ function transformMetricKind(metric) {
    switch(metric.dataPointType){
        case sdk_metrics_1.DataPointType.SUM:
            return metric.isMonotonic ? types_1.MetricKind.CUMULATIVE : types_1.MetricKind.GAUGE;
        case sdk_metrics_1.DataPointType.GAUGE:
            return types_1.MetricKind.GAUGE;
        case sdk_metrics_1.DataPointType.HISTOGRAM:
        case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
            return types_1.MetricKind.CUMULATIVE;
        default:
            exhaust(metric);
            // No logging needed as it will be done in transformPoints()
            return types_1.MetricKind.UNSPECIFIED;
    }
}
/** Transforms a OpenTelemetry ValueType to a GCM ValueType. */ function transformValueType(metric) {
    const { dataPointType, descriptor: { valueType } } = metric;
    switch(dataPointType){
        case sdk_metrics_1.DataPointType.HISTOGRAM:
        case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
            return types_1.ValueType.DISTRIBUTION;
        case sdk_metrics_1.DataPointType.GAUGE:
        case sdk_metrics_1.DataPointType.SUM:
            break;
        default:
            exhaust(dataPointType);
            // No logging needed as it will be done in transformPoints()
            return types_1.ValueType.VALUE_TYPE_UNSPECIFIED;
    }
    switch(valueType){
        case api_1.ValueType.DOUBLE:
            return types_1.ValueType.DOUBLE;
        case api_1.ValueType.INT:
            return types_1.ValueType.INT64;
        default:
            exhaust(valueType);
            api_1.diag.info('Encountered unexpected value type %s', valueType);
            return types_1.ValueType.VALUE_TYPE_UNSPECIFIED;
    }
}
/**
 * Converts metric's timeseries to a TimeSeries, so that metric can be
 * uploaded to GCM.
 */ function createTimeSeries(metric, resource, metricPrefix) {
    const metricKind = transformMetricKind(metric);
    const valueType = transformValueType(metric);
    return transformPoints(metric, metricPrefix).map(({ point, metric })=>({
            metric,
            resource,
            metricKind,
            valueType,
            points: [
                point
            ]
        }));
}
exports.createTimeSeries = createTimeSeries;
function transformMetric(point, instrumentDescriptor, metricPrefix) {
    const type = transformMetricType(metricPrefix, instrumentDescriptor.name);
    const labels = {};
    Object.keys(point.attributes).forEach((key)=>{
        labels[normalizeLabelKey(key)] = `${point.attributes[key]}`;
    });
    return {
        type,
        labels
    };
}
/**
 * Transform timeseries's point, so that metric can be uploaded to GCM.
 */ function transformPoints(metric, metricPrefix) {
    switch(metric.dataPointType){
        case sdk_metrics_1.DataPointType.SUM:
        case sdk_metrics_1.DataPointType.GAUGE:
            return metric.dataPoints.map((dataPoint)=>({
                    metric: transformMetric(dataPoint, metric.descriptor, metricPrefix),
                    point: {
                        value: transformNumberValue(metric.descriptor.valueType, dataPoint.value),
                        interval: {
                            // Add start time for non-gauge points
                            ...metric.dataPointType === sdk_metrics_1.DataPointType.SUM && metric.isMonotonic ? {
                                startTime: new precise_date_1.PreciseDate(dataPoint.startTime).toISOString()
                            } : null,
                            endTime: new precise_date_1.PreciseDate(dataPoint.endTime).toISOString()
                        }
                    }
                }));
        case sdk_metrics_1.DataPointType.HISTOGRAM:
            return metric.dataPoints.map((dataPoint)=>({
                    metric: transformMetric(dataPoint, metric.descriptor, metricPrefix),
                    point: {
                        value: transformHistogramValue(dataPoint.value),
                        interval: {
                            startTime: new precise_date_1.PreciseDate(dataPoint.startTime).toISOString(),
                            endTime: new precise_date_1.PreciseDate(dataPoint.endTime).toISOString()
                        }
                    }
                }));
        case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
            return metric.dataPoints.map((dataPoint)=>({
                    metric: transformMetric(dataPoint, metric.descriptor, metricPrefix),
                    point: {
                        value: transformExponentialHistogramValue(dataPoint.value),
                        interval: {
                            startTime: new precise_date_1.PreciseDate(dataPoint.startTime).toISOString(),
                            endTime: new precise_date_1.PreciseDate(dataPoint.endTime).toISOString()
                        }
                    }
                }));
        default:
            exhaust(metric);
            api_1.diag.info('Encountered unexpected dataPointType=%s, dropping %s points', metric.dataPointType, metric.dataPoints.length);
            break;
    }
    return [];
}
/** Transforms a OpenTelemetry Point's value to a GCM Point value. */ function transformNumberValue(valueType, value) {
    if (valueType === api_1.ValueType.INT) {
        return {
            int64Value: value.toString()
        };
    } else if (valueType === api_1.ValueType.DOUBLE) {
        return {
            doubleValue: value
        };
    }
    exhaust(valueType);
    throw Error(`unsupported value type: ${valueType}`);
}
function transformHistogramValue(value) {
    return {
        distributionValue: {
            // sumOfSquaredDeviation param not aggregated
            count: value.count.toString(),
            mean: value.count && value.sum ? value.sum / value.count : 0,
            bucketOptions: {
                explicitBuckets: {
                    bounds: value.buckets.boundaries
                }
            },
            bucketCounts: (0, utils_1.numbersToStrings)(value.buckets.counts)
        }
    };
}
function transformExponentialHistogramValue(value) {
    // Adapated from reference impl in Go which has more explanatory comments
    // https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/exporter/collector/metrics.go#L582
    const underflow = value.zeroCount + value.negative.bucketCounts.reduce((prev, current)=>prev + current, 0);
    const bucketCounts = [
        underflow,
        ...value.positive.bucketCounts,
        0
    ];
    let bucketOptions;
    if (value.positive.bucketCounts.length === 0) {
        bucketOptions = {
            explicitBuckets: {
                bounds: []
            }
        };
    } else {
        const growthFactor = (0, utils_1.exp2)((0, utils_1.exp2)(-value.scale));
        const scale = Math.pow(growthFactor, value.positive.offset);
        bucketOptions = {
            exponentialBuckets: {
                growthFactor,
                scale,
                numFiniteBuckets: bucketCounts.length - 2
            }
        };
    }
    const mean = value.sum === undefined || value.count === 0 ? 0 : value.sum / value.count;
    return {
        distributionValue: {
            // sumOfSquaredDeviation param not aggregated
            count: value.count.toString(),
            mean,
            bucketOptions,
            bucketCounts: (0, utils_1.numbersToStrings)(bucketCounts)
        }
    };
}
function normalizeLabelKey(key) {
    // Replace characters which are not Letter or Decimal_Number unicode category with "_", see
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes
    //
    // Reimplementation of reference impl in Go:
    // https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/e955c204f4f2bfdc92ff0ad52786232b975efcc2/exporter/metric/metric.go#L595-L604
    let sanitized = key.replace(/[^\p{Letter}\p{Decimal_Number}_]/gu, '_');
    if (sanitized[0].match(/\p{Decimal_Number}/u)) {
        sanitized = 'key_' + sanitized;
    }
    return sanitized;
}
/**
 * Assert switch case is exhaustive
 */ function exhaust(switchValue) {
    return switchValue;
}
exports._TEST_ONLY = {
    normalizeLabelKey
}; //# sourceMappingURL=transform.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/version.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VERSION = void 0;
// Autogenerated by scripts/version-update.js during compilation. Check this
// file in.
exports.VERSION = '0.19.0'; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/monitoring.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetricExporter = void 0;
const core_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-rsc] (ecmascript)");
const google_auth_library_1 = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-rsc] (ecmascript)");
// Import directly from this module instead of googleapis to improve bundler tree shaking
const monitoring_1 = __turbopack_context__.r("[project]/node_modules/googleapis/build/src/apis/monitoring/index.js [app-rsc] (ecmascript)");
const transform_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/transform.js [app-rsc] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/utils.js [app-rsc] (ecmascript)");
const api_1 = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
const opentelemetry_resource_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/index.js [app-rsc] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/version.js [app-rsc] (ecmascript)");
// Stackdriver Monitoring v3 only accepts up to 200 TimeSeries per
// CreateTimeSeries call.
const MAX_BATCH_EXPORT_SIZE = 200;
const OT_USER_AGENTS = [
    {
        product: 'opentelemetry-js',
        version: core_1.VERSION
    },
    {
        product: 'google-cloud-metric-exporter',
        version: version_1.VERSION
    }
];
const OT_REQUEST_HEADER = {
    'x-opentelemetry-outgoing-request': 0x1
};
/**
 * Format and sends metrics information to Google Cloud Monitoring.
 */ class MetricExporter {
    constructor(options = {}){
        var _a;
        /**
         * Set of OTel metric names that have already had their metric descriptors successfully
         * created
         */ this.createdMetricDescriptors = new Set();
        this._metricPrefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : MetricExporter.DEFAULT_METRIC_PREFIX;
        this._disableCreateMetricDescriptors = !!options.disableCreateMetricDescriptors;
        this._auth = new google_auth_library_1.GoogleAuth({
            credentials: options.credentials,
            keyFile: options.keyFile,
            keyFilename: options.keyFilename,
            projectId: options.projectId,
            scopes: [
                'https://www.googleapis.com/auth/cloud-platform'
            ]
        });
        this._monitoring = (0, monitoring_1.monitoring)({
            version: 'v3',
            rootUrl: 'https://' + (options.apiEndpoint || 'monitoring.googleapis.com:443'),
            headers: OT_REQUEST_HEADER,
            userAgentDirectives: OT_USER_AGENTS.concat(options.userAgent ? [
                options.userAgent
            ] : [])
        });
        // Start this async process as early as possible. It will be
        // awaited on the first export because constructors are synchronous
        this._projectId = this._auth.getProjectId().catch((err)=>{
            api_1.diag.error(err);
        });
    }
    /**
     * Implementation for {@link PushMetricExporter.export}.
     * Calls the async wrapper method {@link _exportAsync} and
     * assures no rejected promises bubble up to the caller.
     *
     * @param metrics Metrics to be sent to the Google Cloud Monitoring backend
     * @param resultCallback result callback to be called on finish
     */ export(metrics, resultCallback) {
        this._exportAsync(metrics).then(resultCallback, (err)=>{
            api_1.diag.error(err.message);
            resultCallback({
                code: core_1.ExportResultCode.FAILED,
                error: err
            });
        });
    }
    async shutdown() {}
    async forceFlush() {}
    /**
     * Asnyc wrapper for the {@link export} implementation.
     * Writes the current values of all exported {@link MetricRecord}s
     * to the Google Cloud Monitoring backend.
     *
     * @param resourceMetrics Metrics to be sent to the Google Cloud Monitoring backend
     */ async _exportAsync(resourceMetrics) {
        if (this._projectId instanceof Promise) {
            this._projectId = await this._projectId;
        }
        if (!this._projectId) {
            const error = new Error('expecting a non-blank ProjectID');
            api_1.diag.error(error.message);
            return {
                code: core_1.ExportResultCode.FAILED,
                error
            };
        }
        api_1.diag.debug('Google Cloud Monitoring export');
        const resource = (0, opentelemetry_resource_util_1.mapOtelResourceToMonitoredResource)(resourceMetrics.resource);
        const timeSeries = [];
        for (const scopeMetric of resourceMetrics.scopeMetrics){
            for (const metric of scopeMetric.metrics){
                const isRegistered = this._disableCreateMetricDescriptors || await this._registerMetricDescriptor(metric);
                if (isRegistered) {
                    timeSeries.push(...(0, transform_1.createTimeSeries)(metric, resource, this._metricPrefix));
                }
            }
        }
        let failure = {
            sendFailed: false
        };
        for (const batchedTimeSeries of (0, utils_1.partitionList)(timeSeries, MAX_BATCH_EXPORT_SIZE)){
            try {
                await this._sendTimeSeries(batchedTimeSeries);
            } catch (e) {
                const err = asError(e);
                err.message = `Send TimeSeries failed: ${err.message}`;
                failure = {
                    sendFailed: true,
                    error: err
                };
                api_1.diag.error(err.message);
            }
        }
        if (failure.sendFailed) {
            return {
                code: core_1.ExportResultCode.FAILED,
                error: failure.error
            };
        }
        return {
            code: core_1.ExportResultCode.SUCCESS
        };
    }
    /**
     * Returns true if the given metricDescriptor is successfully registered to
     * Google Cloud Monitoring, or the exact same metric has already been
     * registered. Returns false otherwise and should be skipped.
     *
     * @param metric The OpenTelemetry MetricData.
     */ async _registerMetricDescriptor(metric) {
        const isDescriptorCreated = this.createdMetricDescriptors.has(metric.descriptor.name);
        if (isDescriptorCreated) {
            return true;
        }
        const res = await this._createMetricDescriptorIfNeeded(metric);
        if (res) {
            this.createdMetricDescriptors.add(metric.descriptor.name);
            return true;
        }
        return false;
    }
    /**
     * Returns true if a descriptor already exists within the requested GCP project id;
     * @param descriptor The metric descriptor to check
     * @param projectIdPath The GCP project id path
     * @param authClient The authenticated client which will be used to make the request
     * @returns {boolean}
     */ async _checkIfDescriptorExists(descriptor, projectIdPath, authClient) {
        try {
            await this._monitoring.projects.metricDescriptors.get({
                name: `${projectIdPath}/metricDescriptors/${descriptor.type}`,
                auth: authClient
            });
            return true;
        } catch (error) {
            return false;
        }
    }
    /**
     * Calls CreateMetricDescriptor in the GCM API for the given InstrumentDescriptor if needed
     * @param metric The OpenTelemetry MetricData.
     * @returns whether or not the descriptor was successfully created
     */ async _createMetricDescriptorIfNeeded(metric) {
        const authClient = await this._authorize();
        const descriptor = (0, transform_1.transformMetricDescriptor)(metric, this._metricPrefix);
        const projectIdPath = (0, utils_1.mountProjectIdPath)(this._projectId);
        try {
            const descriptorExists = await this._checkIfDescriptorExists(descriptor, projectIdPath, authClient);
            if (!descriptorExists) {
                await this._monitoring.projects.metricDescriptors.create({
                    name: projectIdPath,
                    requestBody: descriptor,
                    auth: authClient
                });
                api_1.diag.debug('sent metric descriptor', descriptor);
            }
            return true;
        } catch (e) {
            const err = asError(e);
            api_1.diag.error('Failed to create metric descriptor: %s', err.message);
            return false;
        }
    }
    async _sendTimeSeries(timeSeries) {
        if (timeSeries.length === 0) {
            return Promise.resolve();
        }
        const authClient = await this._authorize();
        await this._monitoring.projects.timeSeries.create({
            name: (0, utils_1.mountProjectIdPath)(this._projectId),
            requestBody: {
                timeSeries
            },
            auth: authClient
        });
        api_1.diag.debug('sent time series', timeSeries);
    }
    /**
     * Gets the Google Application Credentials from the environment variables
     * and authenticates the client.
     */ async _authorize() {
        return await this._auth.getClient();
    }
}
exports.MetricExporter = MetricExporter;
MetricExporter.DEFAULT_METRIC_PREFIX = 'workload.googleapis.com';
function asError(error) {
    if (error instanceof Error) {
        return error;
    }
    return new Error(String(error));
} //# sourceMappingURL=monitoring.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/external-types.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-monitoring-exporter/build/src/monitoring.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/precise-date/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PreciseDate = void 0;
const FULL_ISO_REG = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d{4,9}Z/;
const NO_BIG_INT = 'BigInt only available in Node >= v10.7. Consider using getFullTimeString instead.';
var Sign;
(function(Sign) {
    Sign[Sign["NEGATIVE"] = -1] = "NEGATIVE";
    Sign[Sign["POSITIVE"] = 1] = "POSITIVE";
    Sign[Sign["ZERO"] = 0] = "ZERO";
})(Sign || (Sign = {}));
/**
 * The native Date object.
 * @external Date
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date}
 */ /**
 * @typedef {array} DateTuple
 * @property {number} 0 Represents seconds of UTC time since Unix epoch
 *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
 *     9999-12-31T23:59:59Z inclusive.
 * @property {number} 1 Non-negative fractions of a second at nanosecond
 *     resolution. Negative second values with fractions must still have
 *     non-negative nanos values that count forward in time. Must be from 0 to
 *     999,999,999 inclusive.
 */ /**
 * @typedef {object} DateStruct
 * @property {number} seconds Represents seconds of UTC time since Unix epoch
 *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
 *     9999-12-31T23:59:59Z inclusive.
 * @property {number} nanos Non-negative fractions of a second at nanosecond
 *     resolution. Negative second values with fractions must still have
 *     non-negative nanos values that count forward in time. Must be from 0 to
 *     999,999,999 inclusive.
 */ /**
 * Date object with nanosecond precision. Supports all standard Date arguments
 * in addition to several custom types as noted below.
 *
 * @class
 * @extends external:Date
 *
 * @param {number|string|bigint|Date|DateTuple|DateStruct} [time] The time
 *     value.
 * @param {...number} [dateFields] Additional date fields (month, date, hours,
 *     minutes, seconds, milliseconds, microseconds, nanoseconds).
 *
 * @example <caption>With a RFC 3339 formatted string.</caption>
 * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
 *
 * @example <caption>With a nanosecond timestamp string.</caption>
 * const date = new PreciseDate('1549622069481320032');
 *
 * @example <caption>With a BigInt (requires Node >= v10.7)</caption>
 * const date = new PreciseDate(1549622069481320032n);
 *
 * @example <caption>With a tuple containing seconds and nanoseconds.</caption>
 * const date = new PreciseDate([1549622069, 481320032]);
 *
 * @example <caption>With an object containing `seconds` and `nanos`</caption>
 * const date = new PreciseDate({seconds: 1549622069, nanos: 481320032});
 *
 * @example <caption>Specifiying date fields</caption>
 * const date = new PreciseDate(2018, 5, 14, 41, 11, 34, 123, 874, 321);
 */ class PreciseDate extends Date {
    constructor(time){
        super();
        this._micros = 0;
        this._nanos = 0;
        if (time && typeof time !== 'number' && !(time instanceof Date)) {
            this.setFullTime(PreciseDate.parseFull(time));
            return;
        }
        // eslint-disable-next-line prefer-rest-params
        const args = Array.from(arguments);
        const dateFields = args.slice(0, 7);
        const date = new Date(...dateFields);
        const nanos = args.length === 9 ? args.pop() : 0;
        const micros = args.length === 8 ? args.pop() : 0;
        this.setTime(date.getTime());
        this.setMicroseconds(micros);
        this.setNanoseconds(nanos);
    }
    /**
     * Returns the specified date represented in nanoseconds according to
     * universal time.
     *
     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.
     * Use {@link PreciseDate#getFullTimeString} to get the time as a string.
     *
     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}
     *
     * @throws {error} If `BigInt` is unavailable.
     * @returns {bigint}
     *
     * @example
     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
     *
     * console.log(date.getFullTime());
     * // expected output: 1549622069481145231n
     */ getFullTime() {
        if (typeof BigInt !== 'function') {
            throw new Error(NO_BIG_INT);
        }
        return BigInt(this.getFullTimeString());
    }
    /**
     * Returns a string of the specified date represented in nanoseconds according
     * to universal time.
     *
     * @returns {string}
     *
     * @example
     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
     *
     * console.log(date.getFullTimeString());
     * // expected output: "1549622069481145231"
     */ getFullTimeString() {
        const seconds = this._getSeconds();
        let nanos = this._getNanos();
        if (nanos && Math.sign(seconds) === Sign.NEGATIVE) {
            nanos = 1e9 - nanos;
        }
        return `${seconds}${padLeft(nanos, 9)}`;
    }
    /**
     * Returns the microseconds in the specified date according to universal time.
     *
     * @returns {number}
     *
     * @example
     * const date = new PreciseDate('2019-02-08T10:34:29.481145Z');
     *
     * console.log(date.getMicroseconds());
     * // expected output: 145
     */ getMicroseconds() {
        return this._micros;
    }
    /**
     * Returns the nanoseconds in the specified date according to universal time.
     *
     * @returns {number}
     *
     * @example
     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
     *
     * console.log(date.getNanoseconds());
     * // expected output: 231
     */ getNanoseconds() {
        return this._nanos;
    }
    /**
     * Sets the microseconds for a specified date according to universal time.
     *
     * @param {number} microseconds A number representing the microseconds.
     * @returns {string} Returns a string representing the nanoseconds in the
     *     specified date according to universal time.
     *
     * @example
     * const date = new PreciseDate();
     *
     * date.setMicroseconds(149);
     *
     * console.log(date.getMicroseconds());
     * // expected output: 149
     */ setMicroseconds(micros) {
        const abs = Math.abs(micros);
        let millis = this.getUTCMilliseconds();
        if (abs >= 1000) {
            millis += Math.floor(abs / 1000) * Math.sign(micros);
            micros %= 1000;
        }
        if (Math.sign(micros) === Sign.NEGATIVE) {
            millis -= 1;
            micros += 1000;
        }
        this._micros = micros;
        this.setUTCMilliseconds(millis);
        return this.getFullTimeString();
    }
    /**
     * Sets the nanoseconds for a specified date according to universal time.
     *
     * @param {number} nanoseconds A number representing the nanoseconds.
     * @returns {string} Returns a string representing the nanoseconds in the
     *     specified date according to universal time.
     *
     * @example
     * const date = new PreciseDate();
     *
     * date.setNanoseconds(231);
     *
     * console.log(date.getNanoseconds());
     * // expected output: 231
     */ setNanoseconds(nanos) {
        const abs = Math.abs(nanos);
        let micros = this._micros;
        if (abs >= 1000) {
            micros += Math.floor(abs / 1000) * Math.sign(nanos);
            nanos %= 1000;
        }
        if (Math.sign(nanos) === Sign.NEGATIVE) {
            micros -= 1;
            nanos += 1000;
        }
        this._nanos = nanos;
        return this.setMicroseconds(micros);
    }
    /**
     * Sets the PreciseDate object to the time represented by a number of
     * nanoseconds since January 1, 1970, 00:00:00 UTC.
     *
     * @param {bigint|number|string} time Value representing the number of
     *     nanoseconds since January 1, 1970, 00:00:00 UTC.
     * @returns {string} Returns a string representing the nanoseconds in the
     *     specified date according to universal time (effectively, the value of
     *     the argument).
     *
     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}
     *
     * @example <caption>With a nanosecond string.</caption>
     * const date = new PreciseDate();
     * date.setFullTime('1549622069481145231');
     *
     * @example <caption>With a BigInt</caption>
     * date.setFullTime(1549622069481145231n);
     */ setFullTime(time) {
        if (typeof time !== 'string') {
            time = time.toString();
        }
        const sign = Math.sign(Number(time));
        time = time.replace(/^-/, '');
        const seconds = Number(time.substr(0, time.length - 9)) * sign;
        const nanos = Number(time.substr(-9)) * sign;
        this.setTime(seconds * 1000);
        return this.setNanoseconds(nanos);
    }
    /**
     * Sets the PreciseDate object to the time represented by a number of
     * milliseconds since January 1, 1970, 00:00:00 UTC. Calling this method will
     * reset both the microseconds and nanoseconds to 0.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime|Date#setTime}
     *
     * @param {number} time Value representing the number of milliseconds since
     *     January 1, 1970, 00:00:00 UTC.
     * @returns {string} The number of milliseconds between January 1, 1970,
     *     00:00:00 UTC and the updated date (effectively, the value of the
     *     argument).
     */ setTime(time) {
        this._micros = 0;
        this._nanos = 0;
        return super.setTime(time);
    }
    /**
     * Returns a string in RFC 3339 format. Unlike the native `Date#toISOString`,
     * this will return 9 digits to represent sub-second precision.
     *
     * @see {@link https://tools.ietf.org/html/rfc3339|RFC 3339}
     *
     * @returns {string}
     *
     * @example
     * const date = new PreciseDate(1549622069481145231n);
     *
     * console.log(date.toISOString());
     * // expected output: "2019-02-08T10:34:29.481145231Z"
     */ toISOString() {
        const micros = padLeft(this._micros, 3);
        const nanos = padLeft(this._nanos, 3);
        return super.toISOString().replace(/z$/i, `${micros}${nanos}Z`);
    }
    /**
     * Returns an object representing the specified date according to universal
     * time.
     *
     * @see {@link https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#timestamp|google.protobuf.Timestamp}
     *
     * @returns {DateStruct}
     *
     * @example
     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
     *
     * console.log(date.toStruct());
     * // expected output: {seconds: 1549622069, nanos: 481145231}
     */ toStruct() {
        let seconds = this._getSeconds();
        const nanos = this._getNanos();
        const sign = Math.sign(seconds);
        // These objects are essentially a mirror of protobuf timestamps.
        // `nanos` must always count forward in time, even if the date is <= Unix
        // epoch. To do this we just need to count backwards 1 second and return the
        // nanoseconds as is.
        if (sign === Sign.NEGATIVE && nanos) {
            seconds -= 1;
        }
        return {
            seconds,
            nanos
        };
    }
    /**
     * Returns a tuple representing the specified date according to universal
     * time.
     *
     * @returns {DateTuple}
     *
     * @example
     * const date = new PreciseDate('2019-02-08T10:34:29.481145231Z');
     *
     * console.log(date.toTuple());
     * // expected output: [1549622069, 481145231]
     */ toTuple() {
        const { seconds, nanos } = this.toStruct();
        return [
            seconds,
            nanos
        ];
    }
    /**
     * Returns the total number of seconds in the specified date since Unix epoch.
     * Numbers representing < epoch will be negative.
     *
     * @private
     *
     * @returns {number}
     */ _getSeconds() {
        const time = this.getTime();
        const sign = Math.sign(time);
        return Math.floor(Math.abs(time) / 1000) * sign;
    }
    /**
     * Returns the sub-second precision of the specified date. This will always be
     * a positive number.
     *
     * @private
     *
     * @returns {number}
     */ _getNanos() {
        const msInNanos = this.getUTCMilliseconds() * 1e6;
        const microsInNanos = this._micros * 1000;
        return this._nanos + msInNanos + microsInNanos;
    }
    /**
     * Parses a precise time.
     *
     * @static
     *
     * @param {string|bigint|DateTuple|DateStruct} time The precise time value.
     * @returns {string} Returns a string representing the nanoseconds in the
     *     specified date according to universal time.
     *
     * @example <caption>From a RFC 3339 formatted string.</caption>
     * const time = PreciseDate.parseFull('2019-02-08T10:34:29.481145231Z');
     * console.log(time); // expected output: "1549622069481145231"
     *
     * @example <caption>From a nanosecond timestamp string.</caption>
     * const time = PreciseDate.parseFull('1549622069481145231');
     * console.log(time); // expected output: "1549622069481145231"
     *
     * @example <caption>From a BigInt (requires Node >= v10.7)</caption>
     * const time = PreciseDate.parseFull(1549622069481145231n);
     * console.log(time); // expected output: "1549622069481145231"
     *
     * @example <caption>From a tuple.</caption>
     * const time = PreciseDate.parseFull([1549622069, 481145231]);
     * console.log(time); // expected output: "1549622069481145231"
     *
     * @example <caption>From an object.</caption>
     * const struct = {seconds: 1549622069, nanos: 481145231};
     * const time = PreciseDate.parseFull(struct);
     * console.log(time); // expected output: "1549622069481145231"
     */ static parseFull(time) {
        const date = new PreciseDate();
        if (Array.isArray(time)) {
            const [seconds, nanos] = time;
            time = {
                seconds,
                nanos
            };
        }
        if (isFullTime(time)) {
            date.setFullTime(time);
        } else if (isStruct(time)) {
            const { seconds, nanos } = parseProto(time);
            date.setTime(seconds * 1000);
            date.setNanoseconds(nanos);
        } else if (isFullISOString(time)) {
            date.setFullTime(parseFullISO(time));
        } else {
            date.setTime(new Date(time).getTime());
        }
        return date.getFullTimeString();
    }
    /**
     * Accepts the same number parameters as the PreciseDate constructor, but
     * treats them as UTC. It returns a string that represents the number of
     * nanoseconds since January 1, 1970, 00:00:00 UTC.
     *
     * **NOTE:** Because this method returns a `BigInt` it requires Node >= v10.7.
     *
     * @see {@link https://github.com/tc39/proposal-bigint|BigInt}
     *
     * @static
     *
     * @throws {error} If `BigInt` is unavailable.
     *
     * @param {...number} [dateFields] The date fields.
     * @returns {bigint}
     *
     * @example
     * const time = PreciseDate.fullUTC(2019, 1, 8, 10, 34, 29, 481, 145, 231);
     * console.log(time); // expected output: 1549622069481145231n
     */ static fullUTC(...args) {
        if (typeof BigInt !== 'function') {
            throw new Error(NO_BIG_INT);
        }
        return BigInt(PreciseDate.fullUTCString(...args));
    }
    /**
     * Accepts the same number parameters as the PreciseDate constructor, but
     * treats them as UTC. It returns a string that represents the number of
     * nanoseconds since January 1, 1970, 00:00:00 UTC.
     *
     * @static
     *
     * @param {...number} [dateFields] The date fields.
     * @returns {string}
     *
     * @example
     * const time = PreciseDate.fullUTCString(2019, 1, 8, 10, 34, 29, 481, 145,
     * 231); console.log(time); // expected output: '1549622069481145231'
     */ static fullUTCString(...args) {
        const milliseconds = Date.UTC(...args.slice(0, 7));
        const date = new PreciseDate(milliseconds);
        if (args.length === 9) {
            date.setNanoseconds(args.pop());
        }
        if (args.length === 8) {
            date.setMicroseconds(args.pop());
        }
        return date.getFullTimeString();
    }
}
exports.PreciseDate = PreciseDate;
/**
 * Parses a RFC 3339 formatted string representation of the date, and returns
 * a string representing the nanoseconds since January 1, 1970, 00:00:00.
 *
 * @private
 *
 * @param {string} time The RFC 3339 formatted string.
 * @returns {string}
 */ function parseFullISO(time) {
    let digits = '0';
    time = time.replace(/\.(\d+)/, ($0, $1)=>{
        digits = $1;
        return '.000';
    });
    const nanos = Number(padRight(digits, 9));
    const date = new PreciseDate(time);
    return date.setNanoseconds(nanos);
}
/**
 * Normalizes a {@link google.protobuf.Timestamp} object.
 *
 * @private
 *
 * @param {google.protobuf.Timestamp} timestamp The timestamp object.
 * @returns {DateStruct}
 */ function parseProto({ seconds = 0, nanos = 0 }) {
    if (typeof seconds.toNumber === 'function') {
        seconds = seconds.toNumber();
    }
    seconds = Number(seconds);
    nanos = Number(nanos);
    return {
        seconds,
        nanos
    };
}
/**
 * Checks to see if time value is specified in nanoseconds. We assume that all
 * BigInt and string timestamps represent nanoseconds.
 *
 * @private
 *
 * @param {*} time The time to check.
 * @returns {boolean}
 */ function isFullTime(time) {
    return typeof time === 'bigint' || typeof time === 'string' && /^\d+$/.test(time);
}
/**
 * Checks to see if time value is a {@link DateStruct}.
 *
 * @private
 *
 * @param {*} time The time to check.
 * @returns {boolean}
 */ function isStruct(time) {
    return typeof time === 'object' && typeof time.seconds !== 'undefined' || typeof time.nanos === 'number';
}
/**
 * Checks to see if the time value is a RFC 3339 formatted string.
 *
 * @private
 *
 * @param {*} time The time to check.
 * @returns {boolean}
 */ function isFullISOString(time) {
    return typeof time === 'string' && FULL_ISO_REG.test(time);
}
/**
 * Pads a number/string with "0" to the left.
 *
 * @private
 *
 * @param {string|number} n The number/string to pad.
 * @param {number} min The min size of the padded string.
 * @returns {string}
 */ function padLeft(n, min) {
    const padding = getPadding(n, min);
    return `${padding}${n}`;
}
/**
 * Pads a number/string with "0" to the right.
 *
 * @private
 *
 * @param {string|number} n The number/string to pad.
 * @param {number} min The min size of the padded string.
 * @returns {string}
 */ function padRight(n, min) {
    const padding = getPadding(n, min);
    return `${n}${padding}`;
}
/**
 * Creates padding based on current size and min size needed.
 *
 * @private
 *
 * @param {string|number} n The number/string to pad.
 * @param {number} [min=3] The min size of the padded string.
 * @returns {string}
 */ function getPadding(n, min) {
    const size = Math.max(min - n.toString().length, 0);
    return '0'.repeat(size);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/faas.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.faasCloudRegion = exports.faasInstance = exports.faasVersion = exports.faasName = exports.onCloudFunctions = exports.onCloudRun = void 0;
/**
 * Implementation in this file copied from
 * https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/detectors/gcp/faas.go
 */ const metadata = __turbopack_context__.r("[project]/node_modules/gcp-metadata/build/src/index.js [app-rsc] (ecmascript)");
const ID_METADATA_ATTR = 'id';
const CLOUD_RUN_CONFIG_ENV = 'K_CONFIGURATION';
const CLOUD_FUNCTION_TARGET_ENV = 'FUNCTION_TARGET';
const FAAS_SERVICE_ENV = 'K_SERVICE';
const FAAS_REVISION_ENV = 'K_REVISION';
const REGION_METADATA_ATTR = 'region';
async function onCloudRun() {
    return process.env[CLOUD_RUN_CONFIG_ENV] !== undefined;
}
exports.onCloudRun = onCloudRun;
async function onCloudFunctions() {
    return process.env[CLOUD_FUNCTION_TARGET_ENV] !== undefined;
}
exports.onCloudFunctions = onCloudFunctions;
/**
 * The name of the Cloud Run or Cloud Function. Check that {@link onCloudRun()} or {@link
 * onCloudFunctions()} is true before calling this, or it may throw exceptions.
 */ async function faasName() {
    return lookupEnv(FAAS_SERVICE_ENV);
}
exports.faasName = faasName;
/**
 * The version/revision of the Cloud Run or Cloud Function. Check that {@link onCloudRun()} or
 * {@link onCloudFunctions()} is true before calling this, or it may throw exceptions.
 */ async function faasVersion() {
    return lookupEnv(FAAS_REVISION_ENV);
}
exports.faasVersion = faasVersion;
/**
 * The ID for the running instance of a Cloud Run or Cloud Function. Check that {@link
 * onCloudRun()} or {@link onCloudFunctions()} is true before calling this, or it may throw
 * exceptions.
 */ async function faasInstance() {
    // May be a bignumber.js BigNumber which can just be converted with toString(). See
    // https://github.com/googleapis/gcp-metadata#take-care-with-large-number-valued-properties
    const id = await metadata.instance(ID_METADATA_ATTR);
    return id.toString();
}
exports.faasInstance = faasInstance;
/**
 * The cloud region where the running instance of a Cloud Run or Cloud Function is located.
 * Check that {@link onCloudRun()} or {@link onCloudFunctions()} is true before calling this,
 * or it may throw exceptions.
 */ async function faasCloudRegion() {
    const region = await metadata.instance(REGION_METADATA_ATTR);
    return region.slice(region.lastIndexOf('/') + 1);
}
exports.faasCloudRegion = faasCloudRegion;
function lookupEnv(key) {
    const val = process.env[key];
    if (val === undefined) {
        throw new Error(`Environment variable ${key} not found`);
    }
    return val;
} //# sourceMappingURL=faas.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gce.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.availabilityZoneAndRegion = exports.hostName = exports.hostId = exports.hostType = exports.onGce = void 0;
/**
 * Implementation in this file copied from
 * https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/detectors/gcp/gce.go
 */ const api_1 = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
const metadata = __turbopack_context__.r("[project]/node_modules/gcp-metadata/build/src/index.js [app-rsc] (ecmascript)");
const MACHINE_TYPE_METADATA_ATTR = 'machine-type';
const ID_METADATA_ATTR = 'id';
const HOST_NAME_METADATA_ATTR = 'name';
const ZONE_METADATA_ATTR = 'zone';
async function onGce() {
    try {
        await metadata.instance(MACHINE_TYPE_METADATA_ATTR);
        return true;
    } catch (err) {
        api_1.diag.debug('Could not fetch metadata attribute %s, assuming not on GCE. Error was %s', MACHINE_TYPE_METADATA_ATTR, err);
        return false;
    }
}
exports.onGce = onGce;
/**
 * The machine type of the instance on which this program is running. Check that {@link
 * onGce()} is true before calling this, or it may throw exceptions.
 */ async function hostType() {
    return metadata.instance(MACHINE_TYPE_METADATA_ATTR);
}
exports.hostType = hostType;
/**
 * The instance ID of the instance on which this program is running. Check that {@link onGce()}
 * is true before calling this, or it may throw exceptions.
 */ async function hostId() {
    // May be a bignumber.js BigNumber which can just be converted with toString(). See
    // https://github.com/googleapis/gcp-metadata#take-care-with-large-number-valued-properties
    const id = await metadata.instance(ID_METADATA_ATTR);
    return id.toString();
}
exports.hostId = hostId;
/**
 * The instance ID of the instance on which this program is running. Check that {@link onGce()}
 * is true before calling this, or it may throw exceptions.
 */ async function hostName() {
    return metadata.instance(HOST_NAME_METADATA_ATTR);
}
exports.hostName = hostName;
/**
 * The zone and region in which this program is running. Check that {@link onGce()} is true
 * before calling this, or it may throw exceptions.
 */ async function availabilityZoneAndRegion() {
    var _a, _b;
    const fullZone = await metadata.instance(ZONE_METADATA_ATTR);
    // Format described in
    // https://cloud.google.com/compute/docs/metadata/default-metadata-values#vm_instance_metadata
    const re = /projects\/\d+\/zones\/(?<zone>(?<region>\w+-\w+)-\w+)/;
    const { zone, region } = (_b = (_a = fullZone.match(re)) === null || _a === void 0 ? void 0 : _a.groups) !== null && _b !== void 0 ? _b : {};
    if (!zone || !region) {
        throw new Error(`zone was not in the expected format: projects/PROJECT_NUM/zones/COUNTRY-REGION-ZONE. Got ${fullZone}`);
    }
    return {
        zone,
        region
    };
}
exports.availabilityZoneAndRegion = availabilityZoneAndRegion; //# sourceMappingURL=gce.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gae.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.standardCloudRegion = exports.standardAvailabilityZone = exports.flexAvailabilityZoneAndRegion = exports.serviceInstance = exports.serviceVersion = exports.serviceName = exports.onAppEngine = exports.onAppEngineStandard = void 0;
/**
 * Implementation in this file copied from
 * https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/detectors/gcp/app_engine.go
 */ const metadata = __turbopack_context__.r("[project]/node_modules/gcp-metadata/build/src/index.js [app-rsc] (ecmascript)");
const gce = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gce.js [app-rsc] (ecmascript)");
const faas = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/faas.js [app-rsc] (ecmascript)");
const GAE_SERVICE_ENV = 'GAE_SERVICE';
const GAE_VERSION_ENV = 'GAE_VERSION';
const GAE_INSTANCE_ENV = 'GAE_INSTANCE';
const GAE_ENV = 'GAE_ENV';
const GAE_STANDARD = 'standard';
const ZONE_METADATA_ATTR = 'zone';
async function onAppEngineStandard() {
    return process.env[GAE_ENV] === GAE_STANDARD;
}
exports.onAppEngineStandard = onAppEngineStandard;
async function onAppEngine() {
    return process.env[GAE_SERVICE_ENV] !== undefined;
}
exports.onAppEngine = onAppEngine;
/**
 * The service name of the app engine service. Check that {@link onAppEngine()} is true before
 * calling this, or it may throw exceptions.
 */ async function serviceName() {
    return lookupEnv(GAE_SERVICE_ENV);
}
exports.serviceName = serviceName;
/**
 * The service version of the app engine service. Check that {@link onAppEngine()} is true
 * before calling this, or it may throw exceptions.
 */ async function serviceVersion() {
    return lookupEnv(GAE_VERSION_ENV);
}
exports.serviceVersion = serviceVersion;
/**
 * The service instance of the app engine service. Check that {@link onAppEngine()} is true
 * before calling this, or it may throw exceptions.
 */ async function serviceInstance() {
    return lookupEnv(GAE_INSTANCE_ENV);
}
exports.serviceInstance = serviceInstance;
/**
 * The zone and region in which this program is running. Check that {@link onAppEngine()} is
 * true before calling this, or it may throw exceptions.
 */ async function flexAvailabilityZoneAndRegion() {
    return await gce.availabilityZoneAndRegion();
}
exports.flexAvailabilityZoneAndRegion = flexAvailabilityZoneAndRegion;
/**
 * The zone the app engine service is running in. Check that {@link onAppEngineStandard()} is
 * true before calling this, or it may throw exceptions.
 */ async function standardAvailabilityZone() {
    const zone = await metadata.instance(ZONE_METADATA_ATTR);
    // zone is of the form "projects/233510669999/zones/us15"
    return zone.slice(zone.lastIndexOf('/') + 1);
}
exports.standardAvailabilityZone = standardAvailabilityZone;
/**
 * The region the app engine service is running in. Check that {@link onAppEngineStandard()} is
 * true before calling this, or it may throw exceptions.
 */ async function standardCloudRegion() {
    return await faas.faasCloudRegion();
}
exports.standardCloudRegion = standardCloudRegion;
function lookupEnv(key) {
    const val = process.env[key];
    if (val === undefined) {
        throw new Error(`Environment variable ${key} not found`);
    }
    return val;
} //# sourceMappingURL=gae.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gke.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.availabilityZoneOrRegion = exports.clusterName = exports.hostId = exports.onGke = void 0;
/**
 * Implementation in this file copied from
 * https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/detectors/gcp/gke.go
 */ const metadata = __turbopack_context__.r("[project]/node_modules/gcp-metadata/build/src/index.js [app-rsc] (ecmascript)");
const gce = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gce.js [app-rsc] (ecmascript)");
const KUBERNETES_SERVICE_HOST_ENV = 'KUBERNETES_SERVICE_HOST';
const CLUSTER_NAME_METADATA_ATTR = 'attributes/cluster-name';
const CLUSTER_LOCATION_METADATA_ATTR = 'attributes/cluster-location';
async function onGke() {
    return process.env[KUBERNETES_SERVICE_HOST_ENV] !== undefined;
}
exports.onGke = onGke;
/**
 * The instance ID of the instance on which this program is running. Check that {@link onGke()}
 * is true before calling this, or it may throw exceptions.
 */ async function hostId() {
    return await gce.hostId();
}
exports.hostId = hostId;
/**
 * The name of the GKE cluster in which this program is running. Check that {@link onGke()} is
 * true before calling this, or it may throw exceptions.
 */ async function clusterName() {
    return metadata.instance(CLUSTER_NAME_METADATA_ATTR);
}
exports.clusterName = clusterName;
/**
 * The location of the cluster and whether the cluster is zonal or regional. Check that {@link
 * onGke()} is true before calling this, or it may throw exceptions.
 */ async function availabilityZoneOrRegion() {
    const clusterLocation = await metadata.instance(CLUSTER_LOCATION_METADATA_ATTR);
    switch(countChar(clusterLocation, '-')){
        case 1:
            return {
                type: 'region',
                value: clusterLocation
            };
        case 2:
            return {
                type: 'zone',
                value: clusterLocation
            };
        default:
            throw new Error(`unrecognized format for cluster location: ${clusterLocation}`);
    }
}
exports.availabilityZoneOrRegion = availabilityZoneOrRegion;
function countChar(s, char) {
    let count = 0;
    for(let i = 0; i < s.length; i++){
        if (s[i] === char) {
            count += 1;
        }
    }
    return count;
} //# sourceMappingURL=gke.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/detector.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GcpDetectorSync = exports.GcpDetector = void 0;
const semantic_conventions_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js [app-rsc] (ecmascript)");
const resources_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/resources/build/esm/index.js [app-rsc] (ecmascript)");
const metadata = __turbopack_context__.r("[project]/node_modules/gcp-metadata/build/src/index.js [app-rsc] (ecmascript)");
const faas = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/faas.js [app-rsc] (ecmascript)");
const gae = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gae.js [app-rsc] (ecmascript)");
const gce = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gce.js [app-rsc] (ecmascript)");
const gke = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/gke.js [app-rsc] (ecmascript)");
async function detect() {
    if (!await metadata.isAvailable()) {
        return resources_1.Resource.EMPTY;
    }
    // Note the order of these if checks is significant with more specific resources coming
    // first. E.g. Cloud Functions gen2 are executed in Cloud Run so it must be checked first.
    if (await gke.onGke()) {
        return await gkeResource();
    } else if (await faas.onCloudFunctions()) {
        return await cloudFunctionsResource();
    } else if (await faas.onCloudRun()) {
        return await cloudRunResource();
    } else if (await gae.onAppEngine()) {
        return await gaeResource();
    } else if (await gce.onGce()) {
        return await gceResource();
    }
    return resources_1.Resource.EMPTY;
}
async function gkeResource() {
    const [zoneOrRegion, k8sClusterName, hostId] = await Promise.all([
        gke.availabilityZoneOrRegion(),
        gke.clusterName(),
        gke.hostId()
    ]);
    return await makeResource({
        [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
        [zoneOrRegion.type === 'zone' ? semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE : semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: zoneOrRegion.value,
        [semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME]: k8sClusterName,
        [semantic_conventions_1.SEMRESATTRS_HOST_ID]: hostId
    });
}
async function cloudRunResource() {
    const [faasName, faasVersion, faasInstance, faasCloudRegion] = await Promise.all([
        faas.faasName(),
        faas.faasVersion(),
        faas.faasInstance(),
        faas.faasCloudRegion()
    ]);
    return await makeResource({
        [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
        [semantic_conventions_1.SEMRESATTRS_FAAS_NAME]: faasName,
        [semantic_conventions_1.SEMRESATTRS_FAAS_VERSION]: faasVersion,
        [semantic_conventions_1.SEMRESATTRS_FAAS_INSTANCE]: faasInstance,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: faasCloudRegion
    });
}
async function cloudFunctionsResource() {
    const [faasName, faasVersion, faasInstance, faasCloudRegion] = await Promise.all([
        faas.faasName(),
        faas.faasVersion(),
        faas.faasInstance(),
        faas.faasCloudRegion()
    ]);
    return await makeResource({
        [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
        [semantic_conventions_1.SEMRESATTRS_FAAS_NAME]: faasName,
        [semantic_conventions_1.SEMRESATTRS_FAAS_VERSION]: faasVersion,
        [semantic_conventions_1.SEMRESATTRS_FAAS_INSTANCE]: faasInstance,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: faasCloudRegion
    });
}
async function gaeResource() {
    let zone, region;
    if (await gae.onAppEngineStandard()) {
        [zone, region] = await Promise.all([
            gae.standardAvailabilityZone(),
            gae.standardCloudRegion()
        ]);
    } else {
        ({ zone, region } = await gce.availabilityZoneAndRegion());
    }
    const [faasName, faasVersion, faasInstance] = await Promise.all([
        gae.serviceName(),
        gae.serviceVersion(),
        gae.serviceInstance()
    ]);
    return await makeResource({
        [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_APP_ENGINE,
        [semantic_conventions_1.SEMRESATTRS_FAAS_NAME]: faasName,
        [semantic_conventions_1.SEMRESATTRS_FAAS_VERSION]: faasVersion,
        [semantic_conventions_1.SEMRESATTRS_FAAS_INSTANCE]: faasInstance,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE]: zone,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: region
    });
}
async function gceResource() {
    const [zoneAndRegion, hostType, hostId, hostName] = await Promise.all([
        gce.availabilityZoneAndRegion(),
        gce.hostType(),
        gce.hostId(),
        gce.hostName()
    ]);
    return await makeResource({
        [semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM]: semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE]: zoneAndRegion.zone,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_REGION]: zoneAndRegion.region,
        [semantic_conventions_1.SEMRESATTRS_HOST_TYPE]: hostType,
        [semantic_conventions_1.SEMRESATTRS_HOST_ID]: hostId,
        [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: hostName
    });
}
async function makeResource(attrs) {
    const project = await metadata.project('project-id');
    return new resources_1.Resource({
        [semantic_conventions_1.SEMRESATTRS_CLOUD_PROVIDER]: semantic_conventions_1.CLOUDPROVIDERVALUES_GCP,
        [semantic_conventions_1.SEMRESATTRS_CLOUD_ACCOUNT_ID]: project,
        ...attrs
    });
}
/**
 * Async Google Cloud resource detector which populates attributes based the on environment
 * this process is running in. If not on GCP, returns an empty resource.
 *
 * @deprecated Async resource detectors are deprecated. Please use {@link GcpDetectorSync} instead.
 */ class GcpDetector {
    constructor(){
        this.detect = detect;
    }
}
exports.GcpDetector = GcpDetector;
/**
 * Google Cloud resource detector which populates attributes based on the environment this
 * process is running in. If not on GCP, returns an empty resource.
 */ class GcpDetectorSync {
    async _asyncAttributes() {
        return (await detect()).attributes;
    }
    detect() {
        return new resources_1.Resource({}, this._asyncAttributes());
    }
}
exports.GcpDetectorSync = GcpDetectorSync; //# sourceMappingURL=detector.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GcpDetectorSync = exports.GcpDetector = exports.mapOtelResourceToMonitoredResource = void 0;
const semantic_conventions_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js [app-rsc] (ecmascript)");
const AWS_ACCOUNT = 'aws_account';
const AWS_EC2_INSTANCE = 'aws_ec2_instance';
const CLOUD_FUNCTION = 'cloud_function';
const CLOUD_RUN_REVISION = 'cloud_run_revision';
const CLUSTER_NAME = 'cluster_name';
const CONFIGURATION_NAME = 'configuration_name';
const CONTAINER_NAME = 'container_name';
const FUNCTION_NAME = 'function_name';
const GAE_INSTANCE = 'gae_instance';
const GAE_MODULE_ID = 'module_id';
const GAE_VERSION_ID = 'version_id';
const GCE_INSTANCE = 'gce_instance';
const GENERIC_NODE = 'generic_node';
const GENERIC_TASK = 'generic_task';
const INSTANCE_ID = 'instance_id';
const JOB = 'job';
const K8S_CLUSTER = 'k8s_cluster';
const K8S_CONTAINER = 'k8s_container';
const K8S_NODE = 'k8s_node';
const K8S_POD = 'k8s_pod';
const LOCATION = 'location';
const NAMESPACE = 'namespace';
const NAMESPACE_NAME = 'namespace_name';
const NODE_ID = 'node_id';
const NODE_NAME = 'node_name';
const POD_NAME = 'pod_name';
const REGION = 'region';
const REVISION_NAME = 'revision_name';
const SERVICE_NAME = 'service_name';
const TASK_ID = 'task_id';
const ZONE = 'zone';
const UNKNOWN_SERVICE_PREFIX = 'unknown_service';
/**
 * Mappings of GCM resource label keys onto mapping config from OTel resource for a given
 * monitored resource type. Copied from Go impl:
 * https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/internal/resourcemapping/resourcemapping.go#L51
 */ const MAPPINGS = {
    [GCE_INSTANCE]: {
        [ZONE]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE
            ]
        },
        [INSTANCE_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_HOST_ID
            ]
        }
    },
    [K8S_CONTAINER]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [CLUSTER_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME
            ]
        },
        [NAMESPACE_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_NAMESPACE_NAME
            ]
        },
        [POD_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_POD_NAME
            ]
        },
        [CONTAINER_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_CONTAINER_NAME
            ]
        }
    },
    [K8S_POD]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [CLUSTER_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME
            ]
        },
        [NAMESPACE_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_NAMESPACE_NAME
            ]
        },
        [POD_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_POD_NAME
            ]
        }
    },
    [K8S_NODE]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [CLUSTER_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME
            ]
        },
        [NODE_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_NODE_NAME
            ]
        }
    },
    [K8S_CLUSTER]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [CLUSTER_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME
            ]
        }
    },
    [AWS_EC2_INSTANCE]: {
        [INSTANCE_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_HOST_ID
            ]
        },
        [REGION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [AWS_ACCOUNT]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_ACCOUNT_ID
            ]
        }
    },
    [CLOUD_RUN_REVISION]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [SERVICE_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_NAME
            ]
        },
        [CONFIGURATION_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_NAME
            ]
        },
        [REVISION_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_VERSION
            ]
        }
    },
    [CLOUD_FUNCTION]: {
        [REGION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [FUNCTION_NAME]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_NAME
            ]
        }
    },
    [GAE_INSTANCE]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ]
        },
        [GAE_MODULE_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_NAME
            ]
        },
        [GAE_VERSION_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_VERSION
            ]
        },
        [INSTANCE_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_FAAS_INSTANCE
            ]
        }
    },
    [GENERIC_TASK]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ],
            fallback: 'global'
        },
        [NAMESPACE]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_SERVICE_NAMESPACE
            ]
        },
        [JOB]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_SERVICE_NAME,
                semantic_conventions_1.SEMRESATTRS_FAAS_NAME
            ]
        },
        [TASK_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID,
                semantic_conventions_1.SEMRESATTRS_FAAS_INSTANCE
            ]
        }
    },
    [GENERIC_NODE]: {
        [LOCATION]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
                semantic_conventions_1.SEMRESATTRS_CLOUD_REGION
            ],
            fallback: 'global'
        },
        [NAMESPACE]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_SERVICE_NAMESPACE
            ]
        },
        [NODE_ID]: {
            otelKeys: [
                semantic_conventions_1.SEMRESATTRS_HOST_ID,
                semantic_conventions_1.SEMRESATTRS_HOST_NAME
            ]
        }
    }
};
function mapOtelResourceToMonitoredResource(resource, includeUnsupportedResources = false) {
    const attrs = resource.attributes;
    const platform = attrs[semantic_conventions_1.SEMRESATTRS_CLOUD_PLATFORM];
    let mr;
    if (platform === semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE) {
        mr = createMonitoredResource(GCE_INSTANCE, attrs);
    } else if (platform === semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_APP_ENGINE) {
        mr = createMonitoredResource(GAE_INSTANCE, attrs);
    } else if (platform === semantic_conventions_1.CLOUDPLATFORMVALUES_AWS_EC2) {
        mr = createMonitoredResource(AWS_EC2_INSTANCE, attrs);
    } else if (includeUnsupportedResources && platform === semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN) {
        mr = createMonitoredResource(CLOUD_RUN_REVISION, attrs);
    } else if (includeUnsupportedResources && platform === semantic_conventions_1.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS) {
        mr = createMonitoredResource(CLOUD_FUNCTION, attrs);
    } else if (semantic_conventions_1.SEMRESATTRS_K8S_CLUSTER_NAME in attrs) {
        // if k8s.cluster.name is set, pattern match for various k8s resources.
        // this will also match non-cloud k8s platforms like minikube.
        if (semantic_conventions_1.SEMRESATTRS_K8S_CONTAINER_NAME in attrs) {
            mr = createMonitoredResource(K8S_CONTAINER, attrs);
        } else if (semantic_conventions_1.SEMRESATTRS_K8S_POD_NAME in attrs) {
            mr = createMonitoredResource(K8S_POD, attrs);
        } else if (semantic_conventions_1.SEMRESATTRS_K8S_NODE_NAME in attrs) {
            mr = createMonitoredResource(K8S_NODE, attrs);
        } else {
            mr = createMonitoredResource(K8S_CLUSTER, attrs);
        }
    } else if ((semantic_conventions_1.SEMRESATTRS_SERVICE_NAME in attrs || semantic_conventions_1.SEMRESATTRS_FAAS_NAME in attrs) && (semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID in attrs || semantic_conventions_1.SEMRESATTRS_FAAS_INSTANCE in attrs)) {
        // fallback to generic_task
        mr = createMonitoredResource(GENERIC_TASK, attrs);
    } else {
        // If not possible, finally fallback to generic_node
        mr = createMonitoredResource(GENERIC_NODE, attrs);
    }
    return mr;
}
exports.mapOtelResourceToMonitoredResource = mapOtelResourceToMonitoredResource;
function createMonitoredResource(monitoredResourceType, resourceAttrs) {
    const mapping = MAPPINGS[monitoredResourceType];
    const labels = {};
    Object.entries(mapping).map(([mrKey, mapConfig])=>{
        var _a, _b, _c;
        let mrValue;
        const test = undefined;
        for (const otelKey of mapConfig.otelKeys){
            if (otelKey in resourceAttrs && !((_b = (_a = resourceAttrs[otelKey]) === null || _a === void 0 ? void 0 : _a.toString()) === null || _b === void 0 ? void 0 : _b.startsWith(UNKNOWN_SERVICE_PREFIX))) {
                mrValue = resourceAttrs[otelKey];
                break;
            }
        }
        if (mrValue === undefined && mapConfig.otelKeys.includes(semantic_conventions_1.SEMRESATTRS_SERVICE_NAME)) {
            // The service name started with unknown_service, was ignored above, and we couldn't find
            // a better value for mrValue.
            mrValue = resourceAttrs[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME];
        }
        if (mrValue === undefined) {
            mrValue = (_c = mapConfig.fallback) !== null && _c !== void 0 ? _c : '';
        }
        // OTel attribute values can be any of string, boolean, number, or array of any of them.
        // Encode any non-strings as json string
        if (typeof mrValue !== 'string') {
            mrValue = JSON.stringify(mrValue);
        }
        labels[mrKey] = mrValue;
    });
    return {
        type: monitoredResourceType,
        labels
    };
}
var detector_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/detector/detector.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "GcpDetector", {
    enumerable: true,
    get: function() {
        return detector_1.GcpDetector;
    }
});
Object.defineProperty(exports, "GcpDetectorSync", {
    enumerable: true,
    get: function() {
        return detector_1.GcpDetectorSync;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/external-types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=external-types.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/types.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpanKind = exports.Code = exports.LinkType = exports.Type = void 0;
var Type;
(function(Type) {
    Type[Type["TYPE_UNSPECIFIED"] = 0] = "TYPE_UNSPECIFIED";
    Type[Type["SENT"] = 1] = "SENT";
    Type[Type["RECEIVED"] = 2] = "RECEIVED";
})(Type = exports.Type || (exports.Type = {}));
var LinkType;
(function(LinkType) {
    LinkType[LinkType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    LinkType[LinkType["CHILD_LINKED_SPAN"] = 1] = "CHILD_LINKED_SPAN";
    LinkType[LinkType["PARENT_LINKED_SPAN"] = 2] = "PARENT_LINKED_SPAN";
})(LinkType = exports.LinkType || (exports.LinkType = {}));
/**
 * A google.rpc.Code
 */ var Code;
(function(Code) {
    // These are the only two we care about mapping to
    Code[Code["OK"] = 0] = "OK";
    Code[Code["UNKNOWN"] = 2] = "UNKNOWN";
})(Code = exports.Code || (exports.Code = {}));
/**
 * See https://github.com/googleapis/googleapis/blob/8cd4d12c0a02872469176659603451d84c0fbee7/google/devtools/cloudtrace/v2/trace.proto#L182
 */ var SpanKind;
(function(SpanKind) {
    // Unspecified. Do NOT use as default.
    // Implementations MAY assume SpanKind.INTERNAL to be default.
    SpanKind[SpanKind["SPAN_KIND_UNSPECIFIED"] = 0] = "SPAN_KIND_UNSPECIFIED";
    // Indicates that the span is used internally. Default value.
    SpanKind[SpanKind["INTERNAL"] = 1] = "INTERNAL";
    // Indicates that the span covers server-side handling of an RPC or other
    // remote network request.
    SpanKind[SpanKind["SERVER"] = 2] = "SERVER";
    // Indicates that the span covers the client-side wrapper around an RPC or
    // other remote request.
    SpanKind[SpanKind["CLIENT"] = 3] = "CLIENT";
    // Indicates that the span describes producer sending a message to a broker.
    // Unlike client and  server, there is no direct critical path latency
    // relationship between producer and consumer spans (e.g. publishing a
    // message to a pubsub service).
    SpanKind[SpanKind["PRODUCER"] = 4] = "PRODUCER";
    // Indicates that the span describes consumer receiving a message from a
    // broker. Unlike client and  server, there is no direct critical path
    // latency relationship between producer and consumer spans (e.g. receiving
    // a message from a pubsub service subscription).
    SpanKind[SpanKind["CONSUMER"] = 5] = "CONSUMER";
})(SpanKind = exports.SpanKind || (exports.SpanKind = {})); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/version.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VERSION = void 0;
// Autogenerated by scripts/version-update.js during compilation. Check this
// file in.
exports.VERSION = '2.4.1'; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/transform.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getReadableSpanTransformer = void 0;
const ot = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-rsc] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/types.js [app-rsc] (ecmascript)");
const opentelemetry_resource_util_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-resource-util/build/src/index.js [app-rsc] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/version.js [app-rsc] (ecmascript)");
const AGENT_LABEL_KEY = 'g.co/agent';
const AGENT_LABEL_VALUE = `opentelemetry-js ${core_1.VERSION}; google-cloud-trace-exporter ${version_1.VERSION}`;
function getReadableSpanTransformer(projectId, resourceFilter, stringifyArrayAttributes) {
    return (span)=>{
        // @todo get dropped attribute count from sdk ReadableSpan
        const attributes = mergeAttributes(transformAttributes({
            ...span.attributes,
            [AGENT_LABEL_KEY]: AGENT_LABEL_VALUE
        }, stringifyArrayAttributes), // Add in special g.co/r resource labels
        transformResourceToAttributes(span.resource, projectId, resourceFilter, stringifyArrayAttributes));
        const out = {
            attributes,
            displayName: stringToTruncatableString(span.name),
            links: {
                link: span.links.map(getLinkTransformer(stringifyArrayAttributes))
            },
            endTime: transformTime(span.endTime),
            startTime: transformTime(span.startTime),
            name: `projects/${projectId}/traces/${span.spanContext().traceId}/spans/${span.spanContext().spanId}`,
            spanKind: transformKind(span.kind),
            spanId: span.spanContext().spanId,
            sameProcessAsParentSpan: {
                value: !span.spanContext().isRemote
            },
            status: transformStatus(span.status),
            timeEvents: {
                timeEvent: span.events.map((e)=>{
                    var _a;
                    return {
                        time: transformTime(e.time),
                        annotation: {
                            attributes: transformAttributes((_a = e.attributes) !== null && _a !== void 0 ? _a : {}, stringifyArrayAttributes),
                            description: stringToTruncatableString(e.name)
                        }
                    };
                })
            }
        };
        if (span.parentSpanId) {
            out.parentSpanId = span.parentSpanId;
        }
        return out;
    };
}
exports.getReadableSpanTransformer = getReadableSpanTransformer;
function transformStatus(status) {
    switch(status.code){
        case ot.SpanStatusCode.UNSET:
            return undefined;
        case ot.SpanStatusCode.OK:
            return {
                code: types_1.Code.OK
            };
        case ot.SpanStatusCode.ERROR:
            return {
                code: types_1.Code.UNKNOWN,
                message: status.message
            };
        default:
            {
                exhaust(status.code);
                // TODO: log failed mapping
                return {
                    code: types_1.Code.UNKNOWN,
                    message: status.message
                };
            }
    }
}
function transformKind(kind) {
    switch(kind){
        case ot.SpanKind.INTERNAL:
            return types_1.SpanKind.INTERNAL;
        case ot.SpanKind.SERVER:
            return types_1.SpanKind.SERVER;
        case ot.SpanKind.CLIENT:
            return types_1.SpanKind.CLIENT;
        case ot.SpanKind.PRODUCER:
            return types_1.SpanKind.PRODUCER;
        case ot.SpanKind.CONSUMER:
            return types_1.SpanKind.CONSUMER;
        default:
            {
                exhaust(kind);
                // TODO: log failed mapping
                return types_1.SpanKind.SPAN_KIND_UNSPECIFIED;
            }
    }
}
/**
 * Assert switch case is exhaustive
 */ function exhaust(switchValue) {
    return switchValue;
}
function transformTime(time) {
    return {
        seconds: time[0],
        nanos: time[1]
    };
}
function getLinkTransformer(stringifyArrayAttributes) {
    return (link)=>{
        var _a;
        return {
            attributes: transformAttributes((_a = link.attributes) !== null && _a !== void 0 ? _a : {}, stringifyArrayAttributes),
            spanId: link.context.spanId,
            traceId: link.context.traceId,
            type: types_1.LinkType.UNSPECIFIED
        };
    };
}
function transformAttributes(attributes, stringifyArrayAttributes) {
    const changedAttributes = transformAttributeNames(attributes);
    return spanAttributesToGCTAttributes(changedAttributes, stringifyArrayAttributes);
}
function spanAttributesToGCTAttributes(attributes, stringifyArrayAttributes) {
    const attributeMap = transformAttributeValues(attributes, stringifyArrayAttributes);
    return {
        attributeMap,
        droppedAttributesCount: Object.keys(attributes).length - Object.keys(attributeMap).length
    };
}
function mergeAttributes(...attributeList) {
    const attributesOut = {
        attributeMap: {},
        droppedAttributesCount: 0
    };
    attributeList.forEach((attributes)=>{
        var _a;
        Object.assign(attributesOut.attributeMap, attributes.attributeMap);
        attributesOut.droppedAttributesCount += (_a = attributes.droppedAttributesCount) !== null && _a !== void 0 ? _a : 0;
    });
    return attributesOut;
}
function transformResourceToAttributes(resource, projectId, resourceFilter, stringifyArrayAttributes) {
    const monitoredResource = (0, opentelemetry_resource_util_1.mapOtelResourceToMonitoredResource)(resource);
    const attributes = {};
    if (resourceFilter) {
        Object.keys(resource.attributes).filter((key)=>resourceFilter.test(key)).forEach((key)=>{
            attributes[key] = resource.attributes[key];
        });
    }
    // global is the "default" so just skip
    if (monitoredResource.type !== 'global') {
        Object.keys(monitoredResource.labels).forEach((labelKey)=>{
            const key = `g.co/r/${monitoredResource.type}/${labelKey}`;
            attributes[key] = monitoredResource.labels[labelKey];
        });
    }
    return spanAttributesToGCTAttributes(attributes, stringifyArrayAttributes);
}
function transformAttributeValues(attributes, stringifyArrayAttributes) {
    const out = {};
    for (const [key, value] of Object.entries(attributes)){
        if (value === undefined) {
            continue;
        }
        const attributeValue = valueToAttributeValue(value, stringifyArrayAttributes);
        if (attributeValue !== undefined) {
            out[key] = attributeValue;
        }
    }
    return out;
}
function stringToTruncatableString(value) {
    return {
        value
    };
}
function valueToAttributeValue(value, stringifyArrayAttributes) {
    switch(typeof value){
        case 'number':
            // TODO: Consider to change to doubleValue when available in V2 API.
            return {
                intValue: String(Math.round(value))
            };
        case 'boolean':
            return {
                boolValue: value
            };
        case 'string':
            return {
                stringValue: stringToTruncatableString(value)
            };
        default:
            if (stringifyArrayAttributes) {
                return {
                    stringValue: stringToTruncatableString(JSON.stringify(value))
                };
            }
            // TODO: Handle array types without stringification once API level support is added
            return undefined;
    }
}
const HTTP_ATTRIBUTE_MAPPING = {
    'http.method': '/http/method',
    'http.url': '/http/url',
    'http.host': '/http/host',
    'http.scheme': '/http/client_protocol',
    'http.status_code': '/http/status_code',
    'http.user_agent': '/http/user_agent',
    'http.request_content_length': '/http/request/size',
    'http.response_content_length': '/http/response/size',
    'http.route': '/http/route'
};
function transformAttributeNames(attributes) {
    const out = {};
    for (const [key, value] of Object.entries(attributes)){
        if (HTTP_ATTRIBUTE_MAPPING[key]) {
            out[HTTP_ATTRIBUTE_MAPPING[key]] = value;
        } else {
            out[key] = value;
        }
    }
    return out;
} //# sourceMappingURL=transform.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/protos/protos.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"options\":{\"syntax\":\"proto3\"},\"nested\":{\"google\":{\"nested\":{\"devtools\":{\"nested\":{\"cloudtrace\":{\"nested\":{\"v2\":{\"options\":{\"csharp_namespace\":\"Google.Cloud.Trace.V2\",\"go_package\":\"cloud.google.com/go/trace/apiv2/tracepb;tracepb\",\"java_multiple_files\":true,\"java_outer_classname\":\"TraceProto\",\"java_package\":\"com.google.devtools.cloudtrace.v2\",\"php_namespace\":\"Google\\\\Cloud\\\\Trace\\\\V2\",\"ruby_package\":\"Google::Cloud::Trace::V2\"},\"nested\":{\"TraceService\":{\"options\":{\"(google.api.default_host)\":\"cloudtrace.googleapis.com\",\"(google.api.oauth_scopes)\":\"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/trace.append\"},\"methods\":{\"BatchWriteSpans\":{\"requestType\":\"BatchWriteSpansRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).post\":\"/v2/{name=projects/*}/traces:batchWrite\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"name,spans\"},\"parsedOptions\":[{\"(google.api.http)\":{\"post\":\"/v2/{name=projects/*}/traces:batchWrite\",\"body\":\"*\"}},{\"(google.api.method_signature)\":\"name,spans\"}]},\"CreateSpan\":{\"requestType\":\"Span\",\"responseType\":\"Span\",\"options\":{\"(google.api.http).post\":\"/v2/{name=projects/*/traces/*/spans/*}\",\"(google.api.http).body\":\"*\"},\"parsedOptions\":[{\"(google.api.http)\":{\"post\":\"/v2/{name=projects/*/traces/*/spans/*}\",\"body\":\"*\"}}]}}},\"BatchWriteSpansRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"cloudresourcemanager.googleapis.com/Project\"}},\"spans\":{\"rule\":\"repeated\",\"type\":\"Span\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}}}},\"Span\":{\"options\":{\"(google.api.resource).type\":\"cloudtrace.googleapis.com/Span\",\"(google.api.resource).pattern\":\"projects/{project}/traces/{trace}/spans/{span}\"},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"spanId\":{\"type\":\"string\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"parentSpanId\":{\"type\":\"string\",\"id\":3},\"displayName\":{\"type\":\"TruncatableString\",\"id\":4,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"startTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":5,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"endTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":6,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"attributes\":{\"type\":\"Attributes\",\"id\":7},\"stackTrace\":{\"type\":\"StackTrace\",\"id\":8},\"timeEvents\":{\"type\":\"TimeEvents\",\"id\":9},\"links\":{\"type\":\"Links\",\"id\":10},\"status\":{\"type\":\"google.rpc.Status\",\"id\":11,\"options\":{\"(google.api.field_behavior)\":\"OPTIONAL\"}},\"sameProcessAsParentSpan\":{\"type\":\"google.protobuf.BoolValue\",\"id\":12,\"options\":{\"(google.api.field_behavior)\":\"OPTIONAL\"}},\"childSpanCount\":{\"type\":\"google.protobuf.Int32Value\",\"id\":13,\"options\":{\"(google.api.field_behavior)\":\"OPTIONAL\"}},\"spanKind\":{\"type\":\"SpanKind\",\"id\":14,\"options\":{\"(google.api.field_behavior)\":\"OPTIONAL\"}}},\"nested\":{\"Attributes\":{\"fields\":{\"attributeMap\":{\"keyType\":\"string\",\"type\":\"AttributeValue\",\"id\":1},\"droppedAttributesCount\":{\"type\":\"int32\",\"id\":2}}},\"TimeEvent\":{\"oneofs\":{\"value\":{\"oneof\":[\"annotation\",\"messageEvent\"]}},\"fields\":{\"time\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"annotation\":{\"type\":\"Annotation\",\"id\":2},\"messageEvent\":{\"type\":\"MessageEvent\",\"id\":3}},\"nested\":{\"Annotation\":{\"fields\":{\"description\":{\"type\":\"TruncatableString\",\"id\":1},\"attributes\":{\"type\":\"Attributes\",\"id\":2}}},\"MessageEvent\":{\"fields\":{\"type\":{\"type\":\"Type\",\"id\":1},\"id\":{\"type\":\"int64\",\"id\":2},\"uncompressedSizeBytes\":{\"type\":\"int64\",\"id\":3},\"compressedSizeBytes\":{\"type\":\"int64\",\"id\":4}},\"nested\":{\"Type\":{\"values\":{\"TYPE_UNSPECIFIED\":0,\"SENT\":1,\"RECEIVED\":2}}}}}},\"TimeEvents\":{\"fields\":{\"timeEvent\":{\"rule\":\"repeated\",\"type\":\"TimeEvent\",\"id\":1},\"droppedAnnotationsCount\":{\"type\":\"int32\",\"id\":2},\"droppedMessageEventsCount\":{\"type\":\"int32\",\"id\":3}}},\"Link\":{\"fields\":{\"traceId\":{\"type\":\"string\",\"id\":1},\"spanId\":{\"type\":\"string\",\"id\":2},\"type\":{\"type\":\"Type\",\"id\":3},\"attributes\":{\"type\":\"Attributes\",\"id\":4}},\"nested\":{\"Type\":{\"values\":{\"TYPE_UNSPECIFIED\":0,\"CHILD_LINKED_SPAN\":1,\"PARENT_LINKED_SPAN\":2}}}},\"Links\":{\"fields\":{\"link\":{\"rule\":\"repeated\",\"type\":\"Link\",\"id\":1},\"droppedLinksCount\":{\"type\":\"int32\",\"id\":2}}},\"SpanKind\":{\"values\":{\"SPAN_KIND_UNSPECIFIED\":0,\"INTERNAL\":1,\"SERVER\":2,\"CLIENT\":3,\"PRODUCER\":4,\"CONSUMER\":5}}}},\"AttributeValue\":{\"oneofs\":{\"value\":{\"oneof\":[\"stringValue\",\"intValue\",\"boolValue\"]}},\"fields\":{\"stringValue\":{\"type\":\"TruncatableString\",\"id\":1},\"intValue\":{\"type\":\"int64\",\"id\":2},\"boolValue\":{\"type\":\"bool\",\"id\":3}}},\"StackTrace\":{\"fields\":{\"stackFrames\":{\"type\":\"StackFrames\",\"id\":1},\"stackTraceHashId\":{\"type\":\"int64\",\"id\":2}},\"nested\":{\"StackFrame\":{\"fields\":{\"functionName\":{\"type\":\"TruncatableString\",\"id\":1},\"originalFunctionName\":{\"type\":\"TruncatableString\",\"id\":2},\"fileName\":{\"type\":\"TruncatableString\",\"id\":3},\"lineNumber\":{\"type\":\"int64\",\"id\":4},\"columnNumber\":{\"type\":\"int64\",\"id\":5},\"loadModule\":{\"type\":\"Module\",\"id\":6},\"sourceVersion\":{\"type\":\"TruncatableString\",\"id\":7}}},\"StackFrames\":{\"fields\":{\"frame\":{\"rule\":\"repeated\",\"type\":\"StackFrame\",\"id\":1},\"droppedFramesCount\":{\"type\":\"int32\",\"id\":2}}}}},\"Module\":{\"fields\":{\"module\":{\"type\":\"TruncatableString\",\"id\":1},\"buildId\":{\"type\":\"TruncatableString\",\"id\":2}}},\"TruncatableString\":{\"fields\":{\"value\":{\"type\":\"string\",\"id\":1},\"truncatedByteCount\":{\"type\":\"int32\",\"id\":2}}}}}}}}},\"api\":{\"options\":{\"go_package\":\"google.golang.org/genproto/googleapis/api/annotations;annotations\",\"java_multiple_files\":true,\"java_outer_classname\":\"ResourceProto\",\"java_package\":\"com.google.api\",\"objc_class_prefix\":\"GAPI\",\"cc_enable_arenas\":true},\"nested\":{\"http\":{\"type\":\"HttpRule\",\"id\":72295728,\"extend\":\"google.protobuf.MethodOptions\"},\"Http\":{\"fields\":{\"rules\":{\"rule\":\"repeated\",\"type\":\"HttpRule\",\"id\":1},\"fullyDecodeReservedExpansion\":{\"type\":\"bool\",\"id\":2}}},\"HttpRule\":{\"oneofs\":{\"pattern\":{\"oneof\":[\"get\",\"put\",\"post\",\"delete\",\"patch\",\"custom\"]}},\"fields\":{\"selector\":{\"type\":\"string\",\"id\":1},\"get\":{\"type\":\"string\",\"id\":2},\"put\":{\"type\":\"string\",\"id\":3},\"post\":{\"type\":\"string\",\"id\":4},\"delete\":{\"type\":\"string\",\"id\":5},\"patch\":{\"type\":\"string\",\"id\":6},\"custom\":{\"type\":\"CustomHttpPattern\",\"id\":8},\"body\":{\"type\":\"string\",\"id\":7},\"responseBody\":{\"type\":\"string\",\"id\":12},\"additionalBindings\":{\"rule\":\"repeated\",\"type\":\"HttpRule\",\"id\":11}}},\"CustomHttpPattern\":{\"fields\":{\"kind\":{\"type\":\"string\",\"id\":1},\"path\":{\"type\":\"string\",\"id\":2}}},\"methodSignature\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1051,\"extend\":\"google.protobuf.MethodOptions\"},\"defaultHost\":{\"type\":\"string\",\"id\":1049,\"extend\":\"google.protobuf.ServiceOptions\"},\"oauthScopes\":{\"type\":\"string\",\"id\":1050,\"extend\":\"google.protobuf.ServiceOptions\"},\"apiVersion\":{\"type\":\"string\",\"id\":525000001,\"extend\":\"google.protobuf.ServiceOptions\"},\"CommonLanguageSettings\":{\"fields\":{\"referenceDocsUri\":{\"type\":\"string\",\"id\":1,\"options\":{\"deprecated\":true}},\"destinations\":{\"rule\":\"repeated\",\"type\":\"ClientLibraryDestination\",\"id\":2}}},\"ClientLibrarySettings\":{\"fields\":{\"version\":{\"type\":\"string\",\"id\":1},\"launchStage\":{\"type\":\"LaunchStage\",\"id\":2},\"restNumericEnums\":{\"type\":\"bool\",\"id\":3},\"javaSettings\":{\"type\":\"JavaSettings\",\"id\":21},\"cppSettings\":{\"type\":\"CppSettings\",\"id\":22},\"phpSettings\":{\"type\":\"PhpSettings\",\"id\":23},\"pythonSettings\":{\"type\":\"PythonSettings\",\"id\":24},\"nodeSettings\":{\"type\":\"NodeSettings\",\"id\":25},\"dotnetSettings\":{\"type\":\"DotnetSettings\",\"id\":26},\"rubySettings\":{\"type\":\"RubySettings\",\"id\":27},\"goSettings\":{\"type\":\"GoSettings\",\"id\":28}}},\"Publishing\":{\"fields\":{\"methodSettings\":{\"rule\":\"repeated\",\"type\":\"MethodSettings\",\"id\":2},\"newIssueUri\":{\"type\":\"string\",\"id\":101},\"documentationUri\":{\"type\":\"string\",\"id\":102},\"apiShortName\":{\"type\":\"string\",\"id\":103},\"githubLabel\":{\"type\":\"string\",\"id\":104},\"codeownerGithubTeams\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":105},\"docTagPrefix\":{\"type\":\"string\",\"id\":106},\"organization\":{\"type\":\"ClientLibraryOrganization\",\"id\":107},\"librarySettings\":{\"rule\":\"repeated\",\"type\":\"ClientLibrarySettings\",\"id\":109},\"protoReferenceDocumentationUri\":{\"type\":\"string\",\"id\":110},\"restReferenceDocumentationUri\":{\"type\":\"string\",\"id\":111}}},\"JavaSettings\":{\"fields\":{\"libraryPackage\":{\"type\":\"string\",\"id\":1},\"serviceClassNames\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":2},\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":3}}},\"CppSettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1}}},\"PhpSettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1}}},\"PythonSettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1}}},\"NodeSettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1}}},\"DotnetSettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1},\"renamedServices\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":2},\"renamedResources\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":3},\"ignoredResources\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":4},\"forcedNamespaceAliases\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":5},\"handwrittenSignatures\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6}}},\"RubySettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1}}},\"GoSettings\":{\"fields\":{\"common\":{\"type\":\"CommonLanguageSettings\",\"id\":1}}},\"MethodSettings\":{\"fields\":{\"selector\":{\"type\":\"string\",\"id\":1},\"longRunning\":{\"type\":\"LongRunning\",\"id\":2},\"autoPopulatedFields\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":3}},\"nested\":{\"LongRunning\":{\"fields\":{\"initialPollDelay\":{\"type\":\"google.protobuf.Duration\",\"id\":1},\"pollDelayMultiplier\":{\"type\":\"float\",\"id\":2},\"maxPollDelay\":{\"type\":\"google.protobuf.Duration\",\"id\":3},\"totalPollTimeout\":{\"type\":\"google.protobuf.Duration\",\"id\":4}}}}},\"ClientLibraryOrganization\":{\"values\":{\"CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED\":0,\"CLOUD\":1,\"ADS\":2,\"PHOTOS\":3,\"STREET_VIEW\":4,\"SHOPPING\":5,\"GEO\":6,\"GENERATIVE_AI\":7}},\"ClientLibraryDestination\":{\"values\":{\"CLIENT_LIBRARY_DESTINATION_UNSPECIFIED\":0,\"GITHUB\":10,\"PACKAGE_MANAGER\":20}},\"LaunchStage\":{\"values\":{\"LAUNCH_STAGE_UNSPECIFIED\":0,\"UNIMPLEMENTED\":6,\"PRELAUNCH\":7,\"EARLY_ACCESS\":1,\"ALPHA\":2,\"BETA\":3,\"GA\":4,\"DEPRECATED\":5}},\"fieldBehavior\":{\"rule\":\"repeated\",\"type\":\"google.api.FieldBehavior\",\"id\":1052,\"extend\":\"google.protobuf.FieldOptions\",\"options\":{\"packed\":false}},\"FieldBehavior\":{\"values\":{\"FIELD_BEHAVIOR_UNSPECIFIED\":0,\"OPTIONAL\":1,\"REQUIRED\":2,\"OUTPUT_ONLY\":3,\"INPUT_ONLY\":4,\"IMMUTABLE\":5,\"UNORDERED_LIST\":6,\"NON_EMPTY_DEFAULT\":7,\"IDENTIFIER\":8}},\"resourceReference\":{\"type\":\"google.api.ResourceReference\",\"id\":1055,\"extend\":\"google.protobuf.FieldOptions\"},\"resourceDefinition\":{\"rule\":\"repeated\",\"type\":\"google.api.ResourceDescriptor\",\"id\":1053,\"extend\":\"google.protobuf.FileOptions\"},\"resource\":{\"type\":\"google.api.ResourceDescriptor\",\"id\":1053,\"extend\":\"google.protobuf.MessageOptions\"},\"ResourceDescriptor\":{\"fields\":{\"type\":{\"type\":\"string\",\"id\":1},\"pattern\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2},\"nameField\":{\"type\":\"string\",\"id\":3},\"history\":{\"type\":\"History\",\"id\":4},\"plural\":{\"type\":\"string\",\"id\":5},\"singular\":{\"type\":\"string\",\"id\":6},\"style\":{\"rule\":\"repeated\",\"type\":\"Style\",\"id\":10}},\"nested\":{\"History\":{\"values\":{\"HISTORY_UNSPECIFIED\":0,\"ORIGINALLY_SINGLE_PATTERN\":1,\"FUTURE_MULTI_PATTERN\":2}},\"Style\":{\"values\":{\"STYLE_UNSPECIFIED\":0,\"DECLARATIVE_FRIENDLY\":1}}}},\"ResourceReference\":{\"fields\":{\"type\":{\"type\":\"string\",\"id\":1},\"childType\":{\"type\":\"string\",\"id\":2}}}}},\"protobuf\":{\"options\":{\"go_package\":\"google.golang.org/protobuf/types/descriptorpb\",\"java_package\":\"com.google.protobuf\",\"java_outer_classname\":\"DescriptorProtos\",\"csharp_namespace\":\"Google.Protobuf.Reflection\",\"objc_class_prefix\":\"GPB\",\"cc_enable_arenas\":true,\"optimize_for\":\"SPEED\"},\"nested\":{\"FileDescriptorSet\":{\"fields\":{\"file\":{\"rule\":\"repeated\",\"type\":\"FileDescriptorProto\",\"id\":1}}},\"Edition\":{\"values\":{\"EDITION_UNKNOWN\":0,\"EDITION_PROTO2\":998,\"EDITION_PROTO3\":999,\"EDITION_2023\":1000,\"EDITION_2024\":1001,\"EDITION_1_TEST_ONLY\":1,\"EDITION_2_TEST_ONLY\":2,\"EDITION_99997_TEST_ONLY\":99997,\"EDITION_99998_TEST_ONLY\":99998,\"EDITION_99999_TEST_ONLY\":99999,\"EDITION_MAX\":2147483647}},\"FileDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"package\":{\"type\":\"string\",\"id\":2},\"dependency\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":3},\"publicDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":10,\"options\":{\"packed\":false}},\"weakDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":11,\"options\":{\"packed\":false}},\"messageType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":4},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":5},\"service\":{\"rule\":\"repeated\",\"type\":\"ServiceDescriptorProto\",\"id\":6},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":7},\"options\":{\"type\":\"FileOptions\",\"id\":8},\"sourceCodeInfo\":{\"type\":\"SourceCodeInfo\",\"id\":9},\"syntax\":{\"type\":\"string\",\"id\":12},\"edition\":{\"type\":\"Edition\",\"id\":14}}},\"DescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"field\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":2},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":6},\"nestedType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":3},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":4},\"extensionRange\":{\"rule\":\"repeated\",\"type\":\"ExtensionRange\",\"id\":5},\"oneofDecl\":{\"rule\":\"repeated\",\"type\":\"OneofDescriptorProto\",\"id\":8},\"options\":{\"type\":\"MessageOptions\",\"id\":7},\"reservedRange\":{\"rule\":\"repeated\",\"type\":\"ReservedRange\",\"id\":9},\"reservedName\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":10}},\"nested\":{\"ExtensionRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2},\"options\":{\"type\":\"ExtensionRangeOptions\",\"id\":3}}},\"ReservedRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}}}},\"ExtensionRangeOptions\":{\"fields\":{\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999},\"declaration\":{\"rule\":\"repeated\",\"type\":\"Declaration\",\"id\":2,\"options\":{\"retention\":\"RETENTION_SOURCE\"}},\"features\":{\"type\":\"FeatureSet\",\"id\":50},\"verification\":{\"type\":\"VerificationState\",\"id\":3,\"options\":{\"default\":\"UNVERIFIED\",\"retention\":\"RETENTION_SOURCE\"}}},\"extensions\":[[1000,536870911]],\"nested\":{\"Declaration\":{\"fields\":{\"number\":{\"type\":\"int32\",\"id\":1},\"fullName\":{\"type\":\"string\",\"id\":2},\"type\":{\"type\":\"string\",\"id\":3},\"reserved\":{\"type\":\"bool\",\"id\":5},\"repeated\":{\"type\":\"bool\",\"id\":6}},\"reserved\":[[4,4]]},\"VerificationState\":{\"values\":{\"DECLARATION\":0,\"UNVERIFIED\":1}}}},\"FieldDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":3},\"label\":{\"type\":\"Label\",\"id\":4},\"type\":{\"type\":\"Type\",\"id\":5},\"typeName\":{\"type\":\"string\",\"id\":6},\"extendee\":{\"type\":\"string\",\"id\":2},\"defaultValue\":{\"type\":\"string\",\"id\":7},\"oneofIndex\":{\"type\":\"int32\",\"id\":9},\"jsonName\":{\"type\":\"string\",\"id\":10},\"options\":{\"type\":\"FieldOptions\",\"id\":8},\"proto3Optional\":{\"type\":\"bool\",\"id\":17}},\"nested\":{\"Type\":{\"values\":{\"TYPE_DOUBLE\":1,\"TYPE_FLOAT\":2,\"TYPE_INT64\":3,\"TYPE_UINT64\":4,\"TYPE_INT32\":5,\"TYPE_FIXED64\":6,\"TYPE_FIXED32\":7,\"TYPE_BOOL\":8,\"TYPE_STRING\":9,\"TYPE_GROUP\":10,\"TYPE_MESSAGE\":11,\"TYPE_BYTES\":12,\"TYPE_UINT32\":13,\"TYPE_ENUM\":14,\"TYPE_SFIXED32\":15,\"TYPE_SFIXED64\":16,\"TYPE_SINT32\":17,\"TYPE_SINT64\":18}},\"Label\":{\"values\":{\"LABEL_OPTIONAL\":1,\"LABEL_REPEATED\":3,\"LABEL_REQUIRED\":2}}}},\"OneofDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"options\":{\"type\":\"OneofOptions\",\"id\":2}}},\"EnumDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"value\":{\"rule\":\"repeated\",\"type\":\"EnumValueDescriptorProto\",\"id\":2},\"options\":{\"type\":\"EnumOptions\",\"id\":3},\"reservedRange\":{\"rule\":\"repeated\",\"type\":\"EnumReservedRange\",\"id\":4},\"reservedName\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":5}},\"nested\":{\"EnumReservedRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}}}},\"EnumValueDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":2},\"options\":{\"type\":\"EnumValueOptions\",\"id\":3}}},\"ServiceDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"method\":{\"rule\":\"repeated\",\"type\":\"MethodDescriptorProto\",\"id\":2},\"options\":{\"type\":\"ServiceOptions\",\"id\":3}}},\"MethodDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"inputType\":{\"type\":\"string\",\"id\":2},\"outputType\":{\"type\":\"string\",\"id\":3},\"options\":{\"type\":\"MethodOptions\",\"id\":4},\"clientStreaming\":{\"type\":\"bool\",\"id\":5,\"options\":{\"default\":false}},\"serverStreaming\":{\"type\":\"bool\",\"id\":6,\"options\":{\"default\":false}}}},\"FileOptions\":{\"fields\":{\"javaPackage\":{\"type\":\"string\",\"id\":1},\"javaOuterClassname\":{\"type\":\"string\",\"id\":8},\"javaMultipleFiles\":{\"type\":\"bool\",\"id\":10,\"options\":{\"default\":false}},\"javaGenerateEqualsAndHash\":{\"type\":\"bool\",\"id\":20,\"options\":{\"deprecated\":true}},\"javaStringCheckUtf8\":{\"type\":\"bool\",\"id\":27,\"options\":{\"default\":false}},\"optimizeFor\":{\"type\":\"OptimizeMode\",\"id\":9,\"options\":{\"default\":\"SPEED\"}},\"goPackage\":{\"type\":\"string\",\"id\":11},\"ccGenericServices\":{\"type\":\"bool\",\"id\":16,\"options\":{\"default\":false}},\"javaGenericServices\":{\"type\":\"bool\",\"id\":17,\"options\":{\"default\":false}},\"pyGenericServices\":{\"type\":\"bool\",\"id\":18,\"options\":{\"default\":false}},\"deprecated\":{\"type\":\"bool\",\"id\":23,\"options\":{\"default\":false}},\"ccEnableArenas\":{\"type\":\"bool\",\"id\":31,\"options\":{\"default\":true}},\"objcClassPrefix\":{\"type\":\"string\",\"id\":36},\"csharpNamespace\":{\"type\":\"string\",\"id\":37},\"swiftPrefix\":{\"type\":\"string\",\"id\":39},\"phpClassPrefix\":{\"type\":\"string\",\"id\":40},\"phpNamespace\":{\"type\":\"string\",\"id\":41},\"phpMetadataNamespace\":{\"type\":\"string\",\"id\":44},\"rubyPackage\":{\"type\":\"string\",\"id\":45},\"features\":{\"type\":\"FeatureSet\",\"id\":50},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[42,42],[38,38]],\"nested\":{\"OptimizeMode\":{\"values\":{\"SPEED\":1,\"CODE_SIZE\":2,\"LITE_RUNTIME\":3}}}},\"MessageOptions\":{\"fields\":{\"messageSetWireFormat\":{\"type\":\"bool\",\"id\":1,\"options\":{\"default\":false}},\"noStandardDescriptorAccessor\":{\"type\":\"bool\",\"id\":2,\"options\":{\"default\":false}},\"deprecated\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"mapEntry\":{\"type\":\"bool\",\"id\":7},\"deprecatedLegacyJsonFieldConflicts\":{\"type\":\"bool\",\"id\":11,\"options\":{\"deprecated\":true}},\"features\":{\"type\":\"FeatureSet\",\"id\":12},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[4,4],[5,5],[6,6],[8,8],[9,9]]},\"FieldOptions\":{\"fields\":{\"ctype\":{\"type\":\"CType\",\"id\":1,\"options\":{\"default\":\"STRING\"}},\"packed\":{\"type\":\"bool\",\"id\":2},\"jstype\":{\"type\":\"JSType\",\"id\":6,\"options\":{\"default\":\"JS_NORMAL\"}},\"lazy\":{\"type\":\"bool\",\"id\":5,\"options\":{\"default\":false}},\"unverifiedLazy\":{\"type\":\"bool\",\"id\":15,\"options\":{\"default\":false}},\"deprecated\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"weak\":{\"type\":\"bool\",\"id\":10,\"options\":{\"default\":false}},\"debugRedact\":{\"type\":\"bool\",\"id\":16,\"options\":{\"default\":false}},\"retention\":{\"type\":\"OptionRetention\",\"id\":17},\"targets\":{\"rule\":\"repeated\",\"type\":\"OptionTargetType\",\"id\":19,\"options\":{\"packed\":false}},\"editionDefaults\":{\"rule\":\"repeated\",\"type\":\"EditionDefault\",\"id\":20},\"features\":{\"type\":\"FeatureSet\",\"id\":21},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[4,4],[18,18]],\"nested\":{\"CType\":{\"values\":{\"STRING\":0,\"CORD\":1,\"STRING_PIECE\":2}},\"JSType\":{\"values\":{\"JS_NORMAL\":0,\"JS_STRING\":1,\"JS_NUMBER\":2}},\"OptionRetention\":{\"values\":{\"RETENTION_UNKNOWN\":0,\"RETENTION_RUNTIME\":1,\"RETENTION_SOURCE\":2}},\"OptionTargetType\":{\"values\":{\"TARGET_TYPE_UNKNOWN\":0,\"TARGET_TYPE_FILE\":1,\"TARGET_TYPE_EXTENSION_RANGE\":2,\"TARGET_TYPE_MESSAGE\":3,\"TARGET_TYPE_FIELD\":4,\"TARGET_TYPE_ONEOF\":5,\"TARGET_TYPE_ENUM\":6,\"TARGET_TYPE_ENUM_ENTRY\":7,\"TARGET_TYPE_SERVICE\":8,\"TARGET_TYPE_METHOD\":9}},\"EditionDefault\":{\"fields\":{\"edition\":{\"type\":\"Edition\",\"id\":3},\"value\":{\"type\":\"string\",\"id\":2}}}}},\"OneofOptions\":{\"fields\":{\"features\":{\"type\":\"FeatureSet\",\"id\":1},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"EnumOptions\":{\"fields\":{\"allowAlias\":{\"type\":\"bool\",\"id\":2},\"deprecated\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"deprecatedLegacyJsonFieldConflicts\":{\"type\":\"bool\",\"id\":6,\"options\":{\"deprecated\":true}},\"features\":{\"type\":\"FeatureSet\",\"id\":7},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[5,5]]},\"EnumValueOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":1,\"options\":{\"default\":false}},\"features\":{\"type\":\"FeatureSet\",\"id\":2},\"debugRedact\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"ServiceOptions\":{\"fields\":{\"features\":{\"type\":\"FeatureSet\",\"id\":34},\"deprecated\":{\"type\":\"bool\",\"id\":33,\"options\":{\"default\":false}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"MethodOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33,\"options\":{\"default\":false}},\"idempotencyLevel\":{\"type\":\"IdempotencyLevel\",\"id\":34,\"options\":{\"default\":\"IDEMPOTENCY_UNKNOWN\"}},\"features\":{\"type\":\"FeatureSet\",\"id\":35},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"nested\":{\"IdempotencyLevel\":{\"values\":{\"IDEMPOTENCY_UNKNOWN\":0,\"NO_SIDE_EFFECTS\":1,\"IDEMPOTENT\":2}}}},\"UninterpretedOption\":{\"fields\":{\"name\":{\"rule\":\"repeated\",\"type\":\"NamePart\",\"id\":2},\"identifierValue\":{\"type\":\"string\",\"id\":3},\"positiveIntValue\":{\"type\":\"uint64\",\"id\":4},\"negativeIntValue\":{\"type\":\"int64\",\"id\":5},\"doubleValue\":{\"type\":\"double\",\"id\":6},\"stringValue\":{\"type\":\"bytes\",\"id\":7},\"aggregateValue\":{\"type\":\"string\",\"id\":8}},\"nested\":{\"NamePart\":{\"fields\":{\"namePart\":{\"rule\":\"required\",\"type\":\"string\",\"id\":1},\"isExtension\":{\"rule\":\"required\",\"type\":\"bool\",\"id\":2}}}}},\"FeatureSet\":{\"fields\":{\"fieldPresence\":{\"type\":\"FieldPresence\",\"id\":1,\"options\":{\"retention\":\"RETENTION_RUNTIME\",\"targets\":\"TARGET_TYPE_FILE\",\"edition_defaults.edition\":\"EDITION_2023\",\"edition_defaults.value\":\"EXPLICIT\"}},\"enumType\":{\"type\":\"EnumType\",\"id\":2,\"options\":{\"retention\":\"RETENTION_RUNTIME\",\"targets\":\"TARGET_TYPE_FILE\",\"edition_defaults.edition\":\"EDITION_PROTO3\",\"edition_defaults.value\":\"OPEN\"}},\"repeatedFieldEncoding\":{\"type\":\"RepeatedFieldEncoding\",\"id\":3,\"options\":{\"retention\":\"RETENTION_RUNTIME\",\"targets\":\"TARGET_TYPE_FILE\",\"edition_defaults.edition\":\"EDITION_PROTO3\",\"edition_defaults.value\":\"PACKED\"}},\"utf8Validation\":{\"type\":\"Utf8Validation\",\"id\":4,\"options\":{\"retention\":\"RETENTION_RUNTIME\",\"targets\":\"TARGET_TYPE_FILE\",\"edition_defaults.edition\":\"EDITION_PROTO3\",\"edition_defaults.value\":\"VERIFY\"}},\"messageEncoding\":{\"type\":\"MessageEncoding\",\"id\":5,\"options\":{\"retention\":\"RETENTION_RUNTIME\",\"targets\":\"TARGET_TYPE_FILE\",\"edition_defaults.edition\":\"EDITION_PROTO2\",\"edition_defaults.value\":\"LENGTH_PREFIXED\"}},\"jsonFormat\":{\"type\":\"JsonFormat\",\"id\":6,\"options\":{\"retention\":\"RETENTION_RUNTIME\",\"targets\":\"TARGET_TYPE_FILE\",\"edition_defaults.edition\":\"EDITION_PROTO3\",\"edition_defaults.value\":\"ALLOW\"}}},\"extensions\":[[1000,1000],[1001,1001],[1002,1002],[9990,9990],[9995,9999],[10000,10000]],\"reserved\":[[999,999]],\"nested\":{\"FieldPresence\":{\"values\":{\"FIELD_PRESENCE_UNKNOWN\":0,\"EXPLICIT\":1,\"IMPLICIT\":2,\"LEGACY_REQUIRED\":3}},\"EnumType\":{\"values\":{\"ENUM_TYPE_UNKNOWN\":0,\"OPEN\":1,\"CLOSED\":2}},\"RepeatedFieldEncoding\":{\"values\":{\"REPEATED_FIELD_ENCODING_UNKNOWN\":0,\"PACKED\":1,\"EXPANDED\":2}},\"Utf8Validation\":{\"values\":{\"UTF8_VALIDATION_UNKNOWN\":0,\"VERIFY\":2,\"NONE\":3}},\"MessageEncoding\":{\"values\":{\"MESSAGE_ENCODING_UNKNOWN\":0,\"LENGTH_PREFIXED\":1,\"DELIMITED\":2}},\"JsonFormat\":{\"values\":{\"JSON_FORMAT_UNKNOWN\":0,\"ALLOW\":1,\"LEGACY_BEST_EFFORT\":2}}}},\"FeatureSetDefaults\":{\"fields\":{\"defaults\":{\"rule\":\"repeated\",\"type\":\"FeatureSetEditionDefault\",\"id\":1},\"minimumEdition\":{\"type\":\"Edition\",\"id\":4},\"maximumEdition\":{\"type\":\"Edition\",\"id\":5}},\"nested\":{\"FeatureSetEditionDefault\":{\"fields\":{\"edition\":{\"type\":\"Edition\",\"id\":3},\"features\":{\"type\":\"FeatureSet\",\"id\":2}}}}},\"SourceCodeInfo\":{\"fields\":{\"location\":{\"rule\":\"repeated\",\"type\":\"Location\",\"id\":1}},\"nested\":{\"Location\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"span\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"leadingComments\":{\"type\":\"string\",\"id\":3},\"trailingComments\":{\"type\":\"string\",\"id\":4},\"leadingDetachedComments\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6}}}}},\"GeneratedCodeInfo\":{\"fields\":{\"annotation\":{\"rule\":\"repeated\",\"type\":\"Annotation\",\"id\":1}},\"nested\":{\"Annotation\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"sourceFile\":{\"type\":\"string\",\"id\":2},\"begin\":{\"type\":\"int32\",\"id\":3},\"end\":{\"type\":\"int32\",\"id\":4},\"semantic\":{\"type\":\"Semantic\",\"id\":5}},\"nested\":{\"Semantic\":{\"values\":{\"NONE\":0,\"SET\":1,\"ALIAS\":2}}}}}},\"Duration\":{\"fields\":{\"seconds\":{\"type\":\"int64\",\"id\":1},\"nanos\":{\"type\":\"int32\",\"id\":2}}},\"Timestamp\":{\"fields\":{\"seconds\":{\"type\":\"int64\",\"id\":1},\"nanos\":{\"type\":\"int32\",\"id\":2}}},\"DoubleValue\":{\"fields\":{\"value\":{\"type\":\"double\",\"id\":1}}},\"FloatValue\":{\"fields\":{\"value\":{\"type\":\"float\",\"id\":1}}},\"Int64Value\":{\"fields\":{\"value\":{\"type\":\"int64\",\"id\":1}}},\"UInt64Value\":{\"fields\":{\"value\":{\"type\":\"uint64\",\"id\":1}}},\"Int32Value\":{\"fields\":{\"value\":{\"type\":\"int32\",\"id\":1}}},\"UInt32Value\":{\"fields\":{\"value\":{\"type\":\"uint32\",\"id\":1}}},\"BoolValue\":{\"fields\":{\"value\":{\"type\":\"bool\",\"id\":1}}},\"StringValue\":{\"fields\":{\"value\":{\"type\":\"string\",\"id\":1}}},\"BytesValue\":{\"fields\":{\"value\":{\"type\":\"bytes\",\"id\":1}}},\"Any\":{\"fields\":{\"type_url\":{\"type\":\"string\",\"id\":1},\"value\":{\"type\":\"bytes\",\"id\":2}}},\"Empty\":{\"fields\":{}}}},\"rpc\":{\"options\":{\"cc_enable_arenas\":true,\"go_package\":\"google.golang.org/genproto/googleapis/rpc/status;status\",\"java_multiple_files\":true,\"java_outer_classname\":\"StatusProto\",\"java_package\":\"com.google.rpc\",\"objc_class_prefix\":\"RPC\"},\"nested\":{\"Status\":{\"fields\":{\"code\":{\"type\":\"int32\",\"id\":1},\"message\":{\"type\":\"string\",\"id\":2},\"details\":{\"rule\":\"repeated\",\"type\":\"google.protobuf.Any\",\"id\":3}}}}}}}}}"));}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/trace.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TraceExporter = void 0;
const core_1 = __turbopack_context__.r("[project]/node_modules/@opentelemetry/core/build/esm/index.js [app-rsc] (ecmascript)");
const api_1 = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
const protoloader = __turbopack_context__.r("[project]/node_modules/@grpc/proto-loader/build/src/index.js [app-rsc] (ecmascript)");
const grpc = __turbopack_context__.r("[project]/node_modules/@grpc/grpc-js/build/src/index.js [app-rsc] (ecmascript)");
const google_auth_library_1 = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-rsc] (ecmascript)");
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const transform_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/transform.js [app-rsc] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/version.js [app-rsc] (ecmascript)");
const protoJson = __turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/protos/protos.json (json)");
const OT_REQUEST_HEADER = 'x-opentelemetry-outgoing-request';
const TRACE_USER_AGENT = `opentelemetry-js ${core_1.VERSION}; google-cloud-trace-exporter ${version_1.VERSION}`;
const OPTIONS = {
    'grpc.primary_user_agent': TRACE_USER_AGENT
};
/**
 * Format and sends span information to Google Cloud Trace.
 */ class TraceExporter {
    constructor(options = {}){
        var _a;
        this._traceServiceClient = undefined;
        this._resourceFilter = undefined;
        this._apiEndpoint = 'cloudtrace.googleapis.com:443';
        this._resourceFilter = options.resourceFilter;
        this._stringifyArrayAttributes = (_a = options.stringifyArrayAttributes) !== null && _a !== void 0 ? _a : false;
        this._auth = new google_auth_library_1.GoogleAuth({
            credentials: options.credentials,
            keyFile: options.keyFile,
            keyFilename: options.keyFilename,
            projectId: options.projectId,
            scopes: [
                'https://www.googleapis.com/auth/cloud-platform'
            ]
        });
        // Start this async process as early as possible. It will be
        // awaited on the first export because constructors are synchronous
        this._projectId = this._auth.getProjectId().catch((err)=>{
            api_1.diag.error(err);
        });
        if (options.apiEndpoint) {
            this._apiEndpoint = options.apiEndpoint;
        }
    }
    /**
     * Publishes a list of spans to Google Cloud Trace.
     * @param spans The list of spans to transmit to Google Cloud Trace
     */ async export(spans, resultCallback) {
        if (this._projectId instanceof Promise) {
            this._projectId = await this._projectId;
        }
        if (!this._projectId) {
            return resultCallback({
                code: core_1.ExportResultCode.FAILED,
                error: new Error('Was not able to determine GCP project ID')
            });
        }
        api_1.diag.debug('Google Cloud Trace export');
        const namedSpans = {
            name: `projects/${this._projectId}`,
            spans: spans.map((0, transform_1.getReadableSpanTransformer)(this._projectId, this._resourceFilter, this._stringifyArrayAttributes))
        };
        const result = await this._batchWriteSpans(namedSpans);
        resultCallback(result);
    }
    async shutdown() {}
    /**
     * Sends new spans to new or existing traces in the Google Cloud Trace format to the
     * service.
     * @param spans
     */ async _batchWriteSpans(spans) {
        api_1.diag.debug('Google Cloud Trace batch writing traces');
        try {
            this._traceServiceClient = await this._getClient();
        } catch (e) {
            const error = asError(e);
            error.message = `failed to create client: ${error.message}`;
            api_1.diag.error(error.message);
            return {
                code: core_1.ExportResultCode.FAILED,
                error
            };
        }
        const metadata = new grpc.Metadata();
        metadata.add(OT_REQUEST_HEADER, '1');
        metadata.add('user-agent', TRACE_USER_AGENT);
        const batchWriteSpans = (0, util_1.promisify)(this._traceServiceClient.BatchWriteSpans).bind(this._traceServiceClient);
        try {
            await batchWriteSpans(spans, metadata);
            api_1.diag.debug('batchWriteSpans successfully');
            return {
                code: core_1.ExportResultCode.SUCCESS
            };
        } catch (e) {
            const error = asError(e);
            error.message = `batchWriteSpans error: ${error.message}`;
            api_1.diag.error(error.message);
            return {
                code: core_1.ExportResultCode.FAILED,
                error
            };
        }
    }
    /**
     * If the rpc client is not already initialized,
     * authenticates with google credentials and initializes the rpc client
     */ async _getClient() {
        if (this._traceServiceClient) {
            return this._traceServiceClient;
        }
        api_1.diag.debug('Google Cloud Trace authenticating');
        const creds = await this._auth.getClient();
        api_1.diag.debug('Google Cloud Trace got authentication. Initializaing rpc client');
        const packageDefinition = protoloader.fromJSON(protoJson);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { google } = grpc.loadPackageDefinition(packageDefinition);
        const traceService = google.devtools.cloudtrace.v2.TraceService;
        const sslCreds = grpc.credentials.createSsl();
        const callCreds = grpc.credentials.createFromGoogleCredential(creds);
        return new traceService(this._apiEndpoint, grpc.credentials.combineChannelCredentials(sslCreds, callCreds), OPTIONS);
    }
}
exports.TraceExporter = TraceExporter;
function asError(error) {
    if (error instanceof Error) {
        return error;
    }
    return new Error(String(error));
} //# sourceMappingURL=trace.js.map
}}),
"[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/external-types.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@google-cloud/opentelemetry-cloud-trace-exporter/build/src/trace.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_%40google-cloud_24a6dd28._.js.map