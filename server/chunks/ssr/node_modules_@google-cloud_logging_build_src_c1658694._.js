module.exports = {

"[project]/node_modules/@google-cloud/logging/build/src/utils/context.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.W3C_TRACE_PARENT_HEADER = exports.X_CLOUD_TRACE_HEADER = void 0;
exports.makeHeaderWrapper = makeHeaderWrapper;
exports.getOrInjectContext = getOrInjectContext;
exports.getContextFromOtelContext = getContextFromOtelContext;
exports.getContextFromXCloudTrace = getContextFromXCloudTrace;
exports.getContextFromTraceParent = getContextFromTraceParent;
exports.parseXCloudTraceHeader = parseXCloudTraceHeader;
exports.parseTraceParentHeader = parseTraceParentHeader;
const uuid = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/node_modules/uuid/dist/esm-node/index.js [app-rsc] (ecmascript)");
const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const api_1 = __turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
/** Header that carries span context across Google infrastructure. */ exports.X_CLOUD_TRACE_HEADER = 'x-cloud-trace-context';
const SPAN_ID_RANDOM_BYTES = 8;
const spanIdBuffer = Buffer.alloc(SPAN_ID_RANDOM_BYTES);
const randomFillSync = crypto.randomFillSync;
const randomBytes = crypto.randomBytes;
const spanRandomBuffer = randomFillSync ? ()=>randomFillSync(spanIdBuffer) : ()=>randomBytes(SPAN_ID_RANDOM_BYTES);
/** Header that carries span context across W3C compliant infrastructure. */ exports.W3C_TRACE_PARENT_HEADER = 'traceparent';
/**
 * makeHeaderWrapper returns a wrapper with set and get header functionality,
 * returning null if the incoming request object doesn't contain the 'header'
 * propery.
 * @param req
 */ function makeHeaderWrapper(req) {
    if (!req.headers) return null;
    const wrapper = {
        setHeader (name, value) {
            req.headers[name] = value;
        },
        getHeader (name) {
            return req.headers[name];
        }
    };
    return wrapper;
}
/**
 * getOrInjectContext returns a CloudTraceContext with as many available trace
 * and span properties as possible. It examines HTTP headers for trace context.
 * Optionally, it can inject a Google compliant trace context when no context is
 * available from headers.
 *
 * @param req
 * @param projectId
 * @param inject
 */ function getOrInjectContext(req, projectId, inject) {
    const defaultContext = toCloudTraceContext({}, projectId);
    // Get trace context from OpenTelemetry span context.
    const otelContext = getContextFromOtelContext(projectId);
    if (otelContext) return otelContext;
    const wrapper = makeHeaderWrapper(req);
    if (wrapper) {
        // Detect 'traceparent' header.
        const traceContext = getContextFromTraceParent(wrapper, projectId);
        if (traceContext) return traceContext;
        // Detect 'X-Cloud-Trace-Context' header.
        const cloudContext = getContextFromXCloudTrace(wrapper, projectId);
        if (cloudContext) return cloudContext;
        // Optional: Generate and inject a context for the user as last resort.
        if (inject) {
            wrapper.setHeader(exports.X_CLOUD_TRACE_HEADER, makeCloudTraceHeader());
            return getContextFromXCloudTrace(wrapper, projectId);
        }
    }
    return defaultContext;
}
/**
 * toCloudTraceContext converts any context format to cloudTraceContext format.
 * @param context
 * @param projectId
 */ function toCloudTraceContext(// eslint-disable-next-line @typescript-eslint/no-explicit-any
anyContext, projectId) {
    const context = {
        trace: ''
    };
    if (anyContext === null || anyContext === void 0 ? void 0 : anyContext.trace) {
        context.trace = `projects/${projectId}/traces/${anyContext.trace}`;
    }
    if (anyContext === null || anyContext === void 0 ? void 0 : anyContext.spanId) {
        context.spanId = anyContext.spanId;
    }
    if ('traceSampled' in anyContext) {
        context.traceSampled = anyContext.traceSampled;
    }
    return context;
}
/**
 * makeCloudTraceHeader generates valid X-Cloud-Trace-Context trace and spanId.
 */ function makeCloudTraceHeader() {
    const trace = uuid.v4().replace(/-/g, '');
    const spanId = spanRandomBuffer().toString('hex');
    return `${trace}/${spanId}`;
}
/**
 * getContextFromOtelContext looks for the active open telemetry span context
 * per Open Telemetry specifications for tracing contexts.
 *
 * @param projectId
 */ function getContextFromOtelContext(projectId) {
    var _a;
    const spanContext = (_a = api_1.trace.getActiveSpan()) === null || _a === void 0 ? void 0 : _a.spanContext();
    const FLAG_SAMPLED = 1; // 00000001
    if (spanContext !== undefined && (0, api_1.isSpanContextValid)(spanContext)) {
        const otelSpanContext = {
            trace: spanContext === null || spanContext === void 0 ? void 0 : spanContext.traceId,
            spanId: spanContext === null || spanContext === void 0 ? void 0 : spanContext.spanId,
            traceSampled: (spanContext.traceFlags & FLAG_SAMPLED) !== 0
        };
        return toCloudTraceContext(otelSpanContext, projectId);
    }
    return null;
}
/**
 * getContextFromXCloudTrace looks for the HTTP header 'x-cloud-trace-context'
 * per Google Cloud specifications for Cloud Tracing.
 *
 * @param headerWrapper
 * @param projectId
 */ function getContextFromXCloudTrace(headerWrapper, projectId) {
    const context = parseXCloudTraceHeader(headerWrapper);
    if (!context) return null;
    return toCloudTraceContext(context, projectId);
}
/**
 * getOrInjectTraceParent looks for the HTTP header 'traceparent'
 * per W3C specifications for OpenTelemetry and OpenCensus
 * Read more about W3C protocol: https://www.w3.org/TR/trace-context/
 *
 * @param headerWrapper
 * @param projectId
 */ function getContextFromTraceParent(headerWrapper, projectId) {
    const context = parseTraceParentHeader(headerWrapper);
    if (!context) return null;
    return toCloudTraceContext(context, projectId);
}
/**
 * parseXCloudTraceHeader looks for trace context in `X-Cloud-Trace-Context`
 * header
 * @param headerWrapper
 */ function parseXCloudTraceHeader(headerWrapper) {
    var _a;
    const regex = /([a-f\d]+)?(\/?([a-f\d]+))?(;?o=(\d))?/;
    const match = (_a = headerWrapper.getHeader(exports.X_CLOUD_TRACE_HEADER)) === null || _a === void 0 ? void 0 : _a.toString().match(regex);
    if (!match) return null;
    return {
        trace: match[1],
        spanId: match[3],
        traceSampled: match[5] === '1'
    };
}
/**
 * parseTraceParentHeader is a custom implementation of the `parseTraceParent`
 * function in @opentelemetry-core/trace.
 * For more information see {@link https://www.w3.org/TR/trace-context/}
 * @param headerWrapper
 */ function parseTraceParentHeader(headerWrapper) {
    var _a;
    const VERSION_PART = '(?!ff)[\\da-f]{2}';
    const TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
    const PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
    const FLAGS_PART = '[\\da-f]{2}';
    const TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    const match = (_a = headerWrapper.getHeader(exports.W3C_TRACE_PARENT_HEADER)) === null || _a === void 0 ? void 0 : _a.toString().match(TRACE_PARENT_REGEX);
    if (!match) return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5]) return null;
    return {
        trace: match[2],
        spanId: match[3],
        traceSampled: (parseInt(match[4], 16) & 1) === 1
    };
} //# sourceMappingURL=context.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/utils/http-request.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeHttpRequestData = makeHttpRequestData;
exports.isRawHttpRequest = isRawHttpRequest;
/**
 * makeHttpRequestData turns raw incoming HTTPRequests into structured
 * HTTPRequest objects interpreted by Cloud Logging.
 *
 * @param req
 * @param res
 * @param latencyMilliseconds
 */ function makeHttpRequestData(req, res, latencyMilliseconds) {
    let requestUrl, protocol, requestMethod, userAgent, referer, status, responseSize, latency;
    // Format request properties
    if (req.url) requestUrl = req.url;
    // OriginalURL overwrites inferred url
    if ('originalUrl' in req && req.originalUrl) requestUrl = req.originalUrl;
    // Format protocol from valid URL
    if (requestUrl) {
        try {
            const url = new URL(requestUrl);
            protocol = url.protocol;
        } catch (e) {
        // Library should not panic
        }
    }
    req.method ? requestMethod = req.method : null;
    if (req.headers && req.headers['user-agent']) {
        req.headers['user-agent'] ? userAgent = req.headers['user-agent'] : null;
        req.headers['referer'] ? referer = req.headers['referer'] : null;
    }
    // Format response properties
    if (res) {
        res.statusCode ? status = res.statusCode : null;
        responseSize = res.getHeader && Number(res.getHeader('Content-Length')) || 0;
    }
    // Format latency
    if (latencyMilliseconds) {
        latency = {
            seconds: Math.floor(latencyMilliseconds / 1e3),
            nanos: Math.floor(latencyMilliseconds % 1e3 * 1e6)
        };
    }
    // Only include the property if its value exists
    return Object.assign({}, requestUrl ? {
        requestUrl
    } : null, protocol ? {
        protocol
    } : null, requestMethod ? {
        requestMethod
    } : null, userAgent ? {
        userAgent
    } : null, referer ? {
        referer
    } : null, responseSize ? {
        responseSize
    } : null, status ? {
        status
    } : null, latency ? {
        latency
    } : null);
}
/**
 * isRawHttpRequest detects whether a request object extends the
 * http.IncomingMessage class. It should return true on HTTP compliant requests
 * and all requests created by an http.Server.
 *
 * @param req
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
function isRawHttpRequest(req) {
    if (req && ('originalUrl' in req || 'headers' in req || 'method' in req || 'url' in req)) {
        return true;
    }
    return false;
} //# sourceMappingURL=http-request.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/middleware/express/make-middleware.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeMiddleware = makeMiddleware;
const onFinished = __turbopack_context__.r("[project]/node_modules/on-finished/index.js [app-rsc] (ecmascript)");
const context_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/context.js [app-rsc] (ecmascript)");
const http_request_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/http-request.js [app-rsc] (ecmascript)");
/**
 * Generates an express middleware that installs a request-specific logger on
 * the `request` object. It optionally can do HttpRequest timing that can be
 * used for generating request logs. This can be used to integrate with logging
 * libraries such as winston and bunyan.
 *
 * @param projectId Generated traceIds will be associated with this project.
 * @param makeChildLogger A function that generates logger instances that will
 * be installed onto `req` as `req.log`. The logger should include the trace in
 * each log entry's metadata (associated with the LOGGING_TRACE_KEY property.
 * @param emitRequestLog Optional. A function that will emit a parent request
 * log. While some environments like GAE and GCF emit parent request logs
 * automatically, other environments do not. When provided this function will be
 * called with a populated `CloudLoggingHttpRequest` which can be emitted as
 * request log.
 */ function makeMiddleware(projectId, makeChildLogger, emitRequestLog) {
    return (req, res, next)=>{
        // TODO(ofrobots): use high-resolution timer.
        const requestStartMs = Date.now();
        // Detect & establish context if we were the first actor to detect lack of
        // context so traceContext is always available when using middleware.
        const traceContext = (0, context_1.getOrInjectContext)(req, projectId, true);
        // Install a child logger on the request object, with detected trace and
        // span.
        req.log = makeChildLogger(traceContext.trace, traceContext.spanId, traceContext.traceSampled);
        // Emit a 'Request Log' on the parent logger, with detected trace and
        // span.
        if (emitRequestLog) {
            onFinished(res, ()=>{
                const latencyMs = Date.now() - requestStartMs;
                const httpRequest = (0, http_request_1.makeHttpRequestData)(req, res, latencyMs);
                emitRequestLog(httpRequest, traceContext.trace, traceContext.spanId, traceContext.traceSampled);
            });
        }
        next();
    };
} //# sourceMappingURL=make-middleware.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/middleware/express/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/middleware/express/make-middleware.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/middleware/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.express = void 0;
const express = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/middleware/express/index.js [app-rsc] (ecmascript)");
exports.express = express; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/utils/metadata.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KUBERNETES_NAMESPACE_ID_PATH = void 0;
exports.getCloudFunctionDescriptor = getCloudFunctionDescriptor;
exports.getCloudRunDescriptor = getCloudRunDescriptor;
exports.getGAEDescriptor = getGAEDescriptor;
exports.getGCEDescriptor = getGCEDescriptor;
exports.getGKEDescriptor = getGKEDescriptor;
exports.getGlobalDescriptor = getGlobalDescriptor;
exports.getDefaultResource = getDefaultResource;
exports.detectServiceContext = detectServiceContext;
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const gcpMetadata = __turbopack_context__.r("[project]/node_modules/gcp-metadata/build/src/index.js [app-rsc] (ecmascript)");
const google_auth_library_1 = __turbopack_context__.r("[project]/node_modules/google-auth-library/build/src/index.js [app-rsc] (ecmascript)");
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const readFile = (0, util_1.promisify)(fs.readFile);
function zoneFromQualifiedZone(qualified) {
    // Some parsing is necessary. Metadata service returns a fully
    // qualified zone name: 'projects/{projectId}/zones/{zone}'. Logging
    // wants just the zone part.
    //
    return qualified.split('/').pop();
}
function regionFromQualifiedZone(qualified) {
    // Parses the region from the zone. Used for GCF and GCR which dynamically
    // allocate zones.
    const zone = zoneFromQualifiedZone(qualified);
    const region = zone === undefined ? undefined : zone.slice(0, zone.lastIndexOf('-'));
    return region;
}
/**
 * Create a descriptor for Cloud Functions.
 *
 * @returns {object}
 */ async function getCloudFunctionDescriptor() {
    // If the region is already available via an environment variable, don't delay the function by pinging metaserver.
    let region = undefined;
    if (!(process.env.GOOGLE_CLOUD_REGION || process.env.FUNCTION_REGION)) {
        const qualifiedZone = await gcpMetadata.instance('zone');
        region = regionFromQualifiedZone(qualifiedZone);
    }
    /**
     * In GCF versions after Node 8, K_SERVICE is the preferred way to
     * get the function name. We still check for GOOGLE_CLOUD_REGION and FUNCTION_REGION for backwards Node runtime compatibility.
     */ return {
        type: 'cloud_function',
        labels: {
            function_name: process.env.K_SERVICE || process.env.FUNCTION_NAME,
            region: process.env.GOOGLE_CLOUD_REGION || process.env.FUNCTION_REGION || region
        }
    };
}
/**
 * Create a descriptor for Cloud Run.
 *
 * @returns {object}
 */ async function getCloudRunDescriptor() {
    const qualifiedZone = await gcpMetadata.instance('zone');
    const location = regionFromQualifiedZone(qualifiedZone);
    return {
        type: 'cloud_run_revision',
        labels: {
            location,
            service_name: process.env.K_SERVICE,
            revision_name: process.env.K_REVISION,
            configuration_name: process.env.K_CONFIGURATION
        }
    };
}
/**
 * Create a descriptor for Google App Engine.
 *
 * @returns {object}
 */ async function getGAEDescriptor() {
    const qualifiedZone = await gcpMetadata.instance('zone');
    const zone = zoneFromQualifiedZone(qualifiedZone);
    return {
        type: 'gae_app',
        labels: {
            module_id: process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME,
            version_id: process.env.GAE_VERSION,
            zone
        }
    };
}
/**
 * Create a descriptor for Google Compute Engine.
 * @return {object}
 */ async function getGCEDescriptor() {
    const idResponse = await gcpMetadata.instance('id');
    const zoneResponse = await gcpMetadata.instance('zone');
    // Some parsing is necessary. Metadata service returns a fully
    // qualified zone name: 'projects/{projectId}/zones/{zone}'. Logging
    // wants just the zone part.
    //
    const zone = zoneFromQualifiedZone(zoneResponse);
    return {
        type: 'gce_instance',
        labels: {
            // idResponse can be BigNumber when the id too large for JavaScript
            // numbers. Use a toString() to uniformly convert to a string.
            instance_id: idResponse.toString(),
            zone
        }
    };
}
exports.KUBERNETES_NAMESPACE_ID_PATH = '/var/run/secrets/kubernetes.io/serviceaccount/namespace';
/**
 * Create a descriptor for Google Container Engine.
 *
 * @return {object}
 */ async function getGKEDescriptor() {
    // Cloud Logging Monitored Resource for 'container' requires
    // cluster_name and namespace_id fields. Note that these *need* to be
    // snake_case. The namespace_id is not easily available from inside the
    // container, but we can get the namespace_name. Logging has been using the
    // namespace_name in place of namespace_id for a while now. Log correlation
    // with metrics may not necessarily work however.
    //
    const resp = await gcpMetadata.instance('attributes/cluster-name');
    const qualifiedZone = await gcpMetadata.instance('zone');
    const location = zoneFromQualifiedZone(qualifiedZone);
    let namespace = '';
    try {
        namespace = await readFile(exports.KUBERNETES_NAMESPACE_ID_PATH, 'utf8');
    } catch (err) {
    // Ignore errors (leave namespace as a nil string).
    }
    return {
        type: 'k8s_container',
        labels: {
            location,
            cluster_name: resp,
            namespace_name: namespace,
            pod_name: process.env.HOSTNAME,
            // Users must manually supply container name for now.
            // This may be autodetected in the future, pending b/145137070.
            container_name: process.env.CONTAINER_NAME
        }
    };
}
/**
 * Create a global descriptor.
 *
 * @returns {object}
 */ function getGlobalDescriptor() {
    return {
        type: 'global'
    };
}
/**
 * Attempt to contact the metadata service and determine,
 * based on request success and environment variables, what type of resource
 * the library is operating on.
 */ async function getDefaultResource(auth) {
    const env = await auth.getEnv();
    switch(env){
        case google_auth_library_1.GCPEnv.KUBERNETES_ENGINE:
            return getGKEDescriptor().catch(()=>getGlobalDescriptor());
        case google_auth_library_1.GCPEnv.APP_ENGINE:
            return getGAEDescriptor().catch(()=>getGlobalDescriptor());
        case google_auth_library_1.GCPEnv.CLOUD_FUNCTIONS:
            return getCloudFunctionDescriptor().catch(()=>getGlobalDescriptor());
        case google_auth_library_1.GCPEnv.CLOUD_RUN:
            return getCloudRunDescriptor().catch(()=>getGlobalDescriptor());
        case google_auth_library_1.GCPEnv.COMPUTE_ENGINE:
            return getGCEDescriptor().catch(()=>getGlobalDescriptor());
        default:
            return getGlobalDescriptor();
    }
}
/**
 * For logged errors, users can provide a service context. This enables errors
 * to be picked up Cloud Error Reporting. For more information see
 * [this guide]{@link
 * https://cloud.google.com/error-reporting/docs/formatting-error-messages} and
 * the [official documentation]{@link
 * https://cloud.google.com/error-reporting/reference/rest/v1beta1/ServiceContext}.
 */ async function detectServiceContext(auth) {
    const env = await auth.getEnv();
    switch(env){
        case google_auth_library_1.GCPEnv.APP_ENGINE:
            return {
                service: process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME,
                version: process.env.GAE_VERSION || process.env.GAE_MODULE_VERSION
            };
        case google_auth_library_1.GCPEnv.CLOUD_FUNCTIONS:
            return {
                service: process.env.FUNCTION_NAME
            };
        // On Kubernetes we use the pod-name to describe the service. Currently,
        // we acquire the pod-name from within the pod through env var `HOSTNAME`.
        case google_auth_library_1.GCPEnv.KUBERNETES_ENGINE:
            return {
                service: process.env.HOSTNAME
            };
        case google_auth_library_1.GCPEnv.CLOUD_RUN:
            return {
                service: process.env.K_SERVICE
            };
        case google_auth_library_1.GCPEnv.COMPUTE_ENGINE:
            return null;
        default:
            return null;
    }
} //# sourceMappingURL=metadata.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/config_service_v2_client_config.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"interfaces\":{\"google.logging.v2.ConfigServiceV2\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"INTERNAL\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"ListBuckets\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetBucket\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CreateBucketAsync\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateBucketAsync\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CreateBucket\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateBucket\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteBucket\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UndeleteBucket\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListViews\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetView\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CreateView\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateView\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteView\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListSinks\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetSink\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"CreateSink\":{\"timeout_millis\":120000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateSink\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"DeleteSink\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"CreateLink\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteLink\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListLinks\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetLink\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListExclusions\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetExclusion\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"CreateExclusion\":{\"timeout_millis\":120000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateExclusion\":{\"timeout_millis\":120000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteExclusion\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetCmekSettings\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateCmekSettings\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"GetSettings\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateSettings\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"CopyLogEntries\":{\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"}}}}}"));}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/config_service_v2_client.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConfigServiceV2Client = void 0;
const jsonProtos = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/protos/protos.json (json)");
/**
 * Client JSON configuration object, loaded from
 * `src/v2/config_service_v2_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */ const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/config_service_v2_client_config.json (json)");
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/package.json (json)").version;
/**
 *  Service for configuring sinks used to route log entries.
 * @class
 * @memberof v2
 */ class ConfigServiceV2Client {
    /**
     * Construct an instance of ConfigServiceV2Client.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new ConfigServiceV2Client({fallback: true}, gax);
     *     ```
     */ constructor(opts, gaxInstance){
        var _a, _b, _c, _d, _e;
        this._terminated = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {}
        };
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) && (opts === null || opts === void 0 ? void 0 : opts.universeDomain) && (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = typeof process === 'object' && typeof process.env === 'object' ? process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null && _b !== void 0 ? _b : universeDomainEnvVar) !== null && _c !== void 0 ? _c : 'googleapis.com';
        this._servicePath = 'logging.' + this._universeDomain;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _d !== void 0 ? _d : {};
        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _e !== void 0 ? _e : "undefined" !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function';
        opts = Object.assign({
            servicePath,
            port,
            clientConfig,
            fallback
        }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/index.js [app-rsc] (ecmascript)");
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`
        ];
        if (typeof process === 'object' && 'versions' in process) {
            clientHeader.push(`gl-node/${process.versions.node}`);
        } else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        } else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // This API contains "path templates"; forward-slash-separated
        // identifiers to uniquely identify resources within the API.
        // Create useful helper objects for these.
        this.pathTemplates = {
            billingAccountCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/cmekSettings'),
            billingAccountExclusionPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/exclusions/{exclusion}'),
            billingAccountLocationBucketPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}'),
            billingAccountLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/links/{link}'),
            billingAccountLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/views/{view}'),
            billingAccountLogPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/logs/{log}'),
            billingAccountSettingsPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/settings'),
            billingAccountSinkPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/sinks/{sink}'),
            folderCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/cmekSettings'),
            folderExclusionPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/exclusions/{exclusion}'),
            folderLocationBucketPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}'),
            folderLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}/links/{link}'),
            folderLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}/views/{view}'),
            folderLogPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/logs/{log}'),
            folderSettingsPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/settings'),
            folderSinkPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/sinks/{sink}'),
            locationPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}'),
            logMetricPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/metrics/{metric}'),
            organizationCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/cmekSettings'),
            organizationExclusionPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/exclusions/{exclusion}'),
            organizationLocationBucketPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}'),
            organizationLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}/links/{link}'),
            organizationLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}/views/{view}'),
            organizationLogPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/logs/{log}'),
            organizationSettingsPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/settings'),
            organizationSinkPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/sinks/{sink}'),
            projectPathTemplate: new this._gaxModule.PathTemplate('projects/{project}'),
            projectCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/cmekSettings'),
            projectExclusionPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/exclusions/{exclusion}'),
            projectLocationBucketPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}'),
            projectLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}/links/{link}'),
            projectLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}/views/{view}'),
            projectLogPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/logs/{log}'),
            projectSettingsPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/settings'),
            projectSinkPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/sinks/{sink}')
        };
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listBuckets: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'buckets'),
            listViews: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'views'),
            listSinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'sinks'),
            listLinks: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'links'),
            listExclusions: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'exclusions')
        };
        const protoFilesRoot = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
        // This API contains "long-running operations", which return a
        // an Operation object that allows for tracking of the operation,
        // rather than holding a request open.
        const lroOptions = {
            auth: this.auth,
            grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined
        };
        if (opts.fallback) {
            lroOptions.protoJson = protoFilesRoot;
            lroOptions.httpRules = [
                {
                    selector: 'google.longrunning.Operations.CancelOperation',
                    post: '/v2/{name=*/*/locations/*/operations/*}:cancel',
                    body: '*',
                    additional_bindings: [
                        {
                            post: '/v2/{name=projects/*/locations/*/operations/*}:cancel',
                            body: '*'
                        },
                        {
                            post: '/v2/{name=organizations/*/locations/*/operations/*}:cancel',
                            body: '*'
                        },
                        {
                            post: '/v2/{name=folders/*/locations/*/operations/*}:cancel',
                            body: '*'
                        },
                        {
                            post: '/v2/{name=billingAccounts/*/locations/*/operations/*}:cancel',
                            body: '*'
                        }
                    ]
                },
                {
                    selector: 'google.longrunning.Operations.GetOperation',
                    get: '/v2/{name=*/*/locations/*/operations/*}',
                    additional_bindings: [
                        {
                            get: '/v2/{name=projects/*/locations/*/operations/*}'
                        },
                        {
                            get: '/v2/{name=organizations/*/locations/*/operations/*}'
                        },
                        {
                            get: '/v2/{name=folders/*/locations/*/operations/*}'
                        },
                        {
                            get: '/v2/{name=billingAccounts/*/locations/*/operations/*}'
                        }
                    ]
                },
                {
                    selector: 'google.longrunning.Operations.ListOperations',
                    get: '/v2/{name=*/*/locations/*}/operations',
                    additional_bindings: [
                        {
                            get: '/v2/{name=projects/*/locations/*}/operations'
                        },
                        {
                            get: '/v2/{name=organizations/*/locations/*}/operations'
                        },
                        {
                            get: '/v2/{name=folders/*/locations/*}/operations'
                        },
                        {
                            get: '/v2/{name=billingAccounts/*/locations/*}/operations'
                        }
                    ]
                }
            ];
        }
        this.operationsClient = this._gaxModule.lro(lroOptions).operationsClient(opts);
        const createBucketAsyncResponse = protoFilesRoot.lookup('.google.logging.v2.LogBucket');
        const createBucketAsyncMetadata = protoFilesRoot.lookup('.google.logging.v2.BucketMetadata');
        const updateBucketAsyncResponse = protoFilesRoot.lookup('.google.logging.v2.LogBucket');
        const updateBucketAsyncMetadata = protoFilesRoot.lookup('.google.logging.v2.BucketMetadata');
        const createLinkResponse = protoFilesRoot.lookup('.google.logging.v2.Link');
        const createLinkMetadata = protoFilesRoot.lookup('.google.logging.v2.LinkMetadata');
        const deleteLinkResponse = protoFilesRoot.lookup('.google.protobuf.Empty');
        const deleteLinkMetadata = protoFilesRoot.lookup('.google.logging.v2.LinkMetadata');
        const copyLogEntriesResponse = protoFilesRoot.lookup('.google.logging.v2.CopyLogEntriesResponse');
        const copyLogEntriesMetadata = protoFilesRoot.lookup('.google.logging.v2.CopyLogEntriesMetadata');
        this.descriptors.longrunning = {
            createBucketAsync: new this._gaxModule.LongrunningDescriptor(this.operationsClient, createBucketAsyncResponse.decode.bind(createBucketAsyncResponse), createBucketAsyncMetadata.decode.bind(createBucketAsyncMetadata)),
            updateBucketAsync: new this._gaxModule.LongrunningDescriptor(this.operationsClient, updateBucketAsyncResponse.decode.bind(updateBucketAsyncResponse), updateBucketAsyncMetadata.decode.bind(updateBucketAsyncMetadata)),
            createLink: new this._gaxModule.LongrunningDescriptor(this.operationsClient, createLinkResponse.decode.bind(createLinkResponse), createLinkMetadata.decode.bind(createLinkMetadata)),
            deleteLink: new this._gaxModule.LongrunningDescriptor(this.operationsClient, deleteLinkResponse.decode.bind(deleteLinkResponse), deleteLinkMetadata.decode.bind(deleteLinkMetadata)),
            copyLogEntries: new this._gaxModule.LongrunningDescriptor(this.operationsClient, copyLogEntriesResponse.decode.bind(copyLogEntriesResponse), copyLogEntriesMetadata.decode.bind(copyLogEntriesMetadata))
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.logging.v2.ConfigServiceV2', gapicConfig, opts.clientConfig || {}, {
            'x-goog-api-client': clientHeader.join(' ')
        });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */ initialize() {
        // If the client stub promise is already initialized, return immediately.
        if (this.configServiceV2Stub) {
            return this.configServiceV2Stub;
        }
        // Put together the "service stub" for
        // google.logging.v2.ConfigServiceV2.
        this.configServiceV2Stub = this._gaxGrpc.createStub(this._opts.fallback ? this._protos.lookupService('google.logging.v2.ConfigServiceV2') : this._protos.google.logging.v2.ConfigServiceV2, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const configServiceV2StubMethods = [
            'listBuckets',
            'getBucket',
            'createBucketAsync',
            'updateBucketAsync',
            'createBucket',
            'updateBucket',
            'deleteBucket',
            'undeleteBucket',
            'listViews',
            'getView',
            'createView',
            'updateView',
            'deleteView',
            'listSinks',
            'getSink',
            'createSink',
            'updateSink',
            'deleteSink',
            'createLink',
            'deleteLink',
            'listLinks',
            'getLink',
            'listExclusions',
            'getExclusion',
            'createExclusion',
            'updateExclusion',
            'deleteExclusion',
            'getCmekSettings',
            'updateCmekSettings',
            'getSettings',
            'updateSettings',
            'copyLogEntries'
        ];
        for (const methodName of configServiceV2StubMethods){
            const callPromise = this.configServiceV2Stub.then((stub)=>(...args)=>{
                    if (this._terminated) {
                        return Promise.reject('The client has already been closed.');
                    }
                    const func = stub[methodName];
                    return func.apply(stub, args);
                }, (err)=>()=>{
                    throw err;
                });
            const descriptor = this.descriptors.page[methodName] || this.descriptors.longrunning[methodName] || undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.configServiceV2Stub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get servicePath() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'logging.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get apiEndpoint() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'logging.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */ get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */ static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */ static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/cloud-platform.read-only',
            'https://www.googleapis.com/auth/logging.admin',
            'https://www.googleapis.com/auth/logging.read'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */ getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    getBucket(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getBucket(request, options, callback);
    }
    createBucket(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createBucket(request, options, callback);
    }
    updateBucket(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateBucket(request, options, callback);
    }
    deleteBucket(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteBucket(request, options, callback);
    }
    undeleteBucket(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.undeleteBucket(request, options, callback);
    }
    getView(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getView(request, options, callback);
    }
    createView(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createView(request, options, callback);
    }
    updateView(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateView(request, options, callback);
    }
    deleteView(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteView(request, options, callback);
    }
    getSink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            sink_name: (_a = request.sinkName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getSink(request, options, callback);
    }
    createSink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createSink(request, options, callback);
    }
    updateSink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            sink_name: (_a = request.sinkName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateSink(request, options, callback);
    }
    deleteSink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            sink_name: (_a = request.sinkName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteSink(request, options, callback);
    }
    getLink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getLink(request, options, callback);
    }
    getExclusion(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getExclusion(request, options, callback);
    }
    createExclusion(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createExclusion(request, options, callback);
    }
    updateExclusion(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateExclusion(request, options, callback);
    }
    deleteExclusion(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteExclusion(request, options, callback);
    }
    getCmekSettings(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getCmekSettings(request, options, callback);
    }
    updateCmekSettings(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateCmekSettings(request, options, callback);
    }
    getSettings(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getSettings(request, options, callback);
    }
    updateSettings(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateSettings(request, options, callback);
    }
    createBucketAsync(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createBucketAsync(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `createBucketAsync()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.create_bucket_async.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_CreateBucketAsync_async
     */ async checkCreateBucketAsyncProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.createBucketAsync, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    updateBucketAsync(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateBucketAsync(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `updateBucketAsync()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.update_bucket_async.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_UpdateBucketAsync_async
     */ async checkUpdateBucketAsyncProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.updateBucketAsync, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    createLink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createLink(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `createLink()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.create_link.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_CreateLink_async
     */ async checkCreateLinkProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.createLink, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    deleteLink(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            name: (_a = request.name) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteLink(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `deleteLink()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.delete_link.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_DeleteLink_async
     */ async checkDeleteLinkProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.deleteLink, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    copyLogEntries(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize();
        return this.innerApiCalls.copyLogEntries(request, options, callback);
    }
    /**
     * Check the status of the long running operation returned by `copyLogEntries()`.
     * @param {String} name
     *   The operation name that will be passed.
     * @returns {Promise} - The promise which resolves to an object.
     *   The decoded operation object has result and metadata field to get information from.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#long-running-operations | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.copy_log_entries.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_CopyLogEntries_async
     */ async checkCopyLogEntriesProgress(name) {
        const request = new this._gaxModule.operationsProtos.google.longrunning.GetOperationRequest({
            name
        });
        const [operation] = await this.operationsClient.getOperation(request);
        const decodeOperation = new this._gaxModule.Operation(operation, this.descriptors.longrunning.copyLogEntries, this._gaxModule.createDefaultBackoffSettings());
        return decodeOperation;
    }
    listBuckets(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listBuckets(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose buckets are to be listed:
     *
     *       "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
     *       "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]"
     *       "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]"
     *       "folders/[FOLDER_ID]/locations/[LOCATION_ID]"
     *
     *   Note: The locations portion of the resource must be specified, but
     *   supplying the character `-` in place of [LOCATION_ID] will return all
     *   buckets.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.LogBucket|LogBucket} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listBucketsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listBucketsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listBuckets'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listBuckets.createStream(this.innerApiCalls.listBuckets, request, callSettings);
    }
    /**
     * Equivalent to `listBuckets`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose buckets are to be listed:
     *
     *       "projects/[PROJECT_ID]/locations/[LOCATION_ID]"
     *       "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]"
     *       "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]"
     *       "folders/[FOLDER_ID]/locations/[LOCATION_ID]"
     *
     *   Note: The locations portion of the resource must be specified, but
     *   supplying the character `-` in place of [LOCATION_ID] will return all
     *   buckets.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.LogBucket|LogBucket}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.list_buckets.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_ListBuckets_async
     */ listBucketsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listBuckets'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listBuckets.asyncIterate(this.innerApiCalls['listBuckets'], request, callSettings);
    }
    listViews(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listViews(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The bucket whose views are to be listed:
     *
     *       "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.LogView|LogView} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listViewsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listViewsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listViews'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listViews.createStream(this.innerApiCalls.listViews, request, callSettings);
    }
    /**
     * Equivalent to `listViews`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The bucket whose views are to be listed:
     *
     *       "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.LogView|LogView}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.list_views.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_ListViews_async
     */ listViewsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listViews'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listViews.asyncIterate(this.innerApiCalls['listViews'], request, callSettings);
    }
    listSinks(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listSinks(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose sinks are to be listed:
     *
     *       "projects/[PROJECT_ID]"
     *       "organizations/[ORGANIZATION_ID]"
     *       "billingAccounts/[BILLING_ACCOUNT_ID]"
     *       "folders/[FOLDER_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.LogSink|LogSink} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listSinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listSinksStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listSinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listSinks.createStream(this.innerApiCalls.listSinks, request, callSettings);
    }
    /**
     * Equivalent to `listSinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose sinks are to be listed:
     *
     *       "projects/[PROJECT_ID]"
     *       "organizations/[ORGANIZATION_ID]"
     *       "billingAccounts/[BILLING_ACCOUNT_ID]"
     *       "folders/[FOLDER_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.LogSink|LogSink}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.list_sinks.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_ListSinks_async
     */ listSinksAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listSinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listSinks.asyncIterate(this.innerApiCalls['listSinks'], request, callSettings);
    }
    listLinks(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listLinks(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose links are to be listed:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.Link|Link} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listLinksAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listLinksStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLinks.createStream(this.innerApiCalls.listLinks, request, callSettings);
    }
    /**
     * Equivalent to `listLinks`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose links are to be listed:
     *
     *     "projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/links/"
     *     "organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
     *     "billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/"
     *     "folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.Link|Link}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.list_links.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_ListLinks_async
     */ listLinksAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listLinks'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLinks.asyncIterate(this.innerApiCalls['listLinks'], request, callSettings);
    }
    listExclusions(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listExclusions(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose exclusions are to be listed.
     *
     *       "projects/[PROJECT_ID]"
     *       "organizations/[ORGANIZATION_ID]"
     *       "billingAccounts/[BILLING_ACCOUNT_ID]"
     *       "folders/[FOLDER_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.LogExclusion|LogExclusion} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listExclusionsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listExclusionsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listExclusions'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listExclusions.createStream(this.innerApiCalls.listExclusions, request, callSettings);
    }
    /**
     * Equivalent to `listExclusions`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The parent resource whose exclusions are to be listed.
     *
     *       "projects/[PROJECT_ID]"
     *       "organizations/[ORGANIZATION_ID]"
     *       "billingAccounts/[BILLING_ACCOUNT_ID]"
     *       "folders/[FOLDER_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.LogExclusion|LogExclusion}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/config_service_v2.list_exclusions.js</caption>
     * region_tag:logging_v2_generated_ConfigServiceV2_ListExclusions_async
     */ listExclusionsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listExclusions'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listExclusions.asyncIterate(this.innerApiCalls['listExclusions'], request, callSettings);
    }
    /**
     * Gets the latest state of a long-running operation.  Clients can use this
     * method to poll the operation result at intervals as recommended by the API
     * service.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation resource.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     *   e.g, timeout, retries, paginations, etc. See {@link
     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions}
     *   for the details.
     * @param {function(?Error, ?Object)=} callback
     *   The function which will be called with the result of the API call.
     *
     *   The second parameter to the callback is an object representing
     *   {@link google.longrunning.Operation | google.longrunning.Operation}.
     * @return {Promise} - The promise which resolves to an array.
     *   The first element of the array is an object representing
     * {@link google.longrunning.Operation | google.longrunning.Operation}.
     * The promise has a method named "cancel" which cancels the ongoing API call.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * const name = '';
     * const [response] = await client.getOperation({name});
     * // doThingsWith(response)
     * ```
     */ getOperation(request, options, callback) {
        return this.operationsClient.getOperation(request, options, callback);
    }
    /**
     * Lists operations that match the specified filter in the request. If the
     * server doesn't support this method, it returns `UNIMPLEMENTED`. Returns an iterable object.
     *
     * For-await-of syntax is used with the iterable to recursively get response element on-demand.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation collection.
     * @param {string} request.filter - The standard list filter.
     * @param {number=} request.pageSize -
     *   The maximum number of resources contained in the underlying API
     *   response. If page streaming is performed per-resource, this
     *   parameter does not affect the return value. If page streaming is
     *   performed per-page, this determines the maximum number of
     *   resources in a page.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     *   e.g, timeout, retries, paginations, etc. See {@link
     *   https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions} for the
     *   details.
     * @returns {Object}
     *   An iterable Object that conforms to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | iteration protocols}.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * for await (const response of client.listOperationsAsync(request));
     * // doThingsWith(response)
     * ```
     */ listOperationsAsync(request, options) {
        return this.operationsClient.listOperationsAsync(request, options);
    }
    /**
     * Starts asynchronous cancellation on a long-running operation.  The server
     * makes a best effort to cancel the operation, but success is not
     * guaranteed.  If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
     * {@link Operations.GetOperation} or
     * other methods to check whether the cancellation succeeded or whether the
     * operation completed despite cancellation. On successful cancellation,
     * the operation is not deleted; instead, it becomes an operation with
     * an {@link Operation.error} value with a {@link google.rpc.Status.code} of
     * 1, corresponding to `Code.CANCELLED`.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation resource to be cancelled.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     * e.g, timeout, retries, paginations, etc. See {@link
     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions} for the
     * details.
     * @param {function(?Error)=} callback
     *   The function which will be called with the result of the API call.
     * @return {Promise} - The promise which resolves when API call finishes.
     *   The promise has a method named "cancel" which cancels the ongoing API
     * call.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * await client.cancelOperation({name: ''});
     * ```
     */ cancelOperation(request, options, callback) {
        return this.operationsClient.cancelOperation(request, options, callback);
    }
    /**
     * Deletes a long-running operation. This method indicates that the client is
     * no longer interested in the operation result. It does not cancel the
     * operation. If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.
     *
     * @param {Object} request - The request object that will be sent.
     * @param {string} request.name - The name of the operation resource to be deleted.
     * @param {Object=} options
     *   Optional parameters. You can override the default settings for this call,
     * e.g, timeout, retries, paginations, etc. See {@link
     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions | gax.CallOptions}
     * for the details.
     * @param {function(?Error)=} callback
     *   The function which will be called with the result of the API call.
     * @return {Promise} - The promise which resolves when API call finishes.
     *   The promise has a method named "cancel" which cancels the ongoing API
     * call.
     *
     * @example
     * ```
     * const client = longrunning.operationsClient();
     * await client.deleteOperation({name: ''});
     * ```
     */ deleteOperation(request, options, callback) {
        return this.operationsClient.deleteOperation(request, options, callback);
    }
    // --------------------
    // -- Path templates --
    // --------------------
    /**
     * Return a fully-qualified billingAccountCmekSettings resource name string.
     *
     * @param {string} billing_account
     * @returns {string} Resource name string.
     */ billingAccountCmekSettingsPath(billingAccount) {
        return this.pathTemplates.billingAccountCmekSettingsPathTemplate.render({
            billing_account: billingAccount
        });
    }
    /**
     * Parse the billing_account from BillingAccountCmekSettings resource.
     *
     * @param {string} billingAccountCmekSettingsName
     *   A fully-qualified path representing billing_account_cmekSettings resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountCmekSettingsName(billingAccountCmekSettingsName) {
        return this.pathTemplates.billingAccountCmekSettingsPathTemplate.match(billingAccountCmekSettingsName).billing_account;
    }
    /**
     * Return a fully-qualified billingAccountExclusion resource name string.
     *
     * @param {string} billing_account
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ billingAccountExclusionPath(billingAccount, exclusion) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.render({
            billing_account: billingAccount,
            exclusion: exclusion
        });
    }
    /**
     * Parse the billing_account from BillingAccountExclusion resource.
     *
     * @param {string} billingAccountExclusionName
     *   A fully-qualified path representing billing_account_exclusion resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountExclusionName(billingAccountExclusionName) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.match(billingAccountExclusionName).billing_account;
    }
    /**
     * Parse the exclusion from BillingAccountExclusion resource.
     *
     * @param {string} billingAccountExclusionName
     *   A fully-qualified path representing billing_account_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromBillingAccountExclusionName(billingAccountExclusionName) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.match(billingAccountExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucket resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketPath(billingAccount, location, bucket) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucketLink resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketLinkPath(billingAccount, location, bucket, link) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucketView resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketViewPath(billingAccount, location, bucket, view) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified billingAccountLog resource name string.
     *
     * @param {string} billing_account
     * @param {string} log
     * @returns {string} Resource name string.
     */ billingAccountLogPath(billingAccount, log) {
        return this.pathTemplates.billingAccountLogPathTemplate.render({
            billing_account: billingAccount,
            log: log
        });
    }
    /**
     * Parse the billing_account from BillingAccountLog resource.
     *
     * @param {string} billingAccountLogName
     *   A fully-qualified path representing billing_account_log resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLogName(billingAccountLogName) {
        return this.pathTemplates.billingAccountLogPathTemplate.match(billingAccountLogName).billing_account;
    }
    /**
     * Parse the log from BillingAccountLog resource.
     *
     * @param {string} billingAccountLogName
     *   A fully-qualified path representing billing_account_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromBillingAccountLogName(billingAccountLogName) {
        return this.pathTemplates.billingAccountLogPathTemplate.match(billingAccountLogName).log;
    }
    /**
     * Return a fully-qualified billingAccountSettings resource name string.
     *
     * @param {string} billing_account
     * @returns {string} Resource name string.
     */ billingAccountSettingsPath(billingAccount) {
        return this.pathTemplates.billingAccountSettingsPathTemplate.render({
            billing_account: billingAccount
        });
    }
    /**
     * Parse the billing_account from BillingAccountSettings resource.
     *
     * @param {string} billingAccountSettingsName
     *   A fully-qualified path representing billing_account_settings resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountSettingsName(billingAccountSettingsName) {
        return this.pathTemplates.billingAccountSettingsPathTemplate.match(billingAccountSettingsName).billing_account;
    }
    /**
     * Return a fully-qualified billingAccountSink resource name string.
     *
     * @param {string} billing_account
     * @param {string} sink
     * @returns {string} Resource name string.
     */ billingAccountSinkPath(billingAccount, sink) {
        return this.pathTemplates.billingAccountSinkPathTemplate.render({
            billing_account: billingAccount,
            sink: sink
        });
    }
    /**
     * Parse the billing_account from BillingAccountSink resource.
     *
     * @param {string} billingAccountSinkName
     *   A fully-qualified path representing billing_account_sink resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountSinkName(billingAccountSinkName) {
        return this.pathTemplates.billingAccountSinkPathTemplate.match(billingAccountSinkName).billing_account;
    }
    /**
     * Parse the sink from BillingAccountSink resource.
     *
     * @param {string} billingAccountSinkName
     *   A fully-qualified path representing billing_account_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromBillingAccountSinkName(billingAccountSinkName) {
        return this.pathTemplates.billingAccountSinkPathTemplate.match(billingAccountSinkName).sink;
    }
    /**
     * Return a fully-qualified folderCmekSettings resource name string.
     *
     * @param {string} folder
     * @returns {string} Resource name string.
     */ folderCmekSettingsPath(folder) {
        return this.pathTemplates.folderCmekSettingsPathTemplate.render({
            folder: folder
        });
    }
    /**
     * Parse the folder from FolderCmekSettings resource.
     *
     * @param {string} folderCmekSettingsName
     *   A fully-qualified path representing folder_cmekSettings resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderCmekSettingsName(folderCmekSettingsName) {
        return this.pathTemplates.folderCmekSettingsPathTemplate.match(folderCmekSettingsName).folder;
    }
    /**
     * Return a fully-qualified folderExclusion resource name string.
     *
     * @param {string} folder
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ folderExclusionPath(folder, exclusion) {
        return this.pathTemplates.folderExclusionPathTemplate.render({
            folder: folder,
            exclusion: exclusion
        });
    }
    /**
     * Parse the folder from FolderExclusion resource.
     *
     * @param {string} folderExclusionName
     *   A fully-qualified path representing folder_exclusion resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderExclusionName(folderExclusionName) {
        return this.pathTemplates.folderExclusionPathTemplate.match(folderExclusionName).folder;
    }
    /**
     * Parse the exclusion from FolderExclusion resource.
     *
     * @param {string} folderExclusionName
     *   A fully-qualified path representing folder_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromFolderExclusionName(folderExclusionName) {
        return this.pathTemplates.folderExclusionPathTemplate.match(folderExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified folderLocationBucket resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ folderLocationBucketPath(folder, location, bucket) {
        return this.pathTemplates.folderLocationBucketPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the folder from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).folder;
    }
    /**
     * Parse the location from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified folderLocationBucketLink resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ folderLocationBucketLinkPath(folder, location, bucket, link) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the folder from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).folder;
    }
    /**
     * Parse the location from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified folderLocationBucketView resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ folderLocationBucketViewPath(folder, location, bucket, view) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the folder from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).folder;
    }
    /**
     * Parse the location from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified folderLog resource name string.
     *
     * @param {string} folder
     * @param {string} log
     * @returns {string} Resource name string.
     */ folderLogPath(folder, log) {
        return this.pathTemplates.folderLogPathTemplate.render({
            folder: folder,
            log: log
        });
    }
    /**
     * Parse the folder from FolderLog resource.
     *
     * @param {string} folderLogName
     *   A fully-qualified path representing folder_log resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLogName(folderLogName) {
        return this.pathTemplates.folderLogPathTemplate.match(folderLogName).folder;
    }
    /**
     * Parse the log from FolderLog resource.
     *
     * @param {string} folderLogName
     *   A fully-qualified path representing folder_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromFolderLogName(folderLogName) {
        return this.pathTemplates.folderLogPathTemplate.match(folderLogName).log;
    }
    /**
     * Return a fully-qualified folderSettings resource name string.
     *
     * @param {string} folder
     * @returns {string} Resource name string.
     */ folderSettingsPath(folder) {
        return this.pathTemplates.folderSettingsPathTemplate.render({
            folder: folder
        });
    }
    /**
     * Parse the folder from FolderSettings resource.
     *
     * @param {string} folderSettingsName
     *   A fully-qualified path representing folder_settings resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderSettingsName(folderSettingsName) {
        return this.pathTemplates.folderSettingsPathTemplate.match(folderSettingsName).folder;
    }
    /**
     * Return a fully-qualified folderSink resource name string.
     *
     * @param {string} folder
     * @param {string} sink
     * @returns {string} Resource name string.
     */ folderSinkPath(folder, sink) {
        return this.pathTemplates.folderSinkPathTemplate.render({
            folder: folder,
            sink: sink
        });
    }
    /**
     * Parse the folder from FolderSink resource.
     *
     * @param {string} folderSinkName
     *   A fully-qualified path representing folder_sink resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderSinkName(folderSinkName) {
        return this.pathTemplates.folderSinkPathTemplate.match(folderSinkName).folder;
    }
    /**
     * Parse the sink from FolderSink resource.
     *
     * @param {string} folderSinkName
     *   A fully-qualified path representing folder_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromFolderSinkName(folderSinkName) {
        return this.pathTemplates.folderSinkPathTemplate.match(folderSinkName).sink;
    }
    /**
     * Return a fully-qualified location resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @returns {string} Resource name string.
     */ locationPath(project, location) {
        return this.pathTemplates.locationPathTemplate.render({
            project: project,
            location: location
        });
    }
    /**
     * Parse the project from Location resource.
     *
     * @param {string} locationName
     *   A fully-qualified path representing Location resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromLocationName(locationName) {
        return this.pathTemplates.locationPathTemplate.match(locationName).project;
    }
    /**
     * Parse the location from Location resource.
     *
     * @param {string} locationName
     *   A fully-qualified path representing Location resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromLocationName(locationName) {
        return this.pathTemplates.locationPathTemplate.match(locationName).location;
    }
    /**
     * Return a fully-qualified logMetric resource name string.
     *
     * @param {string} project
     * @param {string} metric
     * @returns {string} Resource name string.
     */ logMetricPath(project, metric) {
        return this.pathTemplates.logMetricPathTemplate.render({
            project: project,
            metric: metric
        });
    }
    /**
     * Parse the project from LogMetric resource.
     *
     * @param {string} logMetricName
     *   A fully-qualified path representing LogMetric resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromLogMetricName(logMetricName) {
        return this.pathTemplates.logMetricPathTemplate.match(logMetricName).project;
    }
    /**
     * Parse the metric from LogMetric resource.
     *
     * @param {string} logMetricName
     *   A fully-qualified path representing LogMetric resource.
     * @returns {string} A string representing the metric.
     */ matchMetricFromLogMetricName(logMetricName) {
        return this.pathTemplates.logMetricPathTemplate.match(logMetricName).metric;
    }
    /**
     * Return a fully-qualified organizationCmekSettings resource name string.
     *
     * @param {string} organization
     * @returns {string} Resource name string.
     */ organizationCmekSettingsPath(organization) {
        return this.pathTemplates.organizationCmekSettingsPathTemplate.render({
            organization: organization
        });
    }
    /**
     * Parse the organization from OrganizationCmekSettings resource.
     *
     * @param {string} organizationCmekSettingsName
     *   A fully-qualified path representing organization_cmekSettings resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationCmekSettingsName(organizationCmekSettingsName) {
        return this.pathTemplates.organizationCmekSettingsPathTemplate.match(organizationCmekSettingsName).organization;
    }
    /**
     * Return a fully-qualified organizationExclusion resource name string.
     *
     * @param {string} organization
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ organizationExclusionPath(organization, exclusion) {
        return this.pathTemplates.organizationExclusionPathTemplate.render({
            organization: organization,
            exclusion: exclusion
        });
    }
    /**
     * Parse the organization from OrganizationExclusion resource.
     *
     * @param {string} organizationExclusionName
     *   A fully-qualified path representing organization_exclusion resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationExclusionName(organizationExclusionName) {
        return this.pathTemplates.organizationExclusionPathTemplate.match(organizationExclusionName).organization;
    }
    /**
     * Parse the exclusion from OrganizationExclusion resource.
     *
     * @param {string} organizationExclusionName
     *   A fully-qualified path representing organization_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromOrganizationExclusionName(organizationExclusionName) {
        return this.pathTemplates.organizationExclusionPathTemplate.match(organizationExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified organizationLocationBucket resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ organizationLocationBucketPath(organization, location, bucket) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified organizationLocationBucketLink resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ organizationLocationBucketLinkPath(organization, location, bucket, link) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified organizationLocationBucketView resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ organizationLocationBucketViewPath(organization, location, bucket, view) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified organizationLog resource name string.
     *
     * @param {string} organization
     * @param {string} log
     * @returns {string} Resource name string.
     */ organizationLogPath(organization, log) {
        return this.pathTemplates.organizationLogPathTemplate.render({
            organization: organization,
            log: log
        });
    }
    /**
     * Parse the organization from OrganizationLog resource.
     *
     * @param {string} organizationLogName
     *   A fully-qualified path representing organization_log resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLogName(organizationLogName) {
        return this.pathTemplates.organizationLogPathTemplate.match(organizationLogName).organization;
    }
    /**
     * Parse the log from OrganizationLog resource.
     *
     * @param {string} organizationLogName
     *   A fully-qualified path representing organization_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromOrganizationLogName(organizationLogName) {
        return this.pathTemplates.organizationLogPathTemplate.match(organizationLogName).log;
    }
    /**
     * Return a fully-qualified organizationSettings resource name string.
     *
     * @param {string} organization
     * @returns {string} Resource name string.
     */ organizationSettingsPath(organization) {
        return this.pathTemplates.organizationSettingsPathTemplate.render({
            organization: organization
        });
    }
    /**
     * Parse the organization from OrganizationSettings resource.
     *
     * @param {string} organizationSettingsName
     *   A fully-qualified path representing organization_settings resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationSettingsName(organizationSettingsName) {
        return this.pathTemplates.organizationSettingsPathTemplate.match(organizationSettingsName).organization;
    }
    /**
     * Return a fully-qualified organizationSink resource name string.
     *
     * @param {string} organization
     * @param {string} sink
     * @returns {string} Resource name string.
     */ organizationSinkPath(organization, sink) {
        return this.pathTemplates.organizationSinkPathTemplate.render({
            organization: organization,
            sink: sink
        });
    }
    /**
     * Parse the organization from OrganizationSink resource.
     *
     * @param {string} organizationSinkName
     *   A fully-qualified path representing organization_sink resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationSinkName(organizationSinkName) {
        return this.pathTemplates.organizationSinkPathTemplate.match(organizationSinkName).organization;
    }
    /**
     * Parse the sink from OrganizationSink resource.
     *
     * @param {string} organizationSinkName
     *   A fully-qualified path representing organization_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromOrganizationSinkName(organizationSinkName) {
        return this.pathTemplates.organizationSinkPathTemplate.match(organizationSinkName).sink;
    }
    /**
     * Return a fully-qualified project resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectPath(project) {
        return this.pathTemplates.projectPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from Project resource.
     *
     * @param {string} projectName
     *   A fully-qualified path representing Project resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectName(projectName) {
        return this.pathTemplates.projectPathTemplate.match(projectName).project;
    }
    /**
     * Return a fully-qualified projectCmekSettings resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectCmekSettingsPath(project) {
        return this.pathTemplates.projectCmekSettingsPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from ProjectCmekSettings resource.
     *
     * @param {string} projectCmekSettingsName
     *   A fully-qualified path representing project_cmekSettings resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectCmekSettingsName(projectCmekSettingsName) {
        return this.pathTemplates.projectCmekSettingsPathTemplate.match(projectCmekSettingsName).project;
    }
    /**
     * Return a fully-qualified projectExclusion resource name string.
     *
     * @param {string} project
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ projectExclusionPath(project, exclusion) {
        return this.pathTemplates.projectExclusionPathTemplate.render({
            project: project,
            exclusion: exclusion
        });
    }
    /**
     * Parse the project from ProjectExclusion resource.
     *
     * @param {string} projectExclusionName
     *   A fully-qualified path representing project_exclusion resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectExclusionName(projectExclusionName) {
        return this.pathTemplates.projectExclusionPathTemplate.match(projectExclusionName).project;
    }
    /**
     * Parse the exclusion from ProjectExclusion resource.
     *
     * @param {string} projectExclusionName
     *   A fully-qualified path representing project_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromProjectExclusionName(projectExclusionName) {
        return this.pathTemplates.projectExclusionPathTemplate.match(projectExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified projectLocationBucket resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ projectLocationBucketPath(project, location, bucket) {
        return this.pathTemplates.projectLocationBucketPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the project from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).project;
    }
    /**
     * Parse the location from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified projectLocationBucketLink resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ projectLocationBucketLinkPath(project, location, bucket, link) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the project from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).project;
    }
    /**
     * Parse the location from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified projectLocationBucketView resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ projectLocationBucketViewPath(project, location, bucket, view) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the project from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).project;
    }
    /**
     * Parse the location from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified projectLog resource name string.
     *
     * @param {string} project
     * @param {string} log
     * @returns {string} Resource name string.
     */ projectLogPath(project, log) {
        return this.pathTemplates.projectLogPathTemplate.render({
            project: project,
            log: log
        });
    }
    /**
     * Parse the project from ProjectLog resource.
     *
     * @param {string} projectLogName
     *   A fully-qualified path representing project_log resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLogName(projectLogName) {
        return this.pathTemplates.projectLogPathTemplate.match(projectLogName).project;
    }
    /**
     * Parse the log from ProjectLog resource.
     *
     * @param {string} projectLogName
     *   A fully-qualified path representing project_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromProjectLogName(projectLogName) {
        return this.pathTemplates.projectLogPathTemplate.match(projectLogName).log;
    }
    /**
     * Return a fully-qualified projectSettings resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectSettingsPath(project) {
        return this.pathTemplates.projectSettingsPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from ProjectSettings resource.
     *
     * @param {string} projectSettingsName
     *   A fully-qualified path representing project_settings resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectSettingsName(projectSettingsName) {
        return this.pathTemplates.projectSettingsPathTemplate.match(projectSettingsName).project;
    }
    /**
     * Return a fully-qualified projectSink resource name string.
     *
     * @param {string} project
     * @param {string} sink
     * @returns {string} Resource name string.
     */ projectSinkPath(project, sink) {
        return this.pathTemplates.projectSinkPathTemplate.render({
            project: project,
            sink: sink
        });
    }
    /**
     * Parse the project from ProjectSink resource.
     *
     * @param {string} projectSinkName
     *   A fully-qualified path representing project_sink resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectSinkName(projectSinkName) {
        return this.pathTemplates.projectSinkPathTemplate.match(projectSinkName).project;
    }
    /**
     * Parse the sink from ProjectSink resource.
     *
     * @param {string} projectSinkName
     *   A fully-qualified path representing project_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromProjectSinkName(projectSinkName) {
        return this.pathTemplates.projectSinkPathTemplate.match(projectSinkName).sink;
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */ close() {
        if (this.configServiceV2Stub && !this._terminated) {
            return this.configServiceV2Stub.then((stub)=>{
                this._terminated = true;
                stub.close();
                this.operationsClient.close();
            });
        }
        return Promise.resolve();
    }
}
exports.ConfigServiceV2Client = ConfigServiceV2Client; //# sourceMappingURL=config_service_v2_client.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/logging_service_v2_client_config.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"interfaces\":{\"google.logging.v2.LoggingServiceV2\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"INTERNAL\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"DeleteLog\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"WriteLogEntries\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\",\"bundling\":{\"element_count_threshold\":1000,\"request_byte_threshold\":1048576,\"delay_threshold_millis\":50,\"element_count_limit\":1000000}},\"ListLogEntries\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"ListMonitoredResourceDescriptors\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"ListLogs\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"TailLogEntries\":{\"timeout_millis\":3600000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"}}}}}"));}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/logging_service_v2_client.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LoggingServiceV2Client = void 0;
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const jsonProtos = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/protos/protos.json (json)");
/**
 * Client JSON configuration object, loaded from
 * `src/v2/logging_service_v2_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */ const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/logging_service_v2_client_config.json (json)");
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/package.json (json)").version;
/**
 *  Service for ingesting and querying logs.
 * @class
 * @memberof v2
 */ class LoggingServiceV2Client {
    /**
     * Construct an instance of LoggingServiceV2Client.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new LoggingServiceV2Client({fallback: true}, gax);
     *     ```
     */ constructor(opts, gaxInstance){
        var _a, _b, _c, _d, _e;
        this._terminated = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {}
        };
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) && (opts === null || opts === void 0 ? void 0 : opts.universeDomain) && (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = typeof process === 'object' && typeof process.env === 'object' ? process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null && _b !== void 0 ? _b : universeDomainEnvVar) !== null && _c !== void 0 ? _c : 'googleapis.com';
        this._servicePath = 'logging.' + this._universeDomain;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _d !== void 0 ? _d : {};
        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _e !== void 0 ? _e : "undefined" !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function';
        opts = Object.assign({
            servicePath,
            port,
            clientConfig,
            fallback
        }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/index.js [app-rsc] (ecmascript)");
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`
        ];
        if (typeof process === 'object' && 'versions' in process) {
            clientHeader.push(`gl-node/${process.versions.node}`);
        } else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        } else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // This API contains "path templates"; forward-slash-separated
        // identifiers to uniquely identify resources within the API.
        // Create useful helper objects for these.
        this.pathTemplates = {
            billingAccountCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/cmekSettings'),
            billingAccountExclusionPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/exclusions/{exclusion}'),
            billingAccountLocationBucketPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}'),
            billingAccountLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/links/{link}'),
            billingAccountLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/views/{view}'),
            billingAccountLogPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/logs/{log}'),
            billingAccountSettingsPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/settings'),
            billingAccountSinkPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/sinks/{sink}'),
            folderCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/cmekSettings'),
            folderExclusionPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/exclusions/{exclusion}'),
            folderLocationBucketPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}'),
            folderLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}/links/{link}'),
            folderLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}/views/{view}'),
            folderLogPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/logs/{log}'),
            folderSettingsPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/settings'),
            folderSinkPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/sinks/{sink}'),
            logMetricPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/metrics/{metric}'),
            organizationCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/cmekSettings'),
            organizationExclusionPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/exclusions/{exclusion}'),
            organizationLocationBucketPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}'),
            organizationLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}/links/{link}'),
            organizationLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}/views/{view}'),
            organizationLogPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/logs/{log}'),
            organizationSettingsPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/settings'),
            organizationSinkPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/sinks/{sink}'),
            projectPathTemplate: new this._gaxModule.PathTemplate('projects/{project}'),
            projectCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/cmekSettings'),
            projectExclusionPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/exclusions/{exclusion}'),
            projectLocationBucketPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}'),
            projectLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}/links/{link}'),
            projectLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}/views/{view}'),
            projectLogPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/logs/{log}'),
            projectSettingsPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/settings'),
            projectSinkPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/sinks/{sink}')
        };
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listLogEntries: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'entries'),
            listMonitoredResourceDescriptors: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'resourceDescriptors'),
            listLogs: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'logNames')
        };
        // Some of the methods on this service provide streaming responses.
        // Provide descriptors for these.
        this.descriptors.stream = {
            tailLogEntries: new this._gaxModule.StreamDescriptor(this._gaxModule.StreamType.BIDI_STREAMING, !!opts.fallback, !!opts.gaxServerStreamingRetries)
        };
        const protoFilesRoot = this._gaxModule.protobuf.Root.fromJSON(jsonProtos);
        // Some methods on this API support automatically batching
        // requests; denote this.
        this.descriptors.batching = {
            writeLogEntries: new this._gaxModule.BundleDescriptor('entries', [
                'log_name',
                'resource',
                'labels'
            ], null, this._gaxModule.GrpcClient.createByteLengthFunction(// eslint-disable-next-line @typescript-eslint/no-explicit-any
            protoFilesRoot.lookupType('google.logging.v2.LogEntry')))
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.logging.v2.LoggingServiceV2', gapicConfig, opts.clientConfig || {}, {
            'x-goog-api-client': clientHeader.join(' ')
        });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */ initialize() {
        var _a;
        // If the client stub promise is already initialized, return immediately.
        if (this.loggingServiceV2Stub) {
            return this.loggingServiceV2Stub;
        }
        // Put together the "service stub" for
        // google.logging.v2.LoggingServiceV2.
        this.loggingServiceV2Stub = this._gaxGrpc.createStub(this._opts.fallback ? this._protos.lookupService('google.logging.v2.LoggingServiceV2') : this._protos.google.logging.v2.LoggingServiceV2, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const loggingServiceV2StubMethods = [
            'deleteLog',
            'writeLogEntries',
            'listLogEntries',
            'listMonitoredResourceDescriptors',
            'listLogs',
            'tailLogEntries'
        ];
        for (const methodName of loggingServiceV2StubMethods){
            const callPromise = this.loggingServiceV2Stub.then((stub)=>(...args)=>{
                    if (this._terminated) {
                        if (methodName in this.descriptors.stream) {
                            const stream = new stream_1.PassThrough();
                            setImmediate(()=>{
                                stream.emit('error', new this._gaxModule.GoogleError('The client has already been closed.'));
                            });
                            return stream;
                        }
                        return Promise.reject('The client has already been closed.');
                    }
                    const func = stub[methodName];
                    return func.apply(stub, args);
                }, (err)=>()=>{
                    throw err;
                });
            const descriptor = this.descriptors.page[methodName] || this.descriptors.stream[methodName] || ((_a = this.descriptors.batching) === null || _a === void 0 ? void 0 : _a[methodName]) || undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.loggingServiceV2Stub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get servicePath() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'logging.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get apiEndpoint() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'logging.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */ get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */ static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */ static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/cloud-platform.read-only',
            'https://www.googleapis.com/auth/logging.admin',
            'https://www.googleapis.com/auth/logging.read',
            'https://www.googleapis.com/auth/logging.write'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */ getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    deleteLog(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            log_name: (_a = request.logName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteLog(request, options, callback);
    }
    writeLogEntries(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize();
        return this.innerApiCalls.writeLogEntries(request, options, callback);
    }
    /**
     * Streaming read of log entries as they are ingested. Until the stream is
     * terminated, it will continue reading logs.
     *
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which is both readable and writable. It accepts objects
     *   representing {@link protos.google.logging.v2.TailLogEntriesRequest|TailLogEntriesRequest} for write() method, and
     *   will emit objects representing {@link protos.google.logging.v2.TailLogEntriesResponse|TailLogEntriesResponse} on 'data' event asynchronously.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#bi-directional-streaming | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/logging_service_v2.tail_log_entries.js</caption>
     * region_tag:logging_v2_generated_LoggingServiceV2_TailLogEntries_async
     */ tailLogEntries(options) {
        this.initialize();
        return this.innerApiCalls.tailLogEntries(null, options);
    }
    listLogEntries(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize();
        return this.innerApiCalls.listLogEntries(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string[]} request.resourceNames
     *   Required. Names of one or more parent resources from which to
     *   retrieve log entries:
     *
     *   *  `projects/[PROJECT_ID]`
     *   *  `organizations/[ORGANIZATION_ID]`
     *   *  `billingAccounts/[BILLING_ACCOUNT_ID]`
     *   *  `folders/[FOLDER_ID]`
     *
     *   May alternatively be one or more views:
     *
     *    * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *
     *   Projects listed in the `project_ids` field are added to this list.
     *   A maximum of 100 resources may be specified in a single request.
     * @param {string} [request.filter]
     *   Optional. Only log entries that match the filter are returned.  An empty
     *   filter matches all log entries in the resources listed in `resource_names`.
     *   Referencing a parent resource that is not listed in `resource_names` will
     *   cause the filter to return no results. The maximum length of a filter is
     *   20,000 characters.
     * @param {string} [request.orderBy]
     *   Optional. How the results should be sorted.  Presently, the only permitted
     *   values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
     *   option returns entries in order of increasing values of
     *   `LogEntry.timestamp` (oldest first), and the second option returns entries
     *   in order of decreasing timestamps (newest first).  Entries with equal
     *   timestamps are returned in order of their `insert_id` values.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Default is 50. If the value is negative or exceeds 1000, the request is
     *   rejected. The presence of `next_page_token` in the response indicates that
     *   more results might be available.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method.  `page_token` must be the value of
     *   `next_page_token` from the previous response.  The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.LogEntry|LogEntry} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listLogEntriesAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listLogEntriesStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listLogEntries'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLogEntries.createStream(this.innerApiCalls.listLogEntries, request, callSettings);
    }
    /**
     * Equivalent to `listLogEntries`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string[]} request.resourceNames
     *   Required. Names of one or more parent resources from which to
     *   retrieve log entries:
     *
     *   *  `projects/[PROJECT_ID]`
     *   *  `organizations/[ORGANIZATION_ID]`
     *   *  `billingAccounts/[BILLING_ACCOUNT_ID]`
     *   *  `folders/[FOLDER_ID]`
     *
     *   May alternatively be one or more views:
     *
     *    * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *
     *   Projects listed in the `project_ids` field are added to this list.
     *   A maximum of 100 resources may be specified in a single request.
     * @param {string} [request.filter]
     *   Optional. Only log entries that match the filter are returned.  An empty
     *   filter matches all log entries in the resources listed in `resource_names`.
     *   Referencing a parent resource that is not listed in `resource_names` will
     *   cause the filter to return no results. The maximum length of a filter is
     *   20,000 characters.
     * @param {string} [request.orderBy]
     *   Optional. How the results should be sorted.  Presently, the only permitted
     *   values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
     *   option returns entries in order of increasing values of
     *   `LogEntry.timestamp` (oldest first), and the second option returns entries
     *   in order of decreasing timestamps (newest first).  Entries with equal
     *   timestamps are returned in order of their `insert_id` values.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Default is 50. If the value is negative or exceeds 1000, the request is
     *   rejected. The presence of `next_page_token` in the response indicates that
     *   more results might be available.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method.  `page_token` must be the value of
     *   `next_page_token` from the previous response.  The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.LogEntry|LogEntry}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/logging_service_v2.list_log_entries.js</caption>
     * region_tag:logging_v2_generated_LoggingServiceV2_ListLogEntries_async
     */ listLogEntriesAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listLogEntries'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLogEntries.asyncIterate(this.innerApiCalls['listLogEntries'], request, callSettings);
    }
    listMonitoredResourceDescriptors(request, optionsOrCallback, callback) {
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        this.initialize();
        return this.innerApiCalls.listMonitoredResourceDescriptors(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored.  The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method.  `pageToken` must be the value of
     *   `nextPageToken` from the previous response.  The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.api.MonitoredResourceDescriptor|MonitoredResourceDescriptor} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listMonitoredResourceDescriptorsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listMonitoredResourceDescriptorsStream(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listMonitoredResourceDescriptors'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listMonitoredResourceDescriptors.createStream(this.innerApiCalls.listMonitoredResourceDescriptors, request, callSettings);
    }
    /**
     * Equivalent to `listMonitoredResourceDescriptors`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored.  The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method.  `pageToken` must be the value of
     *   `nextPageToken` from the previous response.  The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.api.MonitoredResourceDescriptor|MonitoredResourceDescriptor}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/logging_service_v2.list_monitored_resource_descriptors.js</caption>
     * region_tag:logging_v2_generated_LoggingServiceV2_ListMonitoredResourceDescriptors_async
     */ listMonitoredResourceDescriptorsAsync(request, options) {
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        const defaultCallSettings = this._defaults['listMonitoredResourceDescriptors'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listMonitoredResourceDescriptors.asyncIterate(this.innerApiCalls['listMonitoredResourceDescriptors'], request, callSettings);
    }
    listLogs(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listLogs(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name to list logs for:
     *
     *   *  `projects/[PROJECT_ID]`
     *   *  `organizations/[ORGANIZATION_ID]`
     *   *  `billingAccounts/[BILLING_ACCOUNT_ID]`
     *   *  `folders/[FOLDER_ID]`
     * @param {string[]} [request.resourceNames]
     *   Optional. List of resource names to list logs for:
     *
     *    * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *
     *   To support legacy queries, it could also be:
     *
     *   *  `projects/[PROJECT_ID]`
     *   *  `organizations/[ORGANIZATION_ID]`
     *   *  `billingAccounts/[BILLING_ACCOUNT_ID]`
     *   *  `folders/[FOLDER_ID]`
     *
     *   The resource name in the `parent` field is added to this list.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored.  The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method.  `pageToken` must be the value of
     *   `nextPageToken` from the previous response.  The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing string on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listLogsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listLogsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listLogs'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLogs.createStream(this.innerApiCalls.listLogs, request, callSettings);
    }
    /**
     * Equivalent to `listLogs`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The resource name to list logs for:
     *
     *   *  `projects/[PROJECT_ID]`
     *   *  `organizations/[ORGANIZATION_ID]`
     *   *  `billingAccounts/[BILLING_ACCOUNT_ID]`
     *   *  `folders/[FOLDER_ID]`
     * @param {string[]} [request.resourceNames]
     *   Optional. List of resource names to list logs for:
     *
     *    * `projects/[PROJECT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `organizations/[ORGANIZATION_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *    * `folders/[FOLDER_ID]/locations/[LOCATION_ID]/buckets/[BUCKET_ID]/views/[VIEW_ID]`
     *
     *   To support legacy queries, it could also be:
     *
     *   *  `projects/[PROJECT_ID]`
     *   *  `organizations/[ORGANIZATION_ID]`
     *   *  `billingAccounts/[BILLING_ACCOUNT_ID]`
     *   *  `folders/[FOLDER_ID]`
     *
     *   The resource name in the `parent` field is added to this list.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored.  The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method.  `pageToken` must be the value of
     *   `nextPageToken` from the previous response.  The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   string. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/logging_service_v2.list_logs.js</caption>
     * region_tag:logging_v2_generated_LoggingServiceV2_ListLogs_async
     */ listLogsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listLogs'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLogs.asyncIterate(this.innerApiCalls['listLogs'], request, callSettings);
    }
    // --------------------
    // -- Path templates --
    // --------------------
    /**
     * Return a fully-qualified billingAccountCmekSettings resource name string.
     *
     * @param {string} billing_account
     * @returns {string} Resource name string.
     */ billingAccountCmekSettingsPath(billingAccount) {
        return this.pathTemplates.billingAccountCmekSettingsPathTemplate.render({
            billing_account: billingAccount
        });
    }
    /**
     * Parse the billing_account from BillingAccountCmekSettings resource.
     *
     * @param {string} billingAccountCmekSettingsName
     *   A fully-qualified path representing billing_account_cmekSettings resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountCmekSettingsName(billingAccountCmekSettingsName) {
        return this.pathTemplates.billingAccountCmekSettingsPathTemplate.match(billingAccountCmekSettingsName).billing_account;
    }
    /**
     * Return a fully-qualified billingAccountExclusion resource name string.
     *
     * @param {string} billing_account
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ billingAccountExclusionPath(billingAccount, exclusion) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.render({
            billing_account: billingAccount,
            exclusion: exclusion
        });
    }
    /**
     * Parse the billing_account from BillingAccountExclusion resource.
     *
     * @param {string} billingAccountExclusionName
     *   A fully-qualified path representing billing_account_exclusion resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountExclusionName(billingAccountExclusionName) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.match(billingAccountExclusionName).billing_account;
    }
    /**
     * Parse the exclusion from BillingAccountExclusion resource.
     *
     * @param {string} billingAccountExclusionName
     *   A fully-qualified path representing billing_account_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromBillingAccountExclusionName(billingAccountExclusionName) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.match(billingAccountExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucket resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketPath(billingAccount, location, bucket) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucketLink resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketLinkPath(billingAccount, location, bucket, link) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucketView resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketViewPath(billingAccount, location, bucket, view) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified billingAccountLog resource name string.
     *
     * @param {string} billing_account
     * @param {string} log
     * @returns {string} Resource name string.
     */ billingAccountLogPath(billingAccount, log) {
        return this.pathTemplates.billingAccountLogPathTemplate.render({
            billing_account: billingAccount,
            log: log
        });
    }
    /**
     * Parse the billing_account from BillingAccountLog resource.
     *
     * @param {string} billingAccountLogName
     *   A fully-qualified path representing billing_account_log resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLogName(billingAccountLogName) {
        return this.pathTemplates.billingAccountLogPathTemplate.match(billingAccountLogName).billing_account;
    }
    /**
     * Parse the log from BillingAccountLog resource.
     *
     * @param {string} billingAccountLogName
     *   A fully-qualified path representing billing_account_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromBillingAccountLogName(billingAccountLogName) {
        return this.pathTemplates.billingAccountLogPathTemplate.match(billingAccountLogName).log;
    }
    /**
     * Return a fully-qualified billingAccountSettings resource name string.
     *
     * @param {string} billing_account
     * @returns {string} Resource name string.
     */ billingAccountSettingsPath(billingAccount) {
        return this.pathTemplates.billingAccountSettingsPathTemplate.render({
            billing_account: billingAccount
        });
    }
    /**
     * Parse the billing_account from BillingAccountSettings resource.
     *
     * @param {string} billingAccountSettingsName
     *   A fully-qualified path representing billing_account_settings resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountSettingsName(billingAccountSettingsName) {
        return this.pathTemplates.billingAccountSettingsPathTemplate.match(billingAccountSettingsName).billing_account;
    }
    /**
     * Return a fully-qualified billingAccountSink resource name string.
     *
     * @param {string} billing_account
     * @param {string} sink
     * @returns {string} Resource name string.
     */ billingAccountSinkPath(billingAccount, sink) {
        return this.pathTemplates.billingAccountSinkPathTemplate.render({
            billing_account: billingAccount,
            sink: sink
        });
    }
    /**
     * Parse the billing_account from BillingAccountSink resource.
     *
     * @param {string} billingAccountSinkName
     *   A fully-qualified path representing billing_account_sink resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountSinkName(billingAccountSinkName) {
        return this.pathTemplates.billingAccountSinkPathTemplate.match(billingAccountSinkName).billing_account;
    }
    /**
     * Parse the sink from BillingAccountSink resource.
     *
     * @param {string} billingAccountSinkName
     *   A fully-qualified path representing billing_account_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromBillingAccountSinkName(billingAccountSinkName) {
        return this.pathTemplates.billingAccountSinkPathTemplate.match(billingAccountSinkName).sink;
    }
    /**
     * Return a fully-qualified folderCmekSettings resource name string.
     *
     * @param {string} folder
     * @returns {string} Resource name string.
     */ folderCmekSettingsPath(folder) {
        return this.pathTemplates.folderCmekSettingsPathTemplate.render({
            folder: folder
        });
    }
    /**
     * Parse the folder from FolderCmekSettings resource.
     *
     * @param {string} folderCmekSettingsName
     *   A fully-qualified path representing folder_cmekSettings resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderCmekSettingsName(folderCmekSettingsName) {
        return this.pathTemplates.folderCmekSettingsPathTemplate.match(folderCmekSettingsName).folder;
    }
    /**
     * Return a fully-qualified folderExclusion resource name string.
     *
     * @param {string} folder
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ folderExclusionPath(folder, exclusion) {
        return this.pathTemplates.folderExclusionPathTemplate.render({
            folder: folder,
            exclusion: exclusion
        });
    }
    /**
     * Parse the folder from FolderExclusion resource.
     *
     * @param {string} folderExclusionName
     *   A fully-qualified path representing folder_exclusion resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderExclusionName(folderExclusionName) {
        return this.pathTemplates.folderExclusionPathTemplate.match(folderExclusionName).folder;
    }
    /**
     * Parse the exclusion from FolderExclusion resource.
     *
     * @param {string} folderExclusionName
     *   A fully-qualified path representing folder_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromFolderExclusionName(folderExclusionName) {
        return this.pathTemplates.folderExclusionPathTemplate.match(folderExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified folderLocationBucket resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ folderLocationBucketPath(folder, location, bucket) {
        return this.pathTemplates.folderLocationBucketPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the folder from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).folder;
    }
    /**
     * Parse the location from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified folderLocationBucketLink resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ folderLocationBucketLinkPath(folder, location, bucket, link) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the folder from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).folder;
    }
    /**
     * Parse the location from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified folderLocationBucketView resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ folderLocationBucketViewPath(folder, location, bucket, view) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the folder from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).folder;
    }
    /**
     * Parse the location from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified folderLog resource name string.
     *
     * @param {string} folder
     * @param {string} log
     * @returns {string} Resource name string.
     */ folderLogPath(folder, log) {
        return this.pathTemplates.folderLogPathTemplate.render({
            folder: folder,
            log: log
        });
    }
    /**
     * Parse the folder from FolderLog resource.
     *
     * @param {string} folderLogName
     *   A fully-qualified path representing folder_log resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLogName(folderLogName) {
        return this.pathTemplates.folderLogPathTemplate.match(folderLogName).folder;
    }
    /**
     * Parse the log from FolderLog resource.
     *
     * @param {string} folderLogName
     *   A fully-qualified path representing folder_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromFolderLogName(folderLogName) {
        return this.pathTemplates.folderLogPathTemplate.match(folderLogName).log;
    }
    /**
     * Return a fully-qualified folderSettings resource name string.
     *
     * @param {string} folder
     * @returns {string} Resource name string.
     */ folderSettingsPath(folder) {
        return this.pathTemplates.folderSettingsPathTemplate.render({
            folder: folder
        });
    }
    /**
     * Parse the folder from FolderSettings resource.
     *
     * @param {string} folderSettingsName
     *   A fully-qualified path representing folder_settings resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderSettingsName(folderSettingsName) {
        return this.pathTemplates.folderSettingsPathTemplate.match(folderSettingsName).folder;
    }
    /**
     * Return a fully-qualified folderSink resource name string.
     *
     * @param {string} folder
     * @param {string} sink
     * @returns {string} Resource name string.
     */ folderSinkPath(folder, sink) {
        return this.pathTemplates.folderSinkPathTemplate.render({
            folder: folder,
            sink: sink
        });
    }
    /**
     * Parse the folder from FolderSink resource.
     *
     * @param {string} folderSinkName
     *   A fully-qualified path representing folder_sink resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderSinkName(folderSinkName) {
        return this.pathTemplates.folderSinkPathTemplate.match(folderSinkName).folder;
    }
    /**
     * Parse the sink from FolderSink resource.
     *
     * @param {string} folderSinkName
     *   A fully-qualified path representing folder_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromFolderSinkName(folderSinkName) {
        return this.pathTemplates.folderSinkPathTemplate.match(folderSinkName).sink;
    }
    /**
     * Return a fully-qualified logMetric resource name string.
     *
     * @param {string} project
     * @param {string} metric
     * @returns {string} Resource name string.
     */ logMetricPath(project, metric) {
        return this.pathTemplates.logMetricPathTemplate.render({
            project: project,
            metric: metric
        });
    }
    /**
     * Parse the project from LogMetric resource.
     *
     * @param {string} logMetricName
     *   A fully-qualified path representing LogMetric resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromLogMetricName(logMetricName) {
        return this.pathTemplates.logMetricPathTemplate.match(logMetricName).project;
    }
    /**
     * Parse the metric from LogMetric resource.
     *
     * @param {string} logMetricName
     *   A fully-qualified path representing LogMetric resource.
     * @returns {string} A string representing the metric.
     */ matchMetricFromLogMetricName(logMetricName) {
        return this.pathTemplates.logMetricPathTemplate.match(logMetricName).metric;
    }
    /**
     * Return a fully-qualified organizationCmekSettings resource name string.
     *
     * @param {string} organization
     * @returns {string} Resource name string.
     */ organizationCmekSettingsPath(organization) {
        return this.pathTemplates.organizationCmekSettingsPathTemplate.render({
            organization: organization
        });
    }
    /**
     * Parse the organization from OrganizationCmekSettings resource.
     *
     * @param {string} organizationCmekSettingsName
     *   A fully-qualified path representing organization_cmekSettings resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationCmekSettingsName(organizationCmekSettingsName) {
        return this.pathTemplates.organizationCmekSettingsPathTemplate.match(organizationCmekSettingsName).organization;
    }
    /**
     * Return a fully-qualified organizationExclusion resource name string.
     *
     * @param {string} organization
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ organizationExclusionPath(organization, exclusion) {
        return this.pathTemplates.organizationExclusionPathTemplate.render({
            organization: organization,
            exclusion: exclusion
        });
    }
    /**
     * Parse the organization from OrganizationExclusion resource.
     *
     * @param {string} organizationExclusionName
     *   A fully-qualified path representing organization_exclusion resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationExclusionName(organizationExclusionName) {
        return this.pathTemplates.organizationExclusionPathTemplate.match(organizationExclusionName).organization;
    }
    /**
     * Parse the exclusion from OrganizationExclusion resource.
     *
     * @param {string} organizationExclusionName
     *   A fully-qualified path representing organization_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromOrganizationExclusionName(organizationExclusionName) {
        return this.pathTemplates.organizationExclusionPathTemplate.match(organizationExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified organizationLocationBucket resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ organizationLocationBucketPath(organization, location, bucket) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified organizationLocationBucketLink resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ organizationLocationBucketLinkPath(organization, location, bucket, link) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified organizationLocationBucketView resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ organizationLocationBucketViewPath(organization, location, bucket, view) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified organizationLog resource name string.
     *
     * @param {string} organization
     * @param {string} log
     * @returns {string} Resource name string.
     */ organizationLogPath(organization, log) {
        return this.pathTemplates.organizationLogPathTemplate.render({
            organization: organization,
            log: log
        });
    }
    /**
     * Parse the organization from OrganizationLog resource.
     *
     * @param {string} organizationLogName
     *   A fully-qualified path representing organization_log resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLogName(organizationLogName) {
        return this.pathTemplates.organizationLogPathTemplate.match(organizationLogName).organization;
    }
    /**
     * Parse the log from OrganizationLog resource.
     *
     * @param {string} organizationLogName
     *   A fully-qualified path representing organization_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromOrganizationLogName(organizationLogName) {
        return this.pathTemplates.organizationLogPathTemplate.match(organizationLogName).log;
    }
    /**
     * Return a fully-qualified organizationSettings resource name string.
     *
     * @param {string} organization
     * @returns {string} Resource name string.
     */ organizationSettingsPath(organization) {
        return this.pathTemplates.organizationSettingsPathTemplate.render({
            organization: organization
        });
    }
    /**
     * Parse the organization from OrganizationSettings resource.
     *
     * @param {string} organizationSettingsName
     *   A fully-qualified path representing organization_settings resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationSettingsName(organizationSettingsName) {
        return this.pathTemplates.organizationSettingsPathTemplate.match(organizationSettingsName).organization;
    }
    /**
     * Return a fully-qualified organizationSink resource name string.
     *
     * @param {string} organization
     * @param {string} sink
     * @returns {string} Resource name string.
     */ organizationSinkPath(organization, sink) {
        return this.pathTemplates.organizationSinkPathTemplate.render({
            organization: organization,
            sink: sink
        });
    }
    /**
     * Parse the organization from OrganizationSink resource.
     *
     * @param {string} organizationSinkName
     *   A fully-qualified path representing organization_sink resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationSinkName(organizationSinkName) {
        return this.pathTemplates.organizationSinkPathTemplate.match(organizationSinkName).organization;
    }
    /**
     * Parse the sink from OrganizationSink resource.
     *
     * @param {string} organizationSinkName
     *   A fully-qualified path representing organization_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromOrganizationSinkName(organizationSinkName) {
        return this.pathTemplates.organizationSinkPathTemplate.match(organizationSinkName).sink;
    }
    /**
     * Return a fully-qualified project resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectPath(project) {
        return this.pathTemplates.projectPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from Project resource.
     *
     * @param {string} projectName
     *   A fully-qualified path representing Project resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectName(projectName) {
        return this.pathTemplates.projectPathTemplate.match(projectName).project;
    }
    /**
     * Return a fully-qualified projectCmekSettings resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectCmekSettingsPath(project) {
        return this.pathTemplates.projectCmekSettingsPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from ProjectCmekSettings resource.
     *
     * @param {string} projectCmekSettingsName
     *   A fully-qualified path representing project_cmekSettings resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectCmekSettingsName(projectCmekSettingsName) {
        return this.pathTemplates.projectCmekSettingsPathTemplate.match(projectCmekSettingsName).project;
    }
    /**
     * Return a fully-qualified projectExclusion resource name string.
     *
     * @param {string} project
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ projectExclusionPath(project, exclusion) {
        return this.pathTemplates.projectExclusionPathTemplate.render({
            project: project,
            exclusion: exclusion
        });
    }
    /**
     * Parse the project from ProjectExclusion resource.
     *
     * @param {string} projectExclusionName
     *   A fully-qualified path representing project_exclusion resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectExclusionName(projectExclusionName) {
        return this.pathTemplates.projectExclusionPathTemplate.match(projectExclusionName).project;
    }
    /**
     * Parse the exclusion from ProjectExclusion resource.
     *
     * @param {string} projectExclusionName
     *   A fully-qualified path representing project_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromProjectExclusionName(projectExclusionName) {
        return this.pathTemplates.projectExclusionPathTemplate.match(projectExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified projectLocationBucket resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ projectLocationBucketPath(project, location, bucket) {
        return this.pathTemplates.projectLocationBucketPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the project from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).project;
    }
    /**
     * Parse the location from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified projectLocationBucketLink resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ projectLocationBucketLinkPath(project, location, bucket, link) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the project from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).project;
    }
    /**
     * Parse the location from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified projectLocationBucketView resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ projectLocationBucketViewPath(project, location, bucket, view) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the project from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).project;
    }
    /**
     * Parse the location from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified projectLog resource name string.
     *
     * @param {string} project
     * @param {string} log
     * @returns {string} Resource name string.
     */ projectLogPath(project, log) {
        return this.pathTemplates.projectLogPathTemplate.render({
            project: project,
            log: log
        });
    }
    /**
     * Parse the project from ProjectLog resource.
     *
     * @param {string} projectLogName
     *   A fully-qualified path representing project_log resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLogName(projectLogName) {
        return this.pathTemplates.projectLogPathTemplate.match(projectLogName).project;
    }
    /**
     * Parse the log from ProjectLog resource.
     *
     * @param {string} projectLogName
     *   A fully-qualified path representing project_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromProjectLogName(projectLogName) {
        return this.pathTemplates.projectLogPathTemplate.match(projectLogName).log;
    }
    /**
     * Return a fully-qualified projectSettings resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectSettingsPath(project) {
        return this.pathTemplates.projectSettingsPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from ProjectSettings resource.
     *
     * @param {string} projectSettingsName
     *   A fully-qualified path representing project_settings resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectSettingsName(projectSettingsName) {
        return this.pathTemplates.projectSettingsPathTemplate.match(projectSettingsName).project;
    }
    /**
     * Return a fully-qualified projectSink resource name string.
     *
     * @param {string} project
     * @param {string} sink
     * @returns {string} Resource name string.
     */ projectSinkPath(project, sink) {
        return this.pathTemplates.projectSinkPathTemplate.render({
            project: project,
            sink: sink
        });
    }
    /**
     * Parse the project from ProjectSink resource.
     *
     * @param {string} projectSinkName
     *   A fully-qualified path representing project_sink resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectSinkName(projectSinkName) {
        return this.pathTemplates.projectSinkPathTemplate.match(projectSinkName).project;
    }
    /**
     * Parse the sink from ProjectSink resource.
     *
     * @param {string} projectSinkName
     *   A fully-qualified path representing project_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromProjectSinkName(projectSinkName) {
        return this.pathTemplates.projectSinkPathTemplate.match(projectSinkName).sink;
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */ close() {
        if (this.loggingServiceV2Stub && !this._terminated) {
            return this.loggingServiceV2Stub.then((stub)=>{
                this._terminated = true;
                stub.close();
            });
        }
        return Promise.resolve();
    }
}
exports.LoggingServiceV2Client = LoggingServiceV2Client; //# sourceMappingURL=logging_service_v2_client.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/metrics_service_v2_client_config.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"interfaces\":{\"google.logging.v2.MetricsServiceV2\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"INTERNAL\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"ListLogMetrics\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetLogMetric\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"CreateLogMetric\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateLogMetric\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"DeleteLogMetric\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"}}}}}"));}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/metrics_service_v2_client.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetricsServiceV2Client = void 0;
const jsonProtos = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/protos/protos.json (json)");
/**
 * Client JSON configuration object, loaded from
 * `src/v2/metrics_service_v2_client_config.json`.
 * This file defines retry strategy and timeouts for all API methods in this library.
 */ const gapicConfig = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/metrics_service_v2_client_config.json (json)");
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/package.json (json)").version;
/**
 *  Service for configuring logs-based metrics.
 * @class
 * @memberof v2
 */ class MetricsServiceV2Client {
    /**
     * Construct an instance of MetricsServiceV2Client.
     *
     * @param {object} [options] - The configuration object.
     * The options accepted by the constructor are described in detail
     * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
     * The common options are:
     * @param {object} [options.credentials] - Credentials object.
     * @param {string} [options.credentials.client_email]
     * @param {string} [options.credentials.private_key]
     * @param {string} [options.email] - Account email address. Required when
     *     using a .pem or .p12 keyFilename.
     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
     *     .p12 key downloaded from the Google Developers Console. If you provide
     *     a path to a JSON file, the projectId option below is not necessary.
     *     NOTE: .pem and .p12 require you to specify options.email as well.
     * @param {number} [options.port] - The port on which to connect to
     *     the remote host.
     * @param {string} [options.projectId] - The project ID from the Google
     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
     *     the environment variable GCLOUD_PROJECT for your project ID. If your
     *     app is running in an environment which supports
     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
     *     your project ID will be detected automatically.
     * @param {string} [options.apiEndpoint] - The domain name of the
     *     API remote host.
     * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
     *     Follows the structure of {@link gapicConfig}.
     * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
     *     For more information, please check the
     *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
     * @param {gax} [gaxInstance]: loaded instance of `google-gax`. Useful if you
     *     need to avoid loading the default gRPC version and want to use the fallback
     *     HTTP implementation. Load only fallback version and pass it to the constructor:
     *     ```
     *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
     *     const client = new MetricsServiceV2Client({fallback: true}, gax);
     *     ```
     */ constructor(opts, gaxInstance){
        var _a, _b, _c, _d, _e;
        this._terminated = false;
        this.descriptors = {
            page: {},
            stream: {},
            longrunning: {},
            batching: {}
        };
        // Ensure that options include all the required fields.
        const staticMembers = this.constructor;
        if ((opts === null || opts === void 0 ? void 0 : opts.universe_domain) && (opts === null || opts === void 0 ? void 0 : opts.universeDomain) && (opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== (opts === null || opts === void 0 ? void 0 : opts.universeDomain)) {
            throw new Error('Please set either universe_domain or universeDomain, but not both.');
        }
        const universeDomainEnvVar = typeof process === 'object' && typeof process.env === 'object' ? process.env['GOOGLE_CLOUD_UNIVERSE_DOMAIN'] : undefined;
        this._universeDomain = (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.universeDomain) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.universe_domain) !== null && _b !== void 0 ? _b : universeDomainEnvVar) !== null && _c !== void 0 ? _c : 'googleapis.com';
        this._servicePath = 'logging.' + this._universeDomain;
        const servicePath = (opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint) || this._servicePath;
        this._providedCustomServicePath = !!((opts === null || opts === void 0 ? void 0 : opts.servicePath) || (opts === null || opts === void 0 ? void 0 : opts.apiEndpoint));
        const port = (opts === null || opts === void 0 ? void 0 : opts.port) || staticMembers.port;
        const clientConfig = (_d = opts === null || opts === void 0 ? void 0 : opts.clientConfig) !== null && _d !== void 0 ? _d : {};
        const fallback = (_e = opts === null || opts === void 0 ? void 0 : opts.fallback) !== null && _e !== void 0 ? _e : "undefined" !== 'undefined' && typeof (window === null || window === void 0 ? void 0 : window.fetch) === 'function';
        opts = Object.assign({
            servicePath,
            port,
            clientConfig,
            fallback
        }, opts);
        // Request numeric enum values if REST transport is used.
        opts.numericEnums = true;
        // If scopes are unset in options and we're connecting to a non-default endpoint, set scopes just in case.
        if (servicePath !== this._servicePath && !('scopes' in opts)) {
            opts['scopes'] = staticMembers.scopes;
        }
        // Load google-gax module synchronously if needed
        if (!gaxInstance) {
            gaxInstance = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/index.js [app-rsc] (ecmascript)");
        }
        // Choose either gRPC or proto-over-HTTP implementation of google-gax.
        this._gaxModule = opts.fallback ? gaxInstance.fallback : gaxInstance;
        // Create a `gaxGrpc` object, with any grpc-specific options sent to the client.
        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);
        // Save options to use in initialize() method.
        this._opts = opts;
        // Save the auth object to the client, for use by other methods.
        this.auth = this._gaxGrpc.auth;
        // Set useJWTAccessWithScope on the auth object.
        this.auth.useJWTAccessWithScope = true;
        // Set defaultServicePath on the auth object.
        this.auth.defaultServicePath = this._servicePath;
        // Set the default scopes in auth client if needed.
        if (servicePath === this._servicePath) {
            this.auth.defaultScopes = staticMembers.scopes;
        }
        // Determine the client header string.
        const clientHeader = [
            `gax/${this._gaxModule.version}`,
            `gapic/${version}`
        ];
        if (typeof process === 'object' && 'versions' in process) {
            clientHeader.push(`gl-node/${process.versions.node}`);
        } else {
            clientHeader.push(`gl-web/${this._gaxModule.version}`);
        }
        if (!opts.fallback) {
            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);
        } else {
            clientHeader.push(`rest/${this._gaxGrpc.grpcVersion}`);
        }
        if (opts.libName && opts.libVersion) {
            clientHeader.push(`${opts.libName}/${opts.libVersion}`);
        }
        // Load the applicable protos.
        this._protos = this._gaxGrpc.loadProtoJSON(jsonProtos);
        // This API contains "path templates"; forward-slash-separated
        // identifiers to uniquely identify resources within the API.
        // Create useful helper objects for these.
        this.pathTemplates = {
            billingAccountCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/cmekSettings'),
            billingAccountExclusionPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/exclusions/{exclusion}'),
            billingAccountLocationBucketPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}'),
            billingAccountLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/links/{link}'),
            billingAccountLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/views/{view}'),
            billingAccountLogPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/logs/{log}'),
            billingAccountSettingsPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/settings'),
            billingAccountSinkPathTemplate: new this._gaxModule.PathTemplate('billingAccounts/{billing_account}/sinks/{sink}'),
            folderCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/cmekSettings'),
            folderExclusionPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/exclusions/{exclusion}'),
            folderLocationBucketPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}'),
            folderLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}/links/{link}'),
            folderLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/locations/{location}/buckets/{bucket}/views/{view}'),
            folderLogPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/logs/{log}'),
            folderSettingsPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/settings'),
            folderSinkPathTemplate: new this._gaxModule.PathTemplate('folders/{folder}/sinks/{sink}'),
            logMetricPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/metrics/{metric}'),
            organizationCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/cmekSettings'),
            organizationExclusionPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/exclusions/{exclusion}'),
            organizationLocationBucketPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}'),
            organizationLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}/links/{link}'),
            organizationLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/locations/{location}/buckets/{bucket}/views/{view}'),
            organizationLogPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/logs/{log}'),
            organizationSettingsPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/settings'),
            organizationSinkPathTemplate: new this._gaxModule.PathTemplate('organizations/{organization}/sinks/{sink}'),
            projectPathTemplate: new this._gaxModule.PathTemplate('projects/{project}'),
            projectCmekSettingsPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/cmekSettings'),
            projectExclusionPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/exclusions/{exclusion}'),
            projectLocationBucketPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}'),
            projectLocationBucketLinkPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}/links/{link}'),
            projectLocationBucketViewPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/locations/{location}/buckets/{bucket}/views/{view}'),
            projectLogPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/logs/{log}'),
            projectSettingsPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/settings'),
            projectSinkPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/sinks/{sink}')
        };
        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this.descriptors.page = {
            listLogMetrics: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'metrics')
        };
        // Put together the default options sent with requests.
        this._defaults = this._gaxGrpc.constructSettings('google.logging.v2.MetricsServiceV2', gapicConfig, opts.clientConfig || {}, {
            'x-goog-api-client': clientHeader.join(' ')
        });
        // Set up a dictionary of "inner API calls"; the core implementation
        // of calling the API is handled in `google-gax`, with this code
        // merely providing the destination and request information.
        this.innerApiCalls = {};
        // Add a warn function to the client constructor so it can be easily tested.
        this.warn = this._gaxModule.warn;
    }
    /**
     * Initialize the client.
     * Performs asynchronous operations (such as authentication) and prepares the client.
     * This function will be called automatically when any class method is called for the
     * first time, but if you need to initialize it before calling an actual method,
     * feel free to call initialize() directly.
     *
     * You can await on this method if you want to make sure the client is initialized.
     *
     * @returns {Promise} A promise that resolves to an authenticated service stub.
     */ initialize() {
        // If the client stub promise is already initialized, return immediately.
        if (this.metricsServiceV2Stub) {
            return this.metricsServiceV2Stub;
        }
        // Put together the "service stub" for
        // google.logging.v2.MetricsServiceV2.
        this.metricsServiceV2Stub = this._gaxGrpc.createStub(this._opts.fallback ? this._protos.lookupService('google.logging.v2.MetricsServiceV2') : this._protos.google.logging.v2.MetricsServiceV2, this._opts, this._providedCustomServicePath);
        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        const metricsServiceV2StubMethods = [
            'listLogMetrics',
            'getLogMetric',
            'createLogMetric',
            'updateLogMetric',
            'deleteLogMetric'
        ];
        for (const methodName of metricsServiceV2StubMethods){
            const callPromise = this.metricsServiceV2Stub.then((stub)=>(...args)=>{
                    if (this._terminated) {
                        return Promise.reject('The client has already been closed.');
                    }
                    const func = stub[methodName];
                    return func.apply(stub, args);
                }, (err)=>()=>{
                    throw err;
                });
            const descriptor = this.descriptors.page[methodName] || undefined;
            const apiCall = this._gaxModule.createApiCall(callPromise, this._defaults[methodName], descriptor, this._opts.fallback);
            this.innerApiCalls[methodName] = apiCall;
        }
        return this.metricsServiceV2Stub;
    }
    /**
     * The DNS address for this API service.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get servicePath() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static servicePath is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'logging.googleapis.com';
    }
    /**
     * The DNS address for this API service - same as servicePath.
     * @deprecated Use the apiEndpoint method of the client instance.
     * @returns {string} The DNS address for this service.
     */ static get apiEndpoint() {
        if (typeof process === 'object' && typeof process.emitWarning === 'function') {
            process.emitWarning('Static apiEndpoint is deprecated, please use the instance method instead.', 'DeprecationWarning');
        }
        return 'logging.googleapis.com';
    }
    /**
     * The DNS address for this API service.
     * @returns {string} The DNS address for this service.
     */ get apiEndpoint() {
        return this._servicePath;
    }
    get universeDomain() {
        return this._universeDomain;
    }
    /**
     * The port for this API service.
     * @returns {number} The default port for this service.
     */ static get port() {
        return 443;
    }
    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     * @returns {string[]} List of default scopes.
     */ static get scopes() {
        return [
            'https://www.googleapis.com/auth/cloud-platform',
            'https://www.googleapis.com/auth/cloud-platform.read-only',
            'https://www.googleapis.com/auth/logging.admin',
            'https://www.googleapis.com/auth/logging.read',
            'https://www.googleapis.com/auth/logging.write'
        ];
    }
    /**
     * Return the project ID used by this class.
     * @returns {Promise} A promise that resolves to string containing the project ID.
     */ getProjectId(callback) {
        if (callback) {
            this.auth.getProjectId(callback);
            return;
        }
        return this.auth.getProjectId();
    }
    getLogMetric(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            metric_name: (_a = request.metricName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.getLogMetric(request, options, callback);
    }
    createLogMetric(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.createLogMetric(request, options, callback);
    }
    updateLogMetric(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            metric_name: (_a = request.metricName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.updateLogMetric(request, options, callback);
    }
    deleteLogMetric(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            metric_name: (_a = request.metricName) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.deleteLogMetric(request, options, callback);
    }
    listLogMetrics(request, optionsOrCallback, callback) {
        var _a;
        request = request || {};
        let options;
        if (typeof optionsOrCallback === 'function' && callback === undefined) {
            callback = optionsOrCallback;
            options = {};
        } else {
            options = optionsOrCallback;
        }
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        this.initialize();
        return this.innerApiCalls.listLogMetrics(request, options, callback);
    }
    /**
     * Equivalent to `method.name.toCamelCase()`, but returns a NodeJS Stream object.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The name of the project containing the metrics:
     *
     *       "projects/[PROJECT_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Stream}
     *   An object stream which emits an object representing {@link protos.google.logging.v2.LogMetric|LogMetric} on 'data' event.
     *   The client library will perform auto-pagination by default: it will call the API as many
     *   times as needed. Note that it can affect your quota.
     *   We recommend using `listLogMetricsAsync()`
     *   method described below for async iteration which you can stop as needed.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     */ listLogMetricsStream(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listLogMetrics'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLogMetrics.createStream(this.innerApiCalls.listLogMetrics, request, callSettings);
    }
    /**
     * Equivalent to `listLogMetrics`, but returns an iterable object.
     *
     * `for`-`await`-`of` syntax is used with the iterable to get response elements on-demand.
     * @param {Object} request
     *   The request object that will be sent.
     * @param {string} request.parent
     *   Required. The name of the project containing the metrics:
     *
     *       "projects/[PROJECT_ID]"
     * @param {string} [request.pageToken]
     *   Optional. If present, then retrieve the next batch of results from the
     *   preceding call to this method. `pageToken` must be the value of
     *   `nextPageToken` from the previous response. The values of other method
     *   parameters should be identical to those in the previous call.
     * @param {number} [request.pageSize]
     *   Optional. The maximum number of results to return from this request.
     *   Non-positive values are ignored. The presence of `nextPageToken` in the
     *   response indicates that more results might be available.
     * @param {object} [options]
     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.
     * @returns {Object}
     *   An iterable Object that allows {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | async iteration }.
     *   When you iterate the returned iterable, each element will be an object representing
     *   {@link protos.google.logging.v2.LogMetric|LogMetric}. The API will be called under the hood as needed, once per the page,
     *   so you can stop the iteration when you don't need more results.
     *   Please see the {@link https://github.com/googleapis/gax-nodejs/blob/master/client-libraries.md#auto-pagination | documentation }
     *   for more details and examples.
     * @example <caption>include:samples/generated/v2/metrics_service_v2.list_log_metrics.js</caption>
     * region_tag:logging_v2_generated_MetricsServiceV2_ListLogMetrics_async
     */ listLogMetricsAsync(request, options) {
        var _a;
        request = request || {};
        options = options || {};
        options.otherArgs = options.otherArgs || {};
        options.otherArgs.headers = options.otherArgs.headers || {};
        options.otherArgs.headers['x-goog-request-params'] = this._gaxModule.routingHeader.fromParams({
            parent: (_a = request.parent) !== null && _a !== void 0 ? _a : ''
        });
        const defaultCallSettings = this._defaults['listLogMetrics'];
        const callSettings = defaultCallSettings.merge(options);
        this.initialize();
        return this.descriptors.page.listLogMetrics.asyncIterate(this.innerApiCalls['listLogMetrics'], request, callSettings);
    }
    // --------------------
    // -- Path templates --
    // --------------------
    /**
     * Return a fully-qualified billingAccountCmekSettings resource name string.
     *
     * @param {string} billing_account
     * @returns {string} Resource name string.
     */ billingAccountCmekSettingsPath(billingAccount) {
        return this.pathTemplates.billingAccountCmekSettingsPathTemplate.render({
            billing_account: billingAccount
        });
    }
    /**
     * Parse the billing_account from BillingAccountCmekSettings resource.
     *
     * @param {string} billingAccountCmekSettingsName
     *   A fully-qualified path representing billing_account_cmekSettings resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountCmekSettingsName(billingAccountCmekSettingsName) {
        return this.pathTemplates.billingAccountCmekSettingsPathTemplate.match(billingAccountCmekSettingsName).billing_account;
    }
    /**
     * Return a fully-qualified billingAccountExclusion resource name string.
     *
     * @param {string} billing_account
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ billingAccountExclusionPath(billingAccount, exclusion) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.render({
            billing_account: billingAccount,
            exclusion: exclusion
        });
    }
    /**
     * Parse the billing_account from BillingAccountExclusion resource.
     *
     * @param {string} billingAccountExclusionName
     *   A fully-qualified path representing billing_account_exclusion resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountExclusionName(billingAccountExclusionName) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.match(billingAccountExclusionName).billing_account;
    }
    /**
     * Parse the exclusion from BillingAccountExclusion resource.
     *
     * @param {string} billingAccountExclusionName
     *   A fully-qualified path representing billing_account_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromBillingAccountExclusionName(billingAccountExclusionName) {
        return this.pathTemplates.billingAccountExclusionPathTemplate.match(billingAccountExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucket resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketPath(billingAccount, location, bucket) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucket resource.
     *
     * @param {string} billingAccountLocationBucketName
     *   A fully-qualified path representing billing_account_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketName(billingAccountLocationBucketName) {
        return this.pathTemplates.billingAccountLocationBucketPathTemplate.match(billingAccountLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucketLink resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketLinkPath(billingAccount, location, bucket, link) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from BillingAccountLocationBucketLink resource.
     *
     * @param {string} billingAccountLocationBucketLinkName
     *   A fully-qualified path representing billing_account_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromBillingAccountLocationBucketLinkName(billingAccountLocationBucketLinkName) {
        return this.pathTemplates.billingAccountLocationBucketLinkPathTemplate.match(billingAccountLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified billingAccountLocationBucketView resource name string.
     *
     * @param {string} billing_account
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ billingAccountLocationBucketViewPath(billingAccount, location, bucket, view) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.render({
            billing_account: billingAccount,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the billing_account from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).billing_account;
    }
    /**
     * Parse the location from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from BillingAccountLocationBucketView resource.
     *
     * @param {string} billingAccountLocationBucketViewName
     *   A fully-qualified path representing billing_account_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromBillingAccountLocationBucketViewName(billingAccountLocationBucketViewName) {
        return this.pathTemplates.billingAccountLocationBucketViewPathTemplate.match(billingAccountLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified billingAccountLog resource name string.
     *
     * @param {string} billing_account
     * @param {string} log
     * @returns {string} Resource name string.
     */ billingAccountLogPath(billingAccount, log) {
        return this.pathTemplates.billingAccountLogPathTemplate.render({
            billing_account: billingAccount,
            log: log
        });
    }
    /**
     * Parse the billing_account from BillingAccountLog resource.
     *
     * @param {string} billingAccountLogName
     *   A fully-qualified path representing billing_account_log resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountLogName(billingAccountLogName) {
        return this.pathTemplates.billingAccountLogPathTemplate.match(billingAccountLogName).billing_account;
    }
    /**
     * Parse the log from BillingAccountLog resource.
     *
     * @param {string} billingAccountLogName
     *   A fully-qualified path representing billing_account_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromBillingAccountLogName(billingAccountLogName) {
        return this.pathTemplates.billingAccountLogPathTemplate.match(billingAccountLogName).log;
    }
    /**
     * Return a fully-qualified billingAccountSettings resource name string.
     *
     * @param {string} billing_account
     * @returns {string} Resource name string.
     */ billingAccountSettingsPath(billingAccount) {
        return this.pathTemplates.billingAccountSettingsPathTemplate.render({
            billing_account: billingAccount
        });
    }
    /**
     * Parse the billing_account from BillingAccountSettings resource.
     *
     * @param {string} billingAccountSettingsName
     *   A fully-qualified path representing billing_account_settings resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountSettingsName(billingAccountSettingsName) {
        return this.pathTemplates.billingAccountSettingsPathTemplate.match(billingAccountSettingsName).billing_account;
    }
    /**
     * Return a fully-qualified billingAccountSink resource name string.
     *
     * @param {string} billing_account
     * @param {string} sink
     * @returns {string} Resource name string.
     */ billingAccountSinkPath(billingAccount, sink) {
        return this.pathTemplates.billingAccountSinkPathTemplate.render({
            billing_account: billingAccount,
            sink: sink
        });
    }
    /**
     * Parse the billing_account from BillingAccountSink resource.
     *
     * @param {string} billingAccountSinkName
     *   A fully-qualified path representing billing_account_sink resource.
     * @returns {string} A string representing the billing_account.
     */ matchBillingAccountFromBillingAccountSinkName(billingAccountSinkName) {
        return this.pathTemplates.billingAccountSinkPathTemplate.match(billingAccountSinkName).billing_account;
    }
    /**
     * Parse the sink from BillingAccountSink resource.
     *
     * @param {string} billingAccountSinkName
     *   A fully-qualified path representing billing_account_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromBillingAccountSinkName(billingAccountSinkName) {
        return this.pathTemplates.billingAccountSinkPathTemplate.match(billingAccountSinkName).sink;
    }
    /**
     * Return a fully-qualified folderCmekSettings resource name string.
     *
     * @param {string} folder
     * @returns {string} Resource name string.
     */ folderCmekSettingsPath(folder) {
        return this.pathTemplates.folderCmekSettingsPathTemplate.render({
            folder: folder
        });
    }
    /**
     * Parse the folder from FolderCmekSettings resource.
     *
     * @param {string} folderCmekSettingsName
     *   A fully-qualified path representing folder_cmekSettings resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderCmekSettingsName(folderCmekSettingsName) {
        return this.pathTemplates.folderCmekSettingsPathTemplate.match(folderCmekSettingsName).folder;
    }
    /**
     * Return a fully-qualified folderExclusion resource name string.
     *
     * @param {string} folder
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ folderExclusionPath(folder, exclusion) {
        return this.pathTemplates.folderExclusionPathTemplate.render({
            folder: folder,
            exclusion: exclusion
        });
    }
    /**
     * Parse the folder from FolderExclusion resource.
     *
     * @param {string} folderExclusionName
     *   A fully-qualified path representing folder_exclusion resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderExclusionName(folderExclusionName) {
        return this.pathTemplates.folderExclusionPathTemplate.match(folderExclusionName).folder;
    }
    /**
     * Parse the exclusion from FolderExclusion resource.
     *
     * @param {string} folderExclusionName
     *   A fully-qualified path representing folder_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromFolderExclusionName(folderExclusionName) {
        return this.pathTemplates.folderExclusionPathTemplate.match(folderExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified folderLocationBucket resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ folderLocationBucketPath(folder, location, bucket) {
        return this.pathTemplates.folderLocationBucketPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the folder from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).folder;
    }
    /**
     * Parse the location from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucket resource.
     *
     * @param {string} folderLocationBucketName
     *   A fully-qualified path representing folder_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketName(folderLocationBucketName) {
        return this.pathTemplates.folderLocationBucketPathTemplate.match(folderLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified folderLocationBucketLink resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ folderLocationBucketLinkPath(folder, location, bucket, link) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the folder from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).folder;
    }
    /**
     * Parse the location from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from FolderLocationBucketLink resource.
     *
     * @param {string} folderLocationBucketLinkName
     *   A fully-qualified path representing folder_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromFolderLocationBucketLinkName(folderLocationBucketLinkName) {
        return this.pathTemplates.folderLocationBucketLinkPathTemplate.match(folderLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified folderLocationBucketView resource name string.
     *
     * @param {string} folder
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ folderLocationBucketViewPath(folder, location, bucket, view) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.render({
            folder: folder,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the folder from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).folder;
    }
    /**
     * Parse the location from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from FolderLocationBucketView resource.
     *
     * @param {string} folderLocationBucketViewName
     *   A fully-qualified path representing folder_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromFolderLocationBucketViewName(folderLocationBucketViewName) {
        return this.pathTemplates.folderLocationBucketViewPathTemplate.match(folderLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified folderLog resource name string.
     *
     * @param {string} folder
     * @param {string} log
     * @returns {string} Resource name string.
     */ folderLogPath(folder, log) {
        return this.pathTemplates.folderLogPathTemplate.render({
            folder: folder,
            log: log
        });
    }
    /**
     * Parse the folder from FolderLog resource.
     *
     * @param {string} folderLogName
     *   A fully-qualified path representing folder_log resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderLogName(folderLogName) {
        return this.pathTemplates.folderLogPathTemplate.match(folderLogName).folder;
    }
    /**
     * Parse the log from FolderLog resource.
     *
     * @param {string} folderLogName
     *   A fully-qualified path representing folder_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromFolderLogName(folderLogName) {
        return this.pathTemplates.folderLogPathTemplate.match(folderLogName).log;
    }
    /**
     * Return a fully-qualified folderSettings resource name string.
     *
     * @param {string} folder
     * @returns {string} Resource name string.
     */ folderSettingsPath(folder) {
        return this.pathTemplates.folderSettingsPathTemplate.render({
            folder: folder
        });
    }
    /**
     * Parse the folder from FolderSettings resource.
     *
     * @param {string} folderSettingsName
     *   A fully-qualified path representing folder_settings resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderSettingsName(folderSettingsName) {
        return this.pathTemplates.folderSettingsPathTemplate.match(folderSettingsName).folder;
    }
    /**
     * Return a fully-qualified folderSink resource name string.
     *
     * @param {string} folder
     * @param {string} sink
     * @returns {string} Resource name string.
     */ folderSinkPath(folder, sink) {
        return this.pathTemplates.folderSinkPathTemplate.render({
            folder: folder,
            sink: sink
        });
    }
    /**
     * Parse the folder from FolderSink resource.
     *
     * @param {string} folderSinkName
     *   A fully-qualified path representing folder_sink resource.
     * @returns {string} A string representing the folder.
     */ matchFolderFromFolderSinkName(folderSinkName) {
        return this.pathTemplates.folderSinkPathTemplate.match(folderSinkName).folder;
    }
    /**
     * Parse the sink from FolderSink resource.
     *
     * @param {string} folderSinkName
     *   A fully-qualified path representing folder_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromFolderSinkName(folderSinkName) {
        return this.pathTemplates.folderSinkPathTemplate.match(folderSinkName).sink;
    }
    /**
     * Return a fully-qualified logMetric resource name string.
     *
     * @param {string} project
     * @param {string} metric
     * @returns {string} Resource name string.
     */ logMetricPath(project, metric) {
        return this.pathTemplates.logMetricPathTemplate.render({
            project: project,
            metric: metric
        });
    }
    /**
     * Parse the project from LogMetric resource.
     *
     * @param {string} logMetricName
     *   A fully-qualified path representing LogMetric resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromLogMetricName(logMetricName) {
        return this.pathTemplates.logMetricPathTemplate.match(logMetricName).project;
    }
    /**
     * Parse the metric from LogMetric resource.
     *
     * @param {string} logMetricName
     *   A fully-qualified path representing LogMetric resource.
     * @returns {string} A string representing the metric.
     */ matchMetricFromLogMetricName(logMetricName) {
        return this.pathTemplates.logMetricPathTemplate.match(logMetricName).metric;
    }
    /**
     * Return a fully-qualified organizationCmekSettings resource name string.
     *
     * @param {string} organization
     * @returns {string} Resource name string.
     */ organizationCmekSettingsPath(organization) {
        return this.pathTemplates.organizationCmekSettingsPathTemplate.render({
            organization: organization
        });
    }
    /**
     * Parse the organization from OrganizationCmekSettings resource.
     *
     * @param {string} organizationCmekSettingsName
     *   A fully-qualified path representing organization_cmekSettings resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationCmekSettingsName(organizationCmekSettingsName) {
        return this.pathTemplates.organizationCmekSettingsPathTemplate.match(organizationCmekSettingsName).organization;
    }
    /**
     * Return a fully-qualified organizationExclusion resource name string.
     *
     * @param {string} organization
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ organizationExclusionPath(organization, exclusion) {
        return this.pathTemplates.organizationExclusionPathTemplate.render({
            organization: organization,
            exclusion: exclusion
        });
    }
    /**
     * Parse the organization from OrganizationExclusion resource.
     *
     * @param {string} organizationExclusionName
     *   A fully-qualified path representing organization_exclusion resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationExclusionName(organizationExclusionName) {
        return this.pathTemplates.organizationExclusionPathTemplate.match(organizationExclusionName).organization;
    }
    /**
     * Parse the exclusion from OrganizationExclusion resource.
     *
     * @param {string} organizationExclusionName
     *   A fully-qualified path representing organization_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromOrganizationExclusionName(organizationExclusionName) {
        return this.pathTemplates.organizationExclusionPathTemplate.match(organizationExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified organizationLocationBucket resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ organizationLocationBucketPath(organization, location, bucket) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucket resource.
     *
     * @param {string} organizationLocationBucketName
     *   A fully-qualified path representing organization_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketName(organizationLocationBucketName) {
        return this.pathTemplates.organizationLocationBucketPathTemplate.match(organizationLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified organizationLocationBucketLink resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ organizationLocationBucketLinkPath(organization, location, bucket, link) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from OrganizationLocationBucketLink resource.
     *
     * @param {string} organizationLocationBucketLinkName
     *   A fully-qualified path representing organization_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromOrganizationLocationBucketLinkName(organizationLocationBucketLinkName) {
        return this.pathTemplates.organizationLocationBucketLinkPathTemplate.match(organizationLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified organizationLocationBucketView resource name string.
     *
     * @param {string} organization
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ organizationLocationBucketViewPath(organization, location, bucket, view) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.render({
            organization: organization,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the organization from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).organization;
    }
    /**
     * Parse the location from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from OrganizationLocationBucketView resource.
     *
     * @param {string} organizationLocationBucketViewName
     *   A fully-qualified path representing organization_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromOrganizationLocationBucketViewName(organizationLocationBucketViewName) {
        return this.pathTemplates.organizationLocationBucketViewPathTemplate.match(organizationLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified organizationLog resource name string.
     *
     * @param {string} organization
     * @param {string} log
     * @returns {string} Resource name string.
     */ organizationLogPath(organization, log) {
        return this.pathTemplates.organizationLogPathTemplate.render({
            organization: organization,
            log: log
        });
    }
    /**
     * Parse the organization from OrganizationLog resource.
     *
     * @param {string} organizationLogName
     *   A fully-qualified path representing organization_log resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationLogName(organizationLogName) {
        return this.pathTemplates.organizationLogPathTemplate.match(organizationLogName).organization;
    }
    /**
     * Parse the log from OrganizationLog resource.
     *
     * @param {string} organizationLogName
     *   A fully-qualified path representing organization_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromOrganizationLogName(organizationLogName) {
        return this.pathTemplates.organizationLogPathTemplate.match(organizationLogName).log;
    }
    /**
     * Return a fully-qualified organizationSettings resource name string.
     *
     * @param {string} organization
     * @returns {string} Resource name string.
     */ organizationSettingsPath(organization) {
        return this.pathTemplates.organizationSettingsPathTemplate.render({
            organization: organization
        });
    }
    /**
     * Parse the organization from OrganizationSettings resource.
     *
     * @param {string} organizationSettingsName
     *   A fully-qualified path representing organization_settings resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationSettingsName(organizationSettingsName) {
        return this.pathTemplates.organizationSettingsPathTemplate.match(organizationSettingsName).organization;
    }
    /**
     * Return a fully-qualified organizationSink resource name string.
     *
     * @param {string} organization
     * @param {string} sink
     * @returns {string} Resource name string.
     */ organizationSinkPath(organization, sink) {
        return this.pathTemplates.organizationSinkPathTemplate.render({
            organization: organization,
            sink: sink
        });
    }
    /**
     * Parse the organization from OrganizationSink resource.
     *
     * @param {string} organizationSinkName
     *   A fully-qualified path representing organization_sink resource.
     * @returns {string} A string representing the organization.
     */ matchOrganizationFromOrganizationSinkName(organizationSinkName) {
        return this.pathTemplates.organizationSinkPathTemplate.match(organizationSinkName).organization;
    }
    /**
     * Parse the sink from OrganizationSink resource.
     *
     * @param {string} organizationSinkName
     *   A fully-qualified path representing organization_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromOrganizationSinkName(organizationSinkName) {
        return this.pathTemplates.organizationSinkPathTemplate.match(organizationSinkName).sink;
    }
    /**
     * Return a fully-qualified project resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectPath(project) {
        return this.pathTemplates.projectPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from Project resource.
     *
     * @param {string} projectName
     *   A fully-qualified path representing Project resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectName(projectName) {
        return this.pathTemplates.projectPathTemplate.match(projectName).project;
    }
    /**
     * Return a fully-qualified projectCmekSettings resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectCmekSettingsPath(project) {
        return this.pathTemplates.projectCmekSettingsPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from ProjectCmekSettings resource.
     *
     * @param {string} projectCmekSettingsName
     *   A fully-qualified path representing project_cmekSettings resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectCmekSettingsName(projectCmekSettingsName) {
        return this.pathTemplates.projectCmekSettingsPathTemplate.match(projectCmekSettingsName).project;
    }
    /**
     * Return a fully-qualified projectExclusion resource name string.
     *
     * @param {string} project
     * @param {string} exclusion
     * @returns {string} Resource name string.
     */ projectExclusionPath(project, exclusion) {
        return this.pathTemplates.projectExclusionPathTemplate.render({
            project: project,
            exclusion: exclusion
        });
    }
    /**
     * Parse the project from ProjectExclusion resource.
     *
     * @param {string} projectExclusionName
     *   A fully-qualified path representing project_exclusion resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectExclusionName(projectExclusionName) {
        return this.pathTemplates.projectExclusionPathTemplate.match(projectExclusionName).project;
    }
    /**
     * Parse the exclusion from ProjectExclusion resource.
     *
     * @param {string} projectExclusionName
     *   A fully-qualified path representing project_exclusion resource.
     * @returns {string} A string representing the exclusion.
     */ matchExclusionFromProjectExclusionName(projectExclusionName) {
        return this.pathTemplates.projectExclusionPathTemplate.match(projectExclusionName).exclusion;
    }
    /**
     * Return a fully-qualified projectLocationBucket resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @returns {string} Resource name string.
     */ projectLocationBucketPath(project, location, bucket) {
        return this.pathTemplates.projectLocationBucketPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket
        });
    }
    /**
     * Parse the project from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).project;
    }
    /**
     * Parse the location from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucket resource.
     *
     * @param {string} projectLocationBucketName
     *   A fully-qualified path representing project_location_bucket resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketName(projectLocationBucketName) {
        return this.pathTemplates.projectLocationBucketPathTemplate.match(projectLocationBucketName).bucket;
    }
    /**
     * Return a fully-qualified projectLocationBucketLink resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @param {string} link
     * @returns {string} Resource name string.
     */ projectLocationBucketLinkPath(project, location, bucket, link) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket,
            link: link
        });
    }
    /**
     * Parse the project from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).project;
    }
    /**
     * Parse the location from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).bucket;
    }
    /**
     * Parse the link from ProjectLocationBucketLink resource.
     *
     * @param {string} projectLocationBucketLinkName
     *   A fully-qualified path representing project_location_bucket_link resource.
     * @returns {string} A string representing the link.
     */ matchLinkFromProjectLocationBucketLinkName(projectLocationBucketLinkName) {
        return this.pathTemplates.projectLocationBucketLinkPathTemplate.match(projectLocationBucketLinkName).link;
    }
    /**
     * Return a fully-qualified projectLocationBucketView resource name string.
     *
     * @param {string} project
     * @param {string} location
     * @param {string} bucket
     * @param {string} view
     * @returns {string} Resource name string.
     */ projectLocationBucketViewPath(project, location, bucket, view) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.render({
            project: project,
            location: location,
            bucket: bucket,
            view: view
        });
    }
    /**
     * Parse the project from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).project;
    }
    /**
     * Parse the location from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the location.
     */ matchLocationFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).location;
    }
    /**
     * Parse the bucket from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the bucket.
     */ matchBucketFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).bucket;
    }
    /**
     * Parse the view from ProjectLocationBucketView resource.
     *
     * @param {string} projectLocationBucketViewName
     *   A fully-qualified path representing project_location_bucket_view resource.
     * @returns {string} A string representing the view.
     */ matchViewFromProjectLocationBucketViewName(projectLocationBucketViewName) {
        return this.pathTemplates.projectLocationBucketViewPathTemplate.match(projectLocationBucketViewName).view;
    }
    /**
     * Return a fully-qualified projectLog resource name string.
     *
     * @param {string} project
     * @param {string} log
     * @returns {string} Resource name string.
     */ projectLogPath(project, log) {
        return this.pathTemplates.projectLogPathTemplate.render({
            project: project,
            log: log
        });
    }
    /**
     * Parse the project from ProjectLog resource.
     *
     * @param {string} projectLogName
     *   A fully-qualified path representing project_log resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectLogName(projectLogName) {
        return this.pathTemplates.projectLogPathTemplate.match(projectLogName).project;
    }
    /**
     * Parse the log from ProjectLog resource.
     *
     * @param {string} projectLogName
     *   A fully-qualified path representing project_log resource.
     * @returns {string} A string representing the log.
     */ matchLogFromProjectLogName(projectLogName) {
        return this.pathTemplates.projectLogPathTemplate.match(projectLogName).log;
    }
    /**
     * Return a fully-qualified projectSettings resource name string.
     *
     * @param {string} project
     * @returns {string} Resource name string.
     */ projectSettingsPath(project) {
        return this.pathTemplates.projectSettingsPathTemplate.render({
            project: project
        });
    }
    /**
     * Parse the project from ProjectSettings resource.
     *
     * @param {string} projectSettingsName
     *   A fully-qualified path representing project_settings resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectSettingsName(projectSettingsName) {
        return this.pathTemplates.projectSettingsPathTemplate.match(projectSettingsName).project;
    }
    /**
     * Return a fully-qualified projectSink resource name string.
     *
     * @param {string} project
     * @param {string} sink
     * @returns {string} Resource name string.
     */ projectSinkPath(project, sink) {
        return this.pathTemplates.projectSinkPathTemplate.render({
            project: project,
            sink: sink
        });
    }
    /**
     * Parse the project from ProjectSink resource.
     *
     * @param {string} projectSinkName
     *   A fully-qualified path representing project_sink resource.
     * @returns {string} A string representing the project.
     */ matchProjectFromProjectSinkName(projectSinkName) {
        return this.pathTemplates.projectSinkPathTemplate.match(projectSinkName).project;
    }
    /**
     * Parse the sink from ProjectSink resource.
     *
     * @param {string} projectSinkName
     *   A fully-qualified path representing project_sink resource.
     * @returns {string} A string representing the sink.
     */ matchSinkFromProjectSinkName(projectSinkName) {
        return this.pathTemplates.projectSinkPathTemplate.match(projectSinkName).sink;
    }
    /**
     * Terminate the gRPC channel and close the client.
     *
     * The client will no longer be usable and all future behavior is undefined.
     * @returns {Promise} A promise that resolves when the client is closed.
     */ close() {
        if (this.metricsServiceV2Stub && !this._terminated) {
            return this.metricsServiceV2Stub.then((stub)=>{
                this._terminated = true;
                stub.close();
            });
        }
        return Promise.resolve();
    }
}
exports.MetricsServiceV2Client = MetricsServiceV2Client; //# sourceMappingURL=metrics_service_v2_client.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/v2/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetricsServiceV2Client = exports.LoggingServiceV2Client = exports.ConfigServiceV2Client = void 0;
var config_service_v2_client_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/config_service_v2_client.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "ConfigServiceV2Client", {
    enumerable: true,
    get: function() {
        return config_service_v2_client_1.ConfigServiceV2Client;
    }
});
var logging_service_v2_client_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/logging_service_v2_client.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "LoggingServiceV2Client", {
    enumerable: true,
    get: function() {
        return logging_service_v2_client_1.LoggingServiceV2Client;
    }
});
var metrics_service_v2_client_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/metrics_service_v2_client.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "MetricsServiceV2Client", {
    enumerable: true,
    get: function() {
        return metrics_service_v2_client_1.MetricsServiceV2Client;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/utils/common.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ObjectToStructConverter = void 0;
exports.objToStruct = objToStruct;
exports.structToObj = structToObj;
exports.decodeValue = decodeValue;
exports.zuluToDateObj = zuluToDateObj;
exports.toNanosAndSecondsObj = toNanosAndSecondsObj;
function objToStruct(obj, options) {
    return new ObjectToStructConverter(options).convert(obj);
}
class ObjectToStructConverter {
    /**
     * A class that can be used to convert an object to a struct. Optionally this
     * class can be used to erase/throw on circular references during conversion.
     *
     * @private
     *
     * @param {object=} options - Configuration object.
     * @param {boolean} options.removeCircular - Remove circular references in the
     *     object with a placeholder string. (Default: `false`)
     * @param {boolean} options.stringify - Stringify un-recognized types. (Default:
     *     `false`)
     */ constructor(options){
        options = options || {};
        this.seenObjects = new Set();
        this.removeCircular = options.removeCircular === true;
        this.stringify = options.stringify === true;
    }
    /**
     * Begin the conversion process from a JS object to an encoded gRPC Value
     * message.
     *
     * @param {*} value - The input value.
     * @return {object} - The encoded value.
     *
     * @example
     * ```
     * ObjectToStructConverter.convert({
     *   aString: 'Hi'
     * });
     * // {
     * //   fields: {
     * //     aString: {
     * //       stringValue: 'Hello!'
     * //     }
     * //   }
     * // }
     * ```
     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    convert(obj) {
        const convertedObject = {
            fields: {}
        };
        this.seenObjects.add(obj);
        for(const prop in obj){
            if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                const value = obj[prop];
                if (value === undefined) {
                    continue;
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                convertedObject.fields[prop] = this.encodeValue_(value);
            }
        }
        this.seenObjects.delete(obj);
        return convertedObject;
    }
    /**
     * Convert a raw value to a type-denoted protobuf message-friendly object.
     *
     * @private
     *
     * @param {*} value - The input value.
     * @return {*} - The encoded value.
     *
     * @example
     * ```
     * ObjectToStructConverter.encodeValue('Hi');
     * // {
     * //   stringValue: 'Hello!'
     * // }
     * ```
     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    encodeValue_(value) {
        let convertedValue;
        if (value === null) {
            convertedValue = {
                nullValue: 0
            };
        } else if (typeof value === 'number') {
            convertedValue = {
                numberValue: value
            };
        } else if (typeof value === 'string') {
            convertedValue = {
                stringValue: value
            };
        } else if (typeof value === 'boolean') {
            convertedValue = {
                boolValue: value
            };
        } else if (Buffer.isBuffer(value)) {
            convertedValue = {
                blobValue: value
            };
        } else if (Array.isArray(value)) {
            convertedValue = {
                listValue: {
                    values: value.map(this.encodeValue_.bind(this))
                }
            };
        } else if (Object.prototype.toString.call(value) === '[object Object]') {
            if (this.seenObjects.has(value)) {
                // Circular reference.
                if (!this.removeCircular) {
                    throw new Error([
                        'This object contains a circular reference. To automatically',
                        'remove it, set the `removeCircular` option to true.'
                    ].join(' '));
                }
                convertedValue = {
                    stringValue: '[Circular]'
                };
            } else {
                convertedValue = {
                    structValue: this.convert(value)
                };
            }
        } else {
            if (!this.stringify) {
                throw new Error('Value of type ' + typeof value + ' not recognized.');
            }
            convertedValue = {
                stringValue: String(value)
            };
        }
        return convertedValue;
    }
}
exports.ObjectToStructConverter = ObjectToStructConverter;
/**
 * Condense a protobuf Struct into an object of only its values.
 *
 * @private
 *
 * @param {object} struct - A protobuf Struct message.
 * @return {object} - The simplified object.
 *
 * @example
 * ```
 * GrpcService.structToObj_({
 *   fields: {
 *     name: {
 *       kind: 'stringValue',
 *       stringValue: 'Stephen'
 *     }
 *   }
 * });
 * // {
 * //   name: 'Stephen'
 * // }
 * ```
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
function structToObj(struct) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const convertedObject = {};
    for(const prop in struct.fields){
        // eslint-disable-next-line no-prototype-builtins
        if (struct.fields.hasOwnProperty(prop)) {
            const value = struct.fields[prop];
            convertedObject[prop] = decodeValue(value);
        }
    }
    return convertedObject;
}
/**
 * Decode a protobuf Struct's value.
 *
 * @param {object} value - A Struct's Field message.
 * @return {*} - The decoded value.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
function decodeValue(value) {
    switch(value.kind){
        case 'structValue':
            {
                return structToObj(value.structValue);
            }
        case 'nullValue':
            {
                return null;
            }
        case 'listValue':
            {
                return value.listValue.values.map(decodeValue);
            }
        default:
            {
                return value[value.kind];
            }
    }
}
/**
 * zuluToDateObj RFC3339 "Zulu" timestamp into a format that can be parsed to
 * a JS Date Object.
 * @param zuluTime
 */ function zuluToDateObj(zuluTime) {
    var _a;
    const ms = Date.parse(zuluTime.split(/[.,Z]/)[0] + 'Z');
    const reNano = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.(\d{0,9})Z$/;
    const nanoSecs = (_a = zuluTime.match(reNano)) === null || _a === void 0 ? void 0 : _a[1];
    return {
        seconds: ms ? Math.floor(ms / 1000) : 0,
        nanos: nanoSecs ? Number(nanoSecs.padEnd(9, '0')) : 0
    };
}
/**
 * Converts Date to nanoseconds format suported by Logging.
 * See https://cloud.google.com/logging/docs/agent/logging/configuration#timestamp-processing for more details
 * @param date The date to be converted to Logging nanos and seconds format
 */ function toNanosAndSecondsObj(date) {
    const seconds = date.getTime() / 1000;
    const secondsRounded = Math.floor(seconds);
    return {
        seconds: secondsRounded,
        nanos: Math.floor((seconds - secondsRounded) * 1e9)
    };
} //# sourceMappingURL=common.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/entry.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Entry = exports.TRACE_SAMPLED_KEY = exports.TRACE_KEY = exports.SPAN_ID_KEY = exports.SOURCE_LOCATION_KEY = exports.OPERATION_KEY = exports.LABELS_KEY = exports.INSERT_ID_KEY = void 0;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const EventId = __turbopack_context__.r("[project]/node_modules/eventid/build/src/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/common.js [app-rsc] (ecmascript)");
const http_request_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/http-request.js [app-rsc] (ecmascript)");
const context_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/context.js [app-rsc] (ecmascript)");
const eventId = new EventId();
exports.INSERT_ID_KEY = 'logging.googleapis.com/insertId';
exports.LABELS_KEY = 'logging.googleapis.com/labels';
exports.OPERATION_KEY = 'logging.googleapis.com/operation';
exports.SOURCE_LOCATION_KEY = 'logging.googleapis.com/sourceLocation';
exports.SPAN_ID_KEY = 'logging.googleapis.com/spanId';
exports.TRACE_KEY = 'logging.googleapis.com/trace';
exports.TRACE_SAMPLED_KEY = 'logging.googleapis.com/trace_sampled';
/**
 * Create an entry object to define new data to insert into a meta.
 *
 * Note, {@link https://cloud.google.com/logging/quotas|Cloud Logging Quotas and limits}
 * dictates that the maximum log entry size, including all
 * {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry|LogEntry Resource properties},
 * cannot exceed approximately 256 KB.
 *
 * See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry|LogEntry JSON representation}
 *
 * @class
 *
 * @param {?object} [metadata] See a
 *     [LogEntry
 * Resource](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry).
 * @param {object|string} data The data to use as the value for this log
 *     entry.
 *
 *     If providing an object, these value types are supported:
 *     - `String`
 *     - `Number`
 *     - `Boolean`
 *     - `Buffer`
 *     - `Object`
 *     - `Array`
 *
 *     Any other types are stringified with `String(value)`.
 *
 * @example
 * ```
 * const {Logging} = require('@google-cloud/logging');
 * const logging = new Logging();
 * const syslog = logging.log('syslog');
 *
 * const metadata = {
 *   resource: {
 *     type: 'gce_instance',
 *     labels: {
 *       zone: 'global',
 *       instance_id: '3'
 *     }
 *   }
 * };
 *
 * const entry = syslog.entry(metadata, {
 *   delegate: 'my_username'
 * });
 *
 * syslog.alert(entry, (err, apiResponse) => {
 *   if (!err) {
 *     // Log entry inserted successfully.
 *   }
 * });
 *
 * //-
 * // You will also receive `Entry` objects when using
 * // Logging#getEntries() and Log#getEntries().
 * //-
 * logging.getEntries((err, entries) => {
 *   if (!err) {
 *     // entries[0].data = The data value from the log entry.
 *   }
 * });
 * ```
 */ class Entry {
    constructor(metadata, data){
        /**
         * @name Entry#metadata
         * @type {object}
         * @property {Date} timestamp
         * @property {number} insertId
         */ this.metadata = extend({
            timestamp: new Date()
        }, metadata);
        // JavaScript date has a very coarse granularity (millisecond), which makes
        // it quite likely that multiple log entries would have the same timestamp.
        // The Logging API doesn't guarantee to preserve insertion order for entries
        // with the same timestamp. The service does use `insertId` as a secondary
        // ordering for entries with the same timestamp. `insertId` needs to be
        // globally unique (within the project) however.
        //
        // We use a globally unique monotonically increasing EventId as the
        // insertId.
        this.metadata.insertId = this.metadata.insertId || eventId.new();
        /**
         * @name Entry#data
         * @type {object}
         */ this.data = data;
    }
    /**
     * Serialize an entry to the format the API expects. Read more:
     * https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry
     *
     * @param {object} [options] Configuration object.
     * @param {boolean} [options.removeCircular] Replace circular references in an
     *     object with a string value, `[Circular]`.
     * @param {string} [projectId] GCP Project ID.
     */ toJSON(options = {}, projectId = '') {
        const entry = extend(true, {}, this.metadata);
        // Format log message
        if (this.isObject(this.data)) {
            entry.jsonPayload = (0, common_1.objToStruct)(this.data, {
                removeCircular: !!options.removeCircular,
                stringify: true
            });
        } else if (typeof this.data === 'string') {
            entry.textPayload = this.data;
        }
        // Format log timestamp
        if (entry.timestamp instanceof Date) {
            entry.timestamp = (0, common_1.toNanosAndSecondsObj)(entry.timestamp);
        } else if (typeof entry.timestamp === 'string') {
            entry.timestamp = (0, common_1.zuluToDateObj)(entry.timestamp);
        }
        // Format httpRequest
        const req = this.metadata.httpRequest;
        if ((0, http_request_1.isRawHttpRequest)(req)) {
            entry.httpRequest = (0, http_request_1.makeHttpRequestData)(req);
        }
        // Format trace and span
        const traceContext = this.extractTraceContext(projectId);
        if (traceContext) {
            if (!this.metadata.trace && traceContext.trace) entry.trace = traceContext.trace;
            if (!this.metadata.spanId && traceContext.spanId) entry.spanId = traceContext.spanId;
            if (this.metadata.traceSampled === undefined) entry.traceSampled = traceContext.traceSampled;
        }
        return entry;
    }
    /**
     * Serialize an entry to a standard format for any transports, e.g. agents.
     * Read more: https://cloud.google.com/logging/docs/structured-logging
     */ toStructuredJSON(projectId = '', useMessageField = true) {
        const meta = this.metadata;
        // Mask out the keys that need to be renamed.
        /* eslint-disable @typescript-eslint/no-unused-vars */ const { textPayload, jsonPayload, insertId, trace, spanId, traceSampled, operation, sourceLocation, labels, ...validKeys } = meta;
        /* eslint-enable @typescript-eslint/no-unused-vars */ let entry = extend(true, {}, validKeys);
        // Re-map keys names.
        entry[exports.LABELS_KEY] = meta.labels ? Object.assign({}, meta.labels) : undefined;
        entry[exports.INSERT_ID_KEY] = meta.insertId || undefined;
        entry[exports.TRACE_KEY] = meta.trace || undefined;
        entry[exports.SPAN_ID_KEY] = meta.spanId || undefined;
        entry[exports.TRACE_SAMPLED_KEY] = 'traceSampled' in meta && meta.traceSampled !== null ? meta.traceSampled : undefined;
        // Format log payload.
        const data = this.data || meta.textPayload || meta.jsonPayload || meta.protoPayload || undefined;
        if (useMessageField) {
            /** If useMessageField is set, we add the payload to {@link StructuredJson#message} field.*/ entry.message = data;
        } else {
            /** useMessageField is false, we add the structured payload to {@link StructuredJson} key-value map.
             * It could be especially useful for serverless environments like Cloud Run/Functions when stdout transport is used.
             * Note that text still added to {@link StructuredJson#message} field for text payload since it does not have fields within. */ if (data !== undefined && data !== null) {
                if (this.isObject(data)) {
                    entry = extend(true, {}, entry, data);
                } else if (typeof data === 'string') {
                    entry.message = data;
                } else {
                    entry.message = JSON.stringify(data);
                }
            }
        }
        // Format timestamp
        if (meta.timestamp instanceof Date) {
            entry.timestamp = (0, common_1.toNanosAndSecondsObj)(meta.timestamp);
        }
        // Format httprequest
        const req = meta.httpRequest;
        if ((0, http_request_1.isRawHttpRequest)(req)) {
            entry.httpRequest = (0, http_request_1.makeHttpRequestData)(req);
        }
        // Detected trace context from OpenTelemetry context or http headers if applicable.
        const traceContext = this.extractTraceContext(projectId);
        if (traceContext) {
            if (!entry[exports.TRACE_KEY] && traceContext.trace) entry[exports.TRACE_KEY] = traceContext.trace;
            if (!entry[exports.SPAN_ID_KEY] && traceContext.spanId) entry[exports.SPAN_ID_KEY] = traceContext.spanId;
            if (entry[exports.TRACE_SAMPLED_KEY] === undefined) entry[exports.TRACE_SAMPLED_KEY] = traceContext.traceSampled;
        }
        return entry;
    }
    /**
     * extractTraceContext extracts trace and span information from OpenTelemetry
     * span context or raw HTTP request headers.
     * @private
     */ extractTraceContext(projectId) {
        // Extract trace context from OpenTelemetry span context.
        const otelContext = (0, context_1.getContextFromOtelContext)(projectId);
        if (otelContext) return otelContext;
        // Extract trace context from http request headers.
        const rawReq = this.metadata.httpRequest;
        if (rawReq && 'headers' in rawReq) {
            return (0, context_1.getOrInjectContext)(rawReq, projectId, false);
        }
        return null;
    }
    /**
     * Create an Entry object from an API response, such as `entries:list`.
     *
     * @private
     *
     * @param {object} entry An API representation of an entry. See a
     *     {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry| LogEntry}.
     * @returns {Entry}
     */ static fromApiResponse_(entry) {
        let data = entry[entry.payload];
        if (entry.payload === 'jsonPayload') {
            data = (0, common_1.structToObj)(data);
        }
        const serializedEntry = new Entry(entry, data);
        if (entry.timestamp) {
            let ms = Number(entry.timestamp.seconds) * 1000;
            ms += Number(entry.timestamp.nanos) / 1e6;
            serializedEntry.metadata.timestamp = new Date(ms);
        }
        return serializedEntry;
    }
    /**
     * Determines whether `value` is a JavaScript object.
     * @param value The value to be checked
     * @returns true if `value` is a JavaScript object, false otherwise
     */ isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }
}
exports.Entry = Entry; //# sourceMappingURL=entry.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/utils/log-common.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Severity = void 0;
exports.snakecaseKeys = snakecaseKeys;
exports.assignSeverityToEntries = assignSeverityToEntries;
exports.formatLogName = formatLogName;
/**
 * Common construct and functions used by both Log and LogSync
 */ const entry_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/entry.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const arrify = __turbopack_context__.r("[project]/node_modules/arrify/index.js [app-rsc] (ecmascript)");
var Severity;
(function(Severity) {
    Severity[Severity["emergency"] = 0] = "emergency";
    Severity[Severity["alert"] = 1] = "alert";
    Severity[Severity["critical"] = 2] = "critical";
    Severity[Severity["error"] = 3] = "error";
    Severity[Severity["warning"] = 4] = "warning";
    Severity[Severity["notice"] = 5] = "notice";
    Severity[Severity["info"] = 6] = "info";
    Severity[Severity["debug"] = 7] = "debug";
})(Severity || (exports.Severity = Severity = {}));
/**
 * snakecaseKeys turns label keys from camel case to snake case.
 * @param labels
 */ function snakecaseKeys(labels) {
    for(const key in labels){
        const replaced = key.replace(/[A-Z]/g, (letter)=>`_${letter.toLowerCase()}`);
        Object.defineProperty(labels, replaced, Object.getOwnPropertyDescriptor(labels, key));
        if (replaced !== key) {
            delete labels[key];
        }
    }
    return labels;
}
/**
 * Return an array of log entries with the desired severity assigned.
 *
 * @private
 *
 * @param {object|object[]} entries - Log entries.
 * @param {string} severity - The desired severity level.
 */ function assignSeverityToEntries(entries, severity) {
    return arrify(entries).map((entry)=>{
        const metadata = extend(true, {}, entry.metadata, {
            severity
        });
        return extend(new entry_1.Entry(), entry, {
            metadata
        });
    });
}
/**
 * Format the name of a log. A log's full name is in the format of
 * 'projects/{projectId}/logs/{logName}'.
 *
 * @param projectId
 * @param name
 */ function formatLogName(projectId, name) {
    const path = 'projects/' + projectId + '/logs/';
    name = name.replace(path, '');
    if (decodeURIComponent(name) === name) {
        // The name has not been encoded yet.
        name = encodeURIComponent(name);
    }
    return path + name;
} //# sourceMappingURL=log-common.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/utils/instrumentation.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MAX_INSTRUMENTATION_COUNT = exports.NODEJS_DEFAULT_LIBRARY_VERSION = exports.NODEJS_LIBRARY_NAME_PREFIX = exports.INSTRUMENTATION_SOURCE_KEY = exports.DIAGNOSTIC_INFO_KEY = void 0;
exports.populateInstrumentationInfo = populateInstrumentationInfo;
exports.createDiagnosticEntry = createDiagnosticEntry;
exports.getNodejsLibraryVersion = getNodejsLibraryVersion;
exports.setInstrumentationStatus = setInstrumentationStatus;
const arrify = __turbopack_context__.r("[project]/node_modules/arrify/index.js [app-rsc] (ecmascript)");
const entry_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/entry.js [app-rsc] (ecmascript)");
// The global variable keeping track if instrumentation record was already written or not.
// The instrumentation record should be generated only once per process and contain logging
// libraries related info.
global.instrumentationAdded = false;
// The global variable to avoid records inspection once instrumentation already written to prevent perf impact
global.shouldSkipInstrumentationCheck = false;
// Max length for instrumentation library name and version values
const maxDiagnosticValueLen = 14;
exports.DIAGNOSTIC_INFO_KEY = 'logging.googleapis.com/diagnostic';
exports.INSTRUMENTATION_SOURCE_KEY = 'instrumentation_source';
exports.NODEJS_LIBRARY_NAME_PREFIX = 'nodejs';
/**
 * Default library version to be used
 * Using release-please annotations to update DEFAULT_INSTRUMENTATION_VERSION with latest version.
 * See https://github.com/googleapis/release-please/blob/main/docs/customizing.md#updating-arbitrary-files
 */ exports.NODEJS_DEFAULT_LIBRARY_VERSION = '11.2.0'; // {x-release-please-version}
exports.MAX_INSTRUMENTATION_COUNT = 3;
/**
 * This method helps to populate entries with instrumentation data
 * @param entry {Entry} The entry or array of entries to be populated with instrumentation info
 * @returns [Entry[], boolean] Array of entries which contains an entry with current library
 * instrumentation info and boolean flag indicating if instrumentation was added or not in this call
 */ function populateInstrumentationInfo(entry) {
    var _a, _b;
    // Check if instrumentation data was already written once. This prevents also inspection of
    // the entries for instrumentation data to prevent perf degradation
    if (global.shouldSkipInstrumentationCheck) {
        return [
            arrify(entry),
            false
        ];
    }
    // Update the flag indicating that instrumentation entry was already added once,
    // so any subsequent calls to this method will not add a separate instrumentation log entry
    let isWritten = setInstrumentationStatus(true);
    // Flag keeping track if this specific call added any instrumentation info
    let isInfoAdded = false;
    const entries = [];
    if (entry) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        for (const entryItem of arrify(entry)){
            if (entryItem) {
                const info = (_b = (_a = entryItem.data) === null || _a === void 0 ? void 0 : _a[exports.DIAGNOSTIC_INFO_KEY]) === null || _b === void 0 ? void 0 : _b[exports.INSTRUMENTATION_SOURCE_KEY];
                if (info) {
                    // Validate and update the instrumentation info with current library info
                    entryItem.data[exports.DIAGNOSTIC_INFO_KEY][exports.INSTRUMENTATION_SOURCE_KEY] = validateAndUpdateInstrumentation(info);
                    // Indicate that instrumentation info log entry already exists
                    // and that current library info was added to existing log entry
                    global.shouldSkipInstrumentationCheck = isInfoAdded = isWritten = true;
                }
                entries.push(entryItem);
            }
        }
    }
    // If no instrumentation info was added before, append a separate log entry with
    // instrumentation data for this library
    if (!isWritten) {
        entries.push(createDiagnosticEntry(undefined, undefined));
        global.shouldSkipInstrumentationCheck = isInfoAdded = true;
    }
    return [
        entries,
        isInfoAdded
    ];
}
/**
 * The helper method to generate a log entry with diagnostic instrumentation data.
 * @param libraryName {string} The name of the logging library to be reported. Should be prefixed with 'nodejs'.
 *        Will be truncated if longer than 14 characters.
 * @param libraryVersion {string} The version of the logging library to be reported. Will be truncated if longer than 14 characters.
 * @returns {Entry} The entry with diagnostic instrumentation data.
 */ function createDiagnosticEntry(libraryName, libraryVersion) {
    // Validate the libraryName first and make sure it starts with 'nodejs' prefix.
    if (!libraryName || !libraryName.startsWith(exports.NODEJS_LIBRARY_NAME_PREFIX)) {
        libraryName = exports.NODEJS_LIBRARY_NAME_PREFIX;
    }
    const entry = new entry_1.Entry(undefined, {
        [exports.DIAGNOSTIC_INFO_KEY]: {
            [exports.INSTRUMENTATION_SOURCE_KEY]: [
                {
                    // Truncate libraryName and libraryVersion if more than 14 characters length
                    name: truncateValue(libraryName, maxDiagnosticValueLen),
                    version: truncateValue(libraryVersion !== null && libraryVersion !== void 0 ? libraryVersion : getNodejsLibraryVersion(), maxDiagnosticValueLen)
                }
            ]
        }
    });
    return entry;
}
/**
 * This method validates that provided instrumentation info list is valid and also adds current library info to a list.
 * @param infoList {InstrumentationInfo} The array of InstrumentationInfo to be validated and updated.
 * @returns {InstrumentationInfo} The updated list of InstrumentationInfo.
 */ function validateAndUpdateInstrumentation(infoList) {
    const finalInfo = [];
    // First, iterate through given list of libraries and for each entry perform validations and transformations.
    // Limit amount of entries to be up to MAX_INSTRUMENTATION_COUNT
    let count = 1;
    for (const info of infoList){
        if (isValidInfo(info)) {
            finalInfo.push({
                name: truncateValue(info.name, maxDiagnosticValueLen),
                version: truncateValue(info.version, maxDiagnosticValueLen)
            });
            if (++count === exports.MAX_INSTRUMENTATION_COUNT) break;
        }
    }
    // Finally, add current library information to be the last entry added
    finalInfo.push({
        name: exports.NODEJS_LIBRARY_NAME_PREFIX,
        version: getNodejsLibraryVersion()
    });
    return finalInfo;
}
/**
 * A helper function to truncate a value (library name or version for example). The value is truncated
 * when it is longer than {maxLen} chars and '*' is added instead of truncated suffix.
 * @param value {object|string} The value to be truncated.
 * @param maxLen {number} The max length to be used for truncation.
 * @returns {string} The truncated value.
 */ function truncateValue(value, maxLen) {
    // Currently there are cases when we get here JSON object instead of string
    // Adding here additional validation to see if version still can be retrieved
    if (typeof value !== 'string') {
        try {
            if (Object.prototype.hasOwnProperty.call(value, 'version')) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                value = value.version;
            }
        } catch (err) {
        // Ignore error since flow should continue
        }
    }
    // Return NODEJS_DEFAULT_LIBRARY_VERSION if version cannot be retrieved
    if (typeof value !== 'string') {
        return exports.NODEJS_DEFAULT_LIBRARY_VERSION;
    }
    if (value && value.length > maxLen) {
        return value.substring(0, maxLen).concat('*');
    }
    return value;
}
/**
 * The helper function to retrieve current library version from annotated NODEJS_DEFAULT_LIBRARY_VERSION
 * @returns {string} A current library version.
 */ function getNodejsLibraryVersion() {
    return exports.NODEJS_DEFAULT_LIBRARY_VERSION;
}
/**
 * The helper function which checks if given InstrumentationInfo is valid.
 * @param info {InstrumentationInfo} The info to be validated.
 * @returns true if given info is valid, false otherwise
 */ function isValidInfo(info) {
    if (!info || !info.name || !info.version || !info.name.startsWith(exports.NODEJS_LIBRARY_NAME_PREFIX)) {
        return false;
    }
    return true;
}
/**
 * The helper method used to set a status of a flag which indicates if instrumentation info already written or not.
 * @param value {boolean} The value to be set.
 * @returns The value of the flag before it is set.
 */ function setInstrumentationStatus(value) {
    const status = global.instrumentationAdded;
    global.instrumentationAdded = value;
    return status;
} //# sourceMappingURL=instrumentation.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/log.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Log = void 0;
const promisify_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/promisify/build/src/index.js [app-rsc] (ecmascript)");
const dotProp = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/node_modules/dot-prop/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const entry_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/entry.js [app-rsc] (ecmascript)");
const instrumentation_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/instrumentation.js [app-rsc] (ecmascript)");
const log_common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/log-common.js [app-rsc] (ecmascript)");
/**
 * A log is a named collection of entries, each entry representing a timestamped
 * event. Logs can be produced by Google Cloud Platform services, by third-party
 * services, or by your applications. For example, the log `apache-access` is
 * produced by the Apache Web Server, but the log
 * `compute.googleapis.com/activity_log` is produced by Google Compute Engine.
 *
 * See {@link https://cloud.google.com/logging/docs/basic-concepts#logs|Introduction to Logs}
 *
 * @class
 *
 * @param {Logging} logging {@link Logging} instance.
 * @param {string} name Name of the log.
 * @param {object} [options] Configuration object.
 * @param {boolean} [options.removeCircular] Replace circular references in
 *     logged objects with a string value, `[Circular]`. (Default: false)
 * @param {number} [options.maxEntrySize] A max entry size
 * @param {string[]} [options.jsonFieldsToTruncate] A list of JSON properties at the given full path to be truncated.
 *     Received values will be prepended to predefined list in the order received and duplicates discarded.
 * @param {ApiResponseCallback} [options.defaultWriteDeleteCallback] A default global callback to be used for {@link Log#write}
 *     and {@link Log#delete} APIs when {@link ApiResponseCallback} callback was not supplied by caller in function parameters.
 *     Note that {@link LogOptions#defaultWriteDeleteCallback} is useful when {@link Log#write} and {@link Log#delete} APIs are called
 *     without `await` and without callback added explicitly to every call - this way {@link LogOptions#defaultWriteDeleteCallback}
 *     can serve as global callback handler, which for example could be used to catch all errors and eliminate crashes.
 * @param {boolean} [options.partialSuccess] Global flag indicating Whether a batch's valid entries should be written even if
 *     some other entry failed due to errors. Default is true.
 *     See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/entries/write#body.request_body.FIELDS.partial_success|partialSuccess} for more info.
 * @example
 * ```
 * import {Logging} from '@google-cloud/logging';
 * import {LogOptions} from '@google-cloud/logging/build/src/log';
 * const options: LogOptions = {
 *   maxEntrySize: 256,
 *   jsonFieldsToTruncate: [
 *     'jsonPayload.fields.metadata.structValue.fields.custom.stringValue',
 *   ],
 *   defaultWriteDeleteCallback: (err: any) => {
 *     if (err) {
 *       console.log('Error: ' + err);
 *     }
 *   },
 * };
 * const logging = new Logging();
 * const log = logging.log('syslog', options);
 * ```
 */ class Log {
    constructor(logging, name, options){
        var _a;
        options = options || {};
        this.formattedName_ = (0, log_common_1.formatLogName)(logging.projectId, name);
        this.removeCircular_ = options.removeCircular === true;
        this.maxEntrySize = options.maxEntrySize;
        this.logging = logging;
        /**
         * @name Log#name
         * @type {string}
         */ this.name = this.formattedName_.split('/').pop();
        this.jsonFieldsToTruncate = [
            // Winston:
            'jsonPayload.fields.metadata.structValue.fields.stack.stringValue',
            // Bunyan:
            'jsonPayload.fields.msg.stringValue',
            'jsonPayload.fields.err.structValue.fields.stack.stringValue',
            'jsonPayload.fields.err.structValue.fields.message.stringValue',
            // All:
            'jsonPayload.fields.message.stringValue'
        ];
        // Prepend all custom fields to be truncated to a list with defaults, thus
        // custom fields will be truncated first. Make sure to filter out fields
        // which are not in EntryJson.jsonPayload
        if (options.jsonFieldsToTruncate !== null && options.jsonFieldsToTruncate !== undefined) {
            const filteredList = options.jsonFieldsToTruncate.filter((str)=>str !== null && !this.jsonFieldsToTruncate.includes(str) && str.startsWith('jsonPayload'));
            const uniqueSet = new Set(filteredList);
            this.jsonFieldsToTruncate = Array.from(uniqueSet).concat(this.jsonFieldsToTruncate);
        }
        /**
         * The default callback for {@link Log#write} and {@link Log#delete} APIs
         * is going to be used only when {@link LogOptions#defaultWriteDeleteCallback}
         * was set by user and only for APIs which does not accept a callback as parameter
         */ this.defaultWriteDeleteCallback = options.defaultWriteDeleteCallback;
        /**
        Turning partialSuccess by default to be true if not provided in options. This should improve
        overall logging reliability since only oversized entries will be dropped
        from request. See {@link https://cloud.google.com/logging/quotas#log-limits} for more info
         */ this.partialSuccess = (_a = options.partialSuccess) !== null && _a !== void 0 ? _a : true;
    }
    alert(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'ALERT'), options);
    }
    critical(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'CRITICAL'), options);
    }
    debug(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'DEBUG'), options);
    }
    async delete(gaxOptions) {
        const projectId = await this.logging.auth.getProjectId();
        this.formattedName_ = (0, log_common_1.formatLogName)(projectId, this.name);
        const reqOpts = {
            logName: this.formattedName_
        };
        return this.logging.loggingService.deleteLog(reqOpts, gaxOptions, this.defaultWriteDeleteCallback);
    }
    emergency(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'EMERGENCY'), options);
    }
    entry(metadataOrData, data) {
        let metadata;
        if (!data && metadataOrData !== null && Object.prototype.hasOwnProperty.call(metadataOrData, 'httpRequest')) {
            // If user logs entry(metadata.httpRequest)
            metadata = metadataOrData;
            data = {};
        } else if (!data) {
            // If user logs entry(message)
            data = metadataOrData;
            metadata = {};
        } else {
            // If user logs entry(metadata, message)
            metadata = metadataOrData;
        }
        return this.logging.entry(metadata, data);
    }
    error(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'ERROR'), options);
    }
    async getEntries(opts) {
        const options = extend({}, opts);
        const projectId = await this.logging.auth.getProjectId();
        this.formattedName_ = (0, log_common_1.formatLogName)(projectId, this.name);
        if (options.filter && !options.filter.includes('logName=')) {
            options.filter = `(${options.filter}) AND logName="${this.formattedName_}"`;
        } else if (!options.filter) {
            options.filter = `logName="${this.formattedName_}"`;
        }
        return this.logging.getEntries(options);
    }
    /**
     * This method is a wrapper around {module:logging#getEntriesStream}, but with
     * a filter specified to only return {module:logging/entry} objects from this
     * log.
     *
     * @method Log#getEntriesStream
     * @param {GetEntriesRequest} [query] Query object for listing entries.
     * @returns {ReadableStream} A readable stream that emits {@link Entry}
     *     instances.
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     *
     * log.getEntriesStream()
     *   .on('error', console.error)
     *   .on('data', entry => {
     *     // `entry` is a Cloud Logging entry object.
     *     // See the `data` property to read the data from the entry.
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * log.getEntriesStream()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     * ```
     */ getEntriesStream(options) {
        options = extend({
            log: this.name
        }, options);
        return this.logging.getEntriesStream(options);
    }
    /**
     * This method is a wrapper around {module:logging#tailEntries}, but with
     * a filter specified to only return {module:logging/entry} objects from this
     * log.
     *
     * @method Log#tailEntries
     * @param {TailEntriesRequest} [query] Query object for tailing entries.
     * @returns {DuplexStream} A duplex stream that emits TailEntriesResponses
     * containing an array of {@link Entry} instances.
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     *
     * log.tailEntries()
     *   .on('error', console.error)
     *   .on('data', resp => {
     *     console.log(resp.entries);
     *     console.log(resp.suppressionInfo);
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * log.tailEntries()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     * ```
     */ tailEntries(options) {
        options = extend({
            log: this.name
        }, options);
        return this.logging.tailEntries(options);
    }
    info(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'INFO'), options);
    }
    notice(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'NOTICE'), options);
    }
    warning(entry, options) {
        return this.write((0, log_common_1.assignSeverityToEntries)(entry, 'WARNING'), options);
    }
    async write(entry, opts) {
        var _a, _b, _c;
        const options = opts ? opts : {};
        // Extract projectId & resource from Logging - inject & memoize if not.
        await this.logging.setProjectId();
        this.formattedName_ = (0, log_common_1.formatLogName)(this.logging.projectId, this.name);
        const resource = await this.getOrSetResource(options);
        // Extract & format additional context from individual entries. Make sure to add instrumentation info
        const info = (0, instrumentation_1.populateInstrumentationInfo)(entry);
        const decoratedEntries = this.decorateEntries(info[0]);
        // If instrumentation info was added or this.partialSuccess was set, make sure we set
        // partialSuccess in outgoing write request, so entire request will make it through and
        // only oversized entries will be dropped if any
        if (info[1] || ((_a = options.partialSuccess) !== null && _a !== void 0 ? _a : this.partialSuccess)) {
            options.partialSuccess = true;
        }
        this.truncateEntries(decoratedEntries);
        // Clobber `labels` and `resource` fields with WriteOptions from the user.
        const reqOpts = extend({
            logName: this.formattedName_,
            entries: decoratedEntries,
            resource
        }, options);
        delete reqOpts.gaxOptions;
        // Propagate maxRetries properly into writeLogEntries call
        if (!((_b = options.gaxOptions) === null || _b === void 0 ? void 0 : _b.maxRetries) && ((_c = this.logging.options) === null || _c === void 0 ? void 0 : _c.maxRetries)) {
            options.gaxOptions = extend({
                maxRetries: this.logging.options.maxRetries
            }, options.gaxOptions);
        }
        return this.logging.loggingService.writeLogEntries(reqOpts, options.gaxOptions, this.defaultWriteDeleteCallback);
    }
    /**
     * getOrSetResource looks for GCP service context first at the user
     * declaration level (snakecasing keys), then in the Logging instance,
     * before finally detecting a resource from the environment.
     * The resource is then memoized at the Logging instance level for future use.
     *
     * @param options
     * @private
     */ async getOrSetResource(options) {
        if (options.resource) {
            if (options.resource.labels) (0, log_common_1.snakecaseKeys)(options.resource.labels);
            return options.resource;
        }
        await this.logging.setDetectedResource();
        return this.logging.detectedResource;
    }
    /**
     * All entries are passed through here in order be formatted and serialized.
     * User provided Entry values are formatted per LogEntry specifications.
     * Read more about the LogEntry format:
     * https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry
     *
     * @private
     *
     * @param {object[]} entries - Entry objects.
     * @returns {object[]} Serialized entries.
     * @throws if there is an error during serialization.
     */ decorateEntries(entries) {
        return entries.map((entry)=>{
            if (!(entry instanceof entry_1.Entry)) {
                entry = this.entry(entry);
            }
            return entry.toJSON({
                removeCircular: this.removeCircular_
            }, this.logging.projectId);
        });
    }
    // TODO consider refactoring `truncateEntries` so that it does not mutate
    /**
     * Truncate log entries at maxEntrySize, so that error is not thrown, see:
     * https://cloud.google.com/logging/quotas
     *
     * @private
     *
     * @param {object|string} the JSON log entry.
     * @returns {object|string} truncated JSON log entry.
     */ truncateEntries(entries) {
        return entries.forEach((entry)=>{
            if (this.maxEntrySize === undefined) return;
            const payloadSize = JSON.stringify(entry).length;
            if (payloadSize < this.maxEntrySize) return;
            let delta = payloadSize - this.maxEntrySize;
            if (entry.textPayload) {
                entry.textPayload = entry.textPayload.slice(0, Math.max(entry.textPayload.length - delta, 0));
            } else {
                for (const field of this.jsonFieldsToTruncate){
                    const msg = dotProp.get(entry, field, '');
                    if (msg !== null && msg !== undefined && msg !== '') {
                        dotProp.set(entry, field, msg.slice(0, Math.max(msg.length - delta, 0)));
                        delta -= Math.min(msg.length, delta);
                        if (delta <= 0) {
                            break;
                        }
                    }
                }
            }
        });
    }
    // TODO: in a future breaking release, delete this extranenous function.
    /**
     * Return an array of log entries with the desired severity assigned.
     *
     * @private
     *
     * @param {object|object[]} entries - Log entries.
     * @param {string} severity - The desired severity level.
     */ static assignSeverityToEntries_(entries, severity) {
        return (0, log_common_1.assignSeverityToEntries)(entries, severity);
    }
    // TODO: in a future breaking release, delete this extranenous function.
    /**
     * Format the name of a log. A log's full name is in the format of
     * 'projects/{projectId}/logs/{logName}'.
     *
     * @private
     *
     * @returns {string}
     */ static formatName_(projectId, name) {
        return (0, log_common_1.formatLogName)(projectId, name);
    }
}
exports.Log = Log;
/*! Developer Documentation
 *
 * All async methods (except for streams) will call a callback in the event
 * that a callback is provided .
 */ (0, promisify_1.callbackifyAll)(Log, {
    exclude: [
        'entry',
        'getEntriesStream'
    ]
}); //# sourceMappingURL=log.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/log-sync.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LogSync = void 0;
const entry_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/entry.js [app-rsc] (ecmascript)");
const instrumentation_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/instrumentation.js [app-rsc] (ecmascript)");
const log_common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/log-common.js [app-rsc] (ecmascript)");
/**
 * A logSync is a named collection of entries in structured log format. In Cloud
 * Logging, structured logs refer to log entries that use the jsonPayload field
 * to add structure to their payloads. In most GCP environments, like GKE and
 * Cloud Functions, structured logs written to process.stdout are automatically
 * picked up and formatted by logging agents.
 *
 * Recommended for Serverless environment logging, especially where async log
 * calls made by the `Log` class can be dropped by the CPU.
 *
 * See {@link https://cloud.google.com/logging/docs/structured-logging|Structured Logging}
 *
 * @class
 *
 * @param {Logging} logging {@link Logging} instance.
 * @param {string} name Name of the logSync.
 * @param {Writable} [transport] transport A custom writable transport stream.
 *     Default: process.stdout.
 *
 * @example
 * ```
 * const {Logging} = require('@google-cloud/logging');
 * const logging = new Logging();
 * const log = logging.logSync('mylog');
 * ```
 */ class LogSync {
    // not projectId, formattedname is expected
    constructor(logging, name, transport, options){
        var _a;
        options = options || {};
        this.formattedName_ = (0, log_common_1.formatLogName)(logging.projectId, name);
        this.logging = logging;
        /**
         * @name Log#name
         * @type {string}
         */ this.name = this.formattedName_.split('/').pop();
        // Default to writing to stdout
        this.transport = transport || process.stdout;
        this.useMessageField_ = (_a = options.useMessageField) !== null && _a !== void 0 ? _a : true;
    }
    /**
     * Write a log entry with a severity of "ALERT".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.alert(entry);
     * ```
     */ alert(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'ALERT'), options);
    }
    /**
     * Write a log entry with a severity of "CRITICAL".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.critical(entry);
     * ```
     */ critical(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'CRITICAL'), options);
    }
    /**
     * Write a log entry with a severity of "DEBUG".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.debug(entry);
     * ```
     */ debug(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'DEBUG'), options);
    }
    /**
     * Write a log entry with a severity of "EMERGENCY".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.emergency(entry);
     * ```
     */ emergency(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'EMERGENCY'), options);
    }
    entry(metadataOrData, data) {
        let metadata;
        if (!data && metadataOrData !== null && Object.prototype.hasOwnProperty.call(metadataOrData, 'httpRequest')) {
            // If user logs entry(metadata.httpRequest)
            metadata = metadataOrData;
            data = {};
        } else if (!data) {
            // If user logs entry(message)
            data = metadataOrData;
            metadata = {};
        } else {
            // If user logs entry(metadata, message)
            metadata = metadataOrData;
        }
        return this.logging.entry(metadata, data);
    }
    /**
     * Write a log entry with a severity of "ERROR".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.error(entry);
     * ```
     */ error(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'ERROR'), options);
    }
    /**
     * Write a log entry with a severity of "INFO".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.info(entry);
     * ```
     */ info(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'INFO'), options);
    }
    /**
     * Write a log entry with a severity of "NOTICE".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.notice(entry);
     * ```
     */ notice(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'NOTICE'), options);
    }
    /**
     * Write a log entry with a severity of "WARNING".
     *
     * This is a simple wrapper around {@link LogSync#write}. All arguments are
     * the same as documented there.
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.logSync('my-log');
     *
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.warning(entry);
     * ```
     */ warning(entry, options) {
        this.write((0, log_common_1.assignSeverityToEntries)(entry, 'WARNING'), options);
    }
    /**
     * Write log entries to a custom transport (default: process.stdout).
     *
     * @param {Entry|Entry[]} entry A log entry, or array of entries, to write.
     * @param {?WriteOptions} [options] Write options
     *
     * @example
     * ```
     * const entry = log.entry('gce_instance', {
     *   instance: 'my_instance'
     * });
     *
     * log.write(entry);
     *
     * //-
     * // You may also pass multiple log entries to write.
     * //-
     * const secondEntry = log.entry('compute.googleapis.com', {
     *   user: 'my_username'
     * });
     *
     * log.write([entry, secondEntry]);
     *
     * //-
     * // To save some steps, you can also pass in plain values as your entries.
     * // Note, however, that you must provide a configuration object to specify
     * // the resource.
     * //-
     * const entries = [
     *   {
     *     user: 'my_username'
     *   },
     *   {
     *     home: process.env.HOME
     *   }
     * ];
     *
     * const options = {
     *   resource: 'compute.googleapis.com'
     * };
     *
     * log.write(entries, options);
     *
     * log.write(entries);
     * });
     * ```
     */ write(entry, opts) {
        var _a;
        const options = opts ? opts : {};
        // We expect projectId and resource to be set before this fn is called...
        let structuredEntries;
        this.formattedName_ = (0, log_common_1.formatLogName)(this.logging.projectId, this.name);
        try {
            // Make sure to add instrumentation info
            structuredEntries = (0, instrumentation_1.populateInstrumentationInfo)(entry)[0].map((entry)=>{
                if (!(entry instanceof entry_1.Entry)) {
                    entry = this.entry(entry);
                }
                return entry.toStructuredJSON(this.logging.projectId, this.useMessageField_);
            });
            for (const entry of structuredEntries){
                entry.logName = this.formattedName_;
                entry.resource = (0, log_common_1.snakecaseKeys)((_a = options.resource) === null || _a === void 0 ? void 0 : _a.labels) || entry.resource || this.logging.detectedResource;
                entry[entry_1.LABELS_KEY] = options.labels || entry[entry_1.LABELS_KEY];
                this.transport.write(JSON.stringify(entry) + '\n');
            }
        } catch (err) {
        // Ignore errors (client libraries do not panic).
        }
    }
}
exports.LogSync = LogSync; //# sourceMappingURL=log-sync.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/sink.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sink = void 0;
const promisify_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/promisify/build/src/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
/**
 * A sink is an object that lets you to specify a set of log entries to export
 * to a particular destination. Cloud Logging lets you export log entries
 * to destinations including Cloud Storage buckets (for long term log
 * storage), Google BigQuery datasets (for log analysis), Google Pub/Sub (for
 * streaming to other applications).
 *
 * See {@link https://cloud.google.com/logging/docs/basic-concepts#sinks|Introduction to Sinks}
 *
 * @class
 *
 * @param {Logging} logging {@link Logging} instance.
 * @param {string} name Name of the sink.
 *
 * @example
 * ```
 * const {Logging} = require('@google-cloud/logging');
 * const logging = new Logging();
 * const sink = logging.sink('my-sink');
 * ```
 */ class Sink {
    constructor(logging, name){
        this.logging = logging;
        /**
         * @name Sink#name
         * @type {string}
         */ this.name = name;
        this.formattedName_ = 'projects/' + logging.projectId + '/sinks/' + name;
    }
    create(config) {
        return this.logging.createSink(this.name, config);
    }
    async delete(gaxOptions) {
        const projectId = await this.logging.auth.getProjectId();
        this.formattedName_ = 'projects/' + projectId + '/sinks/' + this.name;
        const reqOpts = {
            sinkName: this.formattedName_
        };
        return this.logging.configService.deleteSink(reqOpts, gaxOptions);
    }
    async getMetadata(gaxOptions) {
        const projectId = await this.logging.auth.getProjectId();
        this.formattedName_ = 'projects/' + projectId + '/sinks/' + this.name;
        const reqOpts = {
            sinkName: this.formattedName_
        };
        [this.metadata] = await this.logging.configService.getSink(reqOpts, gaxOptions);
        return [
            this.metadata
        ];
    }
    setFilter(filter) {
        return this.setMetadata({
            filter
        });
    }
    async setMetadata(metadata) {
        const [currentMetadata] = await this.getMetadata();
        const uniqueWriterIdentity = metadata.uniqueWriterIdentity;
        delete metadata.uniqueWriterIdentity;
        let reqOpts = {
            sinkName: this.formattedName_,
            sink: extend({}, currentMetadata, metadata)
        };
        delete reqOpts.sink.gaxOptions;
        // Add user specified uniqueWriterIdentity boolean, if any.
        reqOpts = {
            ...reqOpts,
            ...uniqueWriterIdentity && {
                uniqueWriterIdentity
            }
        };
        [this.metadata] = await this.logging.configService.updateSink(reqOpts, metadata.gaxOptions);
        return [
            this.metadata
        ];
    }
}
exports.Sink = Sink;
/*! Developer Documentation
 *
 * All async methods (except for streams) will call a callbakc in the event
 * that a callback is provided.
 */ (0, promisify_1.callbackifyAll)(Sink); //# sourceMappingURL=sink.js.map
}}),
"[project]/node_modules/@google-cloud/logging/build/src/index.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.v2 = exports.protos = exports.Logging = exports.Sink = exports.LogSync = exports.formatLogName = exports.assignSeverityToEntries = exports.Severity = exports.Log = exports.Entry = exports.detectServiceContext = exports.middleware = void 0;
const common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/common/build/src/index.js [app-rsc] (ecmascript)");
const paginator_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/paginator/build/src/index.js [app-rsc] (ecmascript)");
const projectify_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/projectify/build/src/index.js [app-rsc] (ecmascript)");
const promisify_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/promisify/build/src/index.js [app-rsc] (ecmascript)");
const arrify = __turbopack_context__.r("[project]/node_modules/arrify/index.js [app-rsc] (ecmascript)");
const extend = __turbopack_context__.r("[project]/node_modules/extend/index.js [app-rsc] (ecmascript)");
const gax = __turbopack_context__.r("[project]/node_modules/google-gax/build/src/index.js [app-rsc] (ecmascript)");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const pumpify = __turbopack_context__.r("[project]/node_modules/pumpify/index.js [app-rsc] (ecmascript)");
const streamEvents = __turbopack_context__.r("[project]/node_modules/stream-events/index.js [app-rsc] (ecmascript)");
const middleware = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/middleware/index.js [app-rsc] (ecmascript)");
exports.middleware = middleware;
const metadata_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/metadata.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "detectServiceContext", {
    enumerable: true,
    get: function() {
        return metadata_1.detectServiceContext;
    }
});
const version = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/package.json (json)").version;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const v2 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/v2/index.js [app-rsc] (ecmascript)");
exports.v2 = v2;
const entry_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/entry.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Entry", {
    enumerable: true,
    get: function() {
        return entry_1.Entry;
    }
});
const log_common_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/utils/log-common.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Severity", {
    enumerable: true,
    get: function() {
        return log_common_1.Severity;
    }
});
Object.defineProperty(exports, "formatLogName", {
    enumerable: true,
    get: function() {
        return log_common_1.formatLogName;
    }
});
Object.defineProperty(exports, "assignSeverityToEntries", {
    enumerable: true,
    get: function() {
        return log_common_1.assignSeverityToEntries;
    }
});
const log_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/log.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Log", {
    enumerable: true,
    get: function() {
        return log_1.Log;
    }
});
const log_sync_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/log-sync.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "LogSync", {
    enumerable: true,
    get: function() {
        return log_sync_1.LogSync;
    }
});
const sink_1 = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/src/sink.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Sink", {
    enumerable: true,
    get: function() {
        return sink_1.Sink;
    }
});
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
/**
 * @typedef {object} ClientConfig
 * @property {string} [projectId] The project ID from the Google Developer's
 *     Console, e.g. 'grape-spaceship-123'. We will also check the environment
 *     variable `GCLOUD_PROJECT` for your project ID. If your app is running in
 *     an environment which supports {@link
 * https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application
 * Application Default Credentials}, your project ID will be detected
 * automatically.
 * @property {string} [keyFilename] Full path to the a .json, .pem, or .p12 key
 *     downloaded from the Google Developers Console. If you provide a path to a
 *     JSON file, the `projectId` option above is not necessary. NOTE: .pem and
 *     .p12 require you to specify the `email` option as well.
 * @property {string} [email] Account email address. Required when using a .pem
 *     or .p12 keyFilename.
 * @property {object} [credentials] Credentials object.
 * @property {string} [credentials.client_email]
 * @property {string} [credentials.private_key]
 * @property {boolean} [autoRetry=true] Automatically retry requests if the
 *     response is related to rate limits or certain intermittent server errors.
 *     We will exponentially backoff subsequent requests by default.
 * @property {number} [maxRetries=3] Maximum number of automatic retries
 *     attempted before returning the error.
 * @property {Constructor} [promise] Custom promise module to use instead of
 *     native Promises.
 */ /**
 * {@link https://cloud.google.com/logging/docs| Cloud Logging} allows you to
 * store, search, analyze, monitor, and alert on log data and events from Google
 * Cloud Platform and Amazon Web Services (AWS).
 *
 * @class
 *
 * See {@link https://cloud.google.com/logging/docs| What is Cloud Logging?}
 *
 * See {@link https://cloud.google.com/logging/docs/api| Introduction to the Cloud Logging API}
 *
 * See {@link https://www.npmjs.com/package/@google-cloud/logging-bunyan| Logging to Google Cloud from Bunyan}
 *
 * See {@link https://www.npmjs.com/package/@google-cloud/logging-winston| Logging to Google Cloud from Winston}
 *
 * @param {ClientConfig} [options] Configuration options.
 *
 * @example Import the client library
 * ```
 * const {Logging} = require('@google-cloud/logging');
 *
 * ```
 * @example Create a client that uses <a href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application Default Credentials (ADC)</a>:
 * ```
 * const logging = new Logging();
 *
 * ```
 * @example Create a client with <a href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicitcredentials</a>:
 * ```
 * const logging = new Logging({ projectId:
 *  'your-project-id', keyFilename: '/path/to/keyfile.json'
 * });
 *
 * ```
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:logging_quickstart
 * Full quickstart example:
 */ class Logging {
    constructor(options, gaxInstance){
        // Determine what scopes are needed.
        // It is the union of the scopes on all three clients.
        const scopes = [];
        const clientClasses = [
            v2.ConfigServiceV2Client,
            v2.LoggingServiceV2Client,
            v2.MetricsServiceV2Client
        ];
        for (const clientClass of clientClasses){
            for (const scope of clientClass.scopes){
                if (scopes.indexOf(scope) === -1) {
                    scopes.push(scope);
                }
            }
        }
        const options_ = extend({
            libName: 'gccl',
            libVersion: version,
            scopes
        }, options);
        this.api = {};
        this.auth = new (gaxInstance !== null && gaxInstance !== void 0 ? gaxInstance : gax).GoogleAuth(options_);
        this.options = options_;
        this.projectId = this.options.projectId || '{{projectId}}';
        this.configService = new v2.ConfigServiceV2Client(this.options, gaxInstance);
        this.loggingService = new v2.LoggingServiceV2Client(this.options, gaxInstance);
    }
    // jscs:disable maximumLineLength
    /**
     * Create a sink.
     *
     * See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks|Sink Overview}
     * See {@link https://cloud.google.com/logging/docs/view/advanced_filters|Advanced Logs Filters}
     * See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks/create|projects.sinks.create API Documentation}
     *
     * @param {string} name Name of the sink.
     * @param {CreateSinkRequest} config Config to set for the sink.
     * @param {CreateSinkCallback} [callback] Callback function.
     * @returns {Promise<CreateSinkResponse>}
     * @throws {Error} If a name is not provided.
     * @throws {Error} if a config object is not provided.
     * @see Sink#create
     *
     * @example
     * ```
     * const {Storage} = require('@google-cloud/storage');
     * const storage = new Storage({
     *   projectId: 'grape-spaceship-123'
     * });
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * const config = {
     *   destination: storage.bucket('logging-bucket'),
     *   filter: 'severity = ALERT'
     * };
     *
     * function callback(err, sink, apiResponse) {
     *   // `sink` is a Sink object.
     * }
     *
     * logging.createSink('new-sink-name', config, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logging.createSink('new-sink-name', config).then(data => {
     *   const sink = data[0];
     *   const apiResponse = data[1];
     * });
     *
     * ```
     * @example <caption>include:samples/sinks.js</caption>
     * region_tag:logging_create_sink
     * Another example:
     */ async createSink(name, config) {
        if (typeof name !== 'string') {
            throw new Error('A sink name must be provided.');
        }
        if (typeof config !== 'object') {
            throw new Error('A sink configuration object must be provided.');
        }
        if (common_1.util.isCustomType(config.destination, 'bigquery/dataset')) {
            await this.setAclForDataset_(config);
        }
        if (common_1.util.isCustomType(config.destination, 'pubsub/topic')) {
            await this.setAclForTopic_(config);
        }
        if (common_1.util.isCustomType(config.destination, 'storage/bucket')) {
            await this.setAclForBucket_(config);
        }
        const reqOpts = {
            parent: 'projects/' + this.projectId,
            sink: extend({}, config, {
                name
            }),
            uniqueWriterIdentity: config.uniqueWriterIdentity
        };
        delete reqOpts.sink.gaxOptions;
        delete reqOpts.sink.uniqueWriterIdentity;
        await this.setProjectId(reqOpts);
        const [resp] = await this.configService.createSink(reqOpts, config.gaxOptions);
        const sink = this.sink(resp.name);
        sink.metadata = resp;
        return [
            sink,
            resp
        ];
    }
    /**
     * Create an entry object.
     *
     * Using this method will not itself make any API requests. You will use
     * the object returned in other API calls, such as
     * {@link Log#write}.
     *
     * Note, {@link https://cloud.google.com/logging/quotas|Cloud Logging Quotas and limits}
     * dictates that the maximum log entry size, including all
     * [LogEntry Resource properties]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry},
     * cannot exceed _approximately_ 256 KB.
     *
     * See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry|LogEntry JSON representation}
     *
     * @param {?object|?string} [resource] See a
     *     [Monitored
     * Resource](https://cloud.google.com/logging/docs/reference/v2/rest/v2/MonitoredResource).
     * @param {object|string} data The data to use as the value for this log
     *     entry.
     * @returns {Entry}
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * const resource = {
     *   type: 'gce_instance',
     *   labels: {
     *     zone: 'global',
     *     instance_id: '3'
     *   }
     * };
     *
     * const entry = logging.entry(resource, {
     *   delegate: 'my_username'
     * });
     *
     * entry.toJSON();
     * // {
     * //   resource: {
     * //     type: 'gce_instance',
     * //     labels: {
     * //       zone: 'global',
     * //       instance_id: '3'
     * //     }
     * //   },
     * //   jsonPayload: {
     * //     delegate: 'my_username'
     * //   }
     * // }
     * ```
     */ entry(resource, data) {
        return new entry_1.Entry(resource, data);
    }
    async getEntries(opts) {
        const options = opts ? opts : {};
        // By default, sort entries by descending timestamp
        let reqOpts = extend({
            orderBy: 'timestamp desc'
        }, options);
        // By default, filter entries to last 24 hours only
        const time = new Date();
        time.setDate(time.getDate() - 1);
        const timeFilter = `timestamp >= "${time.toISOString()}"`;
        if (!options.filter) {
            reqOpts = extend({
                filter: timeFilter
            }, reqOpts);
        } else if (!options.filter.includes('timestamp')) {
            reqOpts.filter += ` AND ${timeFilter}`;
        }
        reqOpts.resourceNames = arrify(reqOpts.resourceNames);
        this.projectId = await this.auth.getProjectId();
        const resourceName = 'projects/' + this.projectId;
        if (reqOpts.resourceNames.indexOf(resourceName) === -1) {
            reqOpts.resourceNames.push(resourceName);
        }
        delete reqOpts.autoPaginate;
        delete reqOpts.gaxOptions;
        let gaxOptions = extend({
            autoPaginate: options.autoPaginate
        }, options.gaxOptions);
        if (options === null || options === void 0 ? void 0 : options.maxResults) {
            gaxOptions = extend({
                maxResults: options.maxResults
            }, gaxOptions);
        }
        const resp = await this.loggingService.listLogEntries(reqOpts, gaxOptions);
        const [entries] = resp;
        if (entries) {
            resp[0] = entries.map(entry_1.Entry.fromApiResponse_);
        }
        return resp;
    }
    /**
     * List the {@link Entry} objects in your logs as a readable object
     * stream.
     *
     * @method Logging#getEntriesStream
     * @param {GetEntriesRequest} [query] Query object for listing entries.
     * @returns {ReadableStream} A readable stream that emits {@link Entry}
     *     instances.
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getEntriesStream()
     *   .on('error', console.error)
     *   .on('data', entry => {
     *     // `entry` is a Cloud Logging entry object.
     *     // See the `data` property to read the data from the entry.
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getEntriesStream()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     * ```
     */ getEntriesStream(options = {}) {
        let requestStream;
        const userStream = streamEvents(pumpify.obj());
        userStream.abort = ()=>{
            if (requestStream) {
                requestStream.abort();
            }
        };
        const toEntryStream = new stream_1.Transform({
            objectMode: true,
            transform: (chunk, encoding, callback)=>{
                callback(null, entry_1.Entry.fromApiResponse_(chunk));
            }
        });
        userStream.once('reading', ()=>{
            this.auth.getProjectId().then((projectId)=>{
                this.projectId = projectId;
                if (options.log) {
                    if (options.filter) {
                        options.filter = `(${options.filter}) AND logName="${(0, log_common_1.formatLogName)(this.projectId, options.log)}"`;
                    } else {
                        options.filter = `logName="${(0, log_common_1.formatLogName)(this.projectId, options.log)}"`;
                    }
                    delete options.log;
                }
                const reqOpts = extend({
                    orderBy: 'timestamp desc'
                }, options);
                reqOpts.resourceNames = arrify(reqOpts.resourceNames);
                reqOpts.resourceNames.push(`projects/${this.projectId}`);
                delete reqOpts.autoPaginate;
                delete reqOpts.gaxOptions;
                const gaxOptions = extend({
                    autoPaginate: options.autoPaginate
                }, options.gaxOptions);
                let gaxStream;
                requestStream = streamEvents(new stream_1.PassThrough({
                    objectMode: true
                }));
                requestStream.abort = ()=>{
                    if (gaxStream && gaxStream.cancel) {
                        gaxStream.cancel();
                    }
                };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!global.GCLOUD_SANDBOX_ENV) {
                    requestStream.once('reading', ()=>{
                        try {
                            gaxStream = this.loggingService.listLogEntriesStream(reqOpts, gaxOptions);
                        } catch (error) {
                            requestStream.destroy(error);
                            return;
                        }
                        gaxStream.on('error', (err)=>{
                            requestStream.destroy(err);
                        }).pipe(requestStream);
                        return;
                    });
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(requestStream, toEntryStream);
            });
        });
        return userStream;
    }
    /**
     * Query object for streaming entries.
     *
     * @typedef {object} TailEntriesRequest
     * @property {Array.<string>|string} [resourceNames] Names of project
     *     resources to stream logs out of.
     * @property {string} [filter] An
     *     [advanced logs
     * filter](https://cloud.google.com/logging/docs/view/advanced_filters). An
     * empty filter matches all log entries.
     * @property {number} [bufferWindow=2] A setting to balance the tradeoff
     *     between viewing the log entries as they are being written and viewing
     *     them in ascending order.
     * @property {string} [log] A name of the log specifying to only return
     *     entries from this log.
     * @property {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/global.html#CallOptions.
     */ /**
     * Streaming read of live logs as log entries are ingested. Until the stream
     * is terminated, it will continue reading logs.
     *
     * @method Logging#tailEntries
     * @param {TailEntriesRequest} [query] Query object for tailing entries.
     * @returns {DuplexStream} A duplex stream that emits TailEntriesResponses
     * containing an array of {@link Entry} instances.
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.tailEntries()
     *   .on('error', console.error)
     *   .on('data', resp => {
     *     console.log(resp.entries);
     *     console.log(resp.suppressionInfo);
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getEntriesStream()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     * ```
     */ tailEntries(options = {}) {
        const userStream = streamEvents(pumpify.obj());
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let gaxStream;
        userStream.abort = ()=>{
            if (gaxStream && gaxStream.cancel) {
                gaxStream.cancel();
            }
        };
        const transformStream = new stream_1.Transform({
            objectMode: true,
            transform: (chunk, encoding, callback)=>{
                callback(null, (()=>{
                    const formattedEntries = [];
                    chunk.entries.forEach((entry)=>{
                        formattedEntries.push(entry_1.Entry.fromApiResponse_(entry));
                    });
                    const resp = {
                        entries: formattedEntries,
                        suppressionInfo: chunk.suppressionInfo
                    };
                    return resp;
                })());
            }
        });
        this.auth.getProjectId().then((projectId)=>{
            this.projectId = projectId;
            if (options.log) {
                if (options.filter) {
                    options.filter = `(${options.filter}) AND logName="${(0, log_common_1.formatLogName)(this.projectId, options.log)}"`;
                } else {
                    options.filter = `logName="${(0, log_common_1.formatLogName)(this.projectId, options.log)}"`;
                }
            }
            options.resourceNames = arrify(options.resourceNames);
            options.resourceNames.push(`projects/${this.projectId}`);
            const writeOptions = {
                resourceNames: options.resourceNames,
                ...options.filter && {
                    filter: options.filter
                },
                ...options.bufferWindow && {
                    bufferwindow: options.bufferWindow
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (!global.GCLOUD_SANDBOX_ENV) {
                gaxStream = this.loggingService.tailLogEntries(options.gaxOptions);
                // Write can only be called once in a single tail streaming session.
                gaxStream.write(writeOptions);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(gaxStream, transformStream);
            }
        });
        return userStream;
    }
    async getLogs(opts) {
        const options = opts ? opts : {};
        this.projectId = await this.auth.getProjectId();
        const reqOpts = extend({}, options, {
            parent: 'projects/' + this.projectId
        });
        delete reqOpts.autoPaginate;
        delete reqOpts.gaxOptions;
        const gaxOptions = extend({
            autoPaginate: options.autoPaginate
        }, options.gaxOptions);
        const resp = await this.loggingService.listLogs(reqOpts, gaxOptions);
        const [logs] = resp;
        if (logs) {
            resp[0] = logs.map((logName)=>this.log(logName));
        }
        return resp;
    }
    /**
     * List the {@link Log} objects in your project as a readable object stream.
     *
     * @method Logging#getLogsStream
     * @param {GetLogsRequest} [query] Query object for listing entries.
     * @returns {ReadableStream} A readable stream that emits {@link Log}
     *     instances.
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getLogsStream()
     *   .on('error', console.error)
     *   .on('data', log => {
     *     // `log` is a Cloud Logging log object.
     *   })
     *   .on('end', function() {
     *     // All logs retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getLogsStream()
     *   .on('data', log => {
     *     this.end();
     *   });
     * ```
     */ getLogsStream(options = {}) {
        options = options || {};
        let requestStream;
        const userStream = streamEvents(pumpify.obj());
        userStream.abort = ()=>{
            if (requestStream) {
                requestStream.abort();
            }
        };
        const toLogStream = new stream_1.Transform({
            objectMode: true,
            transform: (chunk, encoding, callback)=>{
                callback(null, this.log(chunk));
            }
        });
        userStream.once('reading', ()=>{
            this.auth.getProjectId().then((projectId)=>{
                this.projectId = projectId;
                const reqOpts = extend({}, options, {
                    parent: 'projects/' + this.projectId
                });
                delete reqOpts.gaxOptions;
                const gaxOptions = extend({
                    autoPaginate: options.autoPaginate
                }, options.gaxOptions);
                let gaxStream;
                requestStream = streamEvents(new stream_1.PassThrough({
                    objectMode: true
                }));
                requestStream.abort = ()=>{
                    if (gaxStream && gaxStream.cancel) {
                        gaxStream.cancel();
                    }
                };
                requestStream.once('reading', ()=>{
                    try {
                        gaxStream = this.loggingService.listLogsStream(reqOpts, gaxOptions);
                    } catch (error) {
                        requestStream.destroy(error);
                        return;
                    }
                    gaxStream.on('error', (err)=>{
                        requestStream.destroy(err);
                    }).pipe(requestStream);
                    return;
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(requestStream, toLogStream);
            });
        });
        return userStream;
    }
    async getSinks(opts) {
        const options = opts ? opts : {};
        this.projectId = await this.auth.getProjectId();
        const reqOpts = extend({}, options, {
            parent: 'projects/' + this.projectId
        });
        delete reqOpts.autoPaginate;
        delete reqOpts.gaxOptions;
        const gaxOptions = extend({
            autoPaginate: options.autoPaginate
        }, options.gaxOptions);
        const resp = await this.configService.listSinks(reqOpts, gaxOptions);
        const [sinks] = resp;
        if (sinks) {
            resp[0] = sinks.map((sink)=>{
                const sinkInstance = this.sink(sink.name);
                sinkInstance.metadata = sink;
                return sinkInstance;
            });
        }
        return resp;
    }
    /**
     * Get the {@link Sink} objects associated with this project as a
     * readable object stream.
     *
     * @method Logging#getSinksStream
     * @param {GetSinksRequest} [query] Query object for listing sinks.
     * @returns {ReadableStream} A readable stream that emits {@link Sink}
     *     instances.
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getSinksStream()
     *   .on('error', console.error)
     *   .on('data', sink => {
     *     // `sink` is a Sink object.
     *   })
     *   .on('end', function() {
     *     // All sinks retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getSinksStream()
     *   .on('data', function(sink) {
     *     this.end();
     *   });
     * ```
     */ getSinksStream(options) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        options = options || {};
        let requestStream;
        const userStream = streamEvents(pumpify.obj());
        userStream.abort = ()=>{
            if (requestStream) {
                requestStream.abort();
            }
        };
        const toSinkStream = new stream_1.Transform({
            objectMode: true,
            transform: (chunk, encoding, callback)=>{
                const sinkInstance = self.sink(chunk.name);
                sinkInstance.metadata = chunk;
                callback(null, sinkInstance);
            }
        });
        userStream.once('reading', ()=>{
            this.auth.getProjectId().then((projectId)=>{
                this.projectId = projectId;
                const reqOpts = extend({}, options, {
                    parent: 'projects/' + self.projectId
                });
                delete reqOpts.gaxOptions;
                const gaxOptions = extend({
                    autoPaginate: options.autoPaginate
                }, options.gaxOptions);
                let gaxStream;
                requestStream = streamEvents(new stream_1.PassThrough({
                    objectMode: true
                }));
                requestStream.abort = ()=>{
                    if (gaxStream && gaxStream.cancel) {
                        gaxStream.cancel();
                    }
                };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!global.GCLOUD_SANDBOX_ENV) {
                    requestStream.once('reading', ()=>{
                        try {
                            gaxStream = this.configService.listSinksStream(reqOpts, gaxOptions);
                        } catch (error) {
                            requestStream.destroy(error);
                            return;
                        }
                        gaxStream.on('error', (err)=>{
                            requestStream.destroy(err);
                        }).pipe(requestStream);
                        return;
                    });
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(requestStream, toSinkStream);
            });
        });
        return userStream;
    }
    /**
     * Get a reference to a Cloud Logging log.
     *
     * See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.logs|Log Overview}
     *
     * @param {string} name Name of the existing log.
     * @param {object} [options] Configuration object.
     * @param {boolean} [options.removeCircular] Replace circular references in
     *     logged objects with a string value, `[Circular]`. (Default: false)
     * @returns {Log}
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     * ```
     */ log(name, options) {
        return new log_1.Log(this, name, options);
    }
    /**
     * Get a reference to a Cloud Logging logSync.
     *
     * @param {string} name Name of the existing log.
     * @param {object} transport An optional write stream.
     * @param {LogSyncOptions} options An optional configuration object.
     * @returns {LogSync}
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * // Optional: enrich logs with additional context
     * await logging.setProjectId();
     * await logging.setDetectedResource();
     *
     * // Default transport writes to process.stdout
     * const log = logging.logSync('my-log');
     * ```
     */ logSync(name, transport, options) {
        return new log_sync_1.LogSync(this, name, transport, options);
    }
    /**
     * Get a reference to a Cloud Logging sink.
     *
     * See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks|Sink Overview}
     *
     * @param {string} name Name of the existing sink.
     * @returns {Sink}
     *
     * @example
     * ```
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const sink = logging.sink('my-sink');
     * ```
     */ sink(name) {
        return new sink_1.Sink(this, name);
    }
    /**
     * Funnel all API requests through this method, to be sure we have a project
     * ID.
     *
     * @param {object} config Configuration object.
     * @param {object} config.gaxOpts GAX options.
     * @param {function} config.method The gax method to call.
     * @param {object} config.reqOpts Request options.
     * @param {function} [callback] Callback function.
     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
    request(config, callback) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const isStreamMode = !callback;
        let gaxStream;
        let stream;
        if (isStreamMode) {
            stream = streamEvents(new stream_1.PassThrough({
                objectMode: true
            }));
            stream.abort = ()=>{
                if (gaxStream && gaxStream.cancel) {
                    gaxStream.cancel();
                }
            };
            stream.once('reading', makeRequestStream);
        } else {
            makeRequestCallback();
        }
        function prepareGaxRequest(callback) {
            self.auth.getProjectId((err, projectId)=>{
                if (err) {
                    callback(err);
                    return;
                }
                self.projectId = projectId;
                let gaxClient = self.api[config.client];
                if (!gaxClient) {
                    // Lazily instantiate client.
                    gaxClient = new v2[config.client](self.options);
                    self.api[config.client] = gaxClient;
                }
                let reqOpts = extend(true, {}, config.reqOpts);
                reqOpts = (0, projectify_1.replaceProjectIdToken)(reqOpts, projectId);
                const requestFn = gaxClient[config.method].bind(gaxClient, reqOpts, config.gaxOpts);
                callback(null, requestFn);
            });
        }
        function makeRequestCallback() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (global.GCLOUD_SANDBOX_ENV) {
                return;
            }
            prepareGaxRequest((err, requestFn)=>{
                if (err) {
                    callback(err);
                    return;
                }
                requestFn(callback);
            });
        }
        function makeRequestStream() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (global.GCLOUD_SANDBOX_ENV) {
                return new stream_1.PassThrough({
                    objectMode: true
                });
            }
            prepareGaxRequest((err, requestFn)=>{
                if (err) {
                    stream.destroy(err);
                    return;
                }
                gaxStream = requestFn();
                gaxStream.on('error', (err)=>{
                    stream.destroy(err);
                }).pipe(stream);
            });
            return;
        }
        return stream;
    }
    /**
     * This method is called when creating a sink with a Bucket destination. The
     * bucket must first grant proper ACL access to the Cloud Logging
     * account.
     *
     * The parameters are the same as what {@link Logging#createSink} accepts.
     *
     * @private
     */ async setAclForBucket_(config) {
        const bucket = config.destination;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        await bucket.acl.owners.addGroup('cloud-logs@google.com');
        config.destination = 'storage.googleapis.com/' + bucket.name;
    }
    /**
     * This method is called when creating a sink with a Dataset destination. The
     * dataset must first grant proper ACL access to the Cloud Logging
     * account.
     *
     * The parameters are the same as what {@link Logging#createSink} accepts.
     *
     * @private
     */ async setAclForDataset_(config) {
        const dataset = config.destination;
        const [metadata] = await dataset.getMetadata();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const access = [].slice.call(arrify(metadata.access));
        access.push({
            role: 'WRITER',
            groupByEmail: 'cloud-logs@google.com'
        });
        await dataset.setMetadata({
            access
        });
        const baseUrl = 'bigquery.googleapis.com';
        const pId = dataset.parent.projectId;
        const dId = dataset.id;
        config.destination = `${baseUrl}/projects/${pId}/datasets/${dId}`;
    }
    /**
     * This method is called when creating a sink with a Topic destination. The
     * topic must first grant proper ACL access to the Cloud Logging
     * account.
     *
     * The parameters are the same as what {@link Logging#createSink} accepts.
     *
     * @private
     */ async setAclForTopic_(config) {
        const topic = config.destination;
        const [policy] = await topic.iam.getPolicy();
        policy.bindings = arrify(policy.bindings);
        policy.bindings.push({
            role: 'roles/pubsub.publisher',
            members: [
                'serviceAccount:cloud-logs@system.gserviceaccount.com'
            ]
        });
        await topic.iam.setPolicy(policy);
        const baseUrl = 'pubsub.googleapis.com';
        const topicName = topic.name;
        config.destination = `${baseUrl}/${topicName}`;
    }
    /**
     * setProjectId detects and sets a projectId string on the Logging instance.
     * It can be invoked once to ensure ensuing LogSync entries have a projectID.
     * @param reqOpts
     */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setProjectId(reqOpts) {
        if (this.projectId === '{{projectId}}') this.projectId = await this.auth.getProjectId();
        if (reqOpts) reqOpts = (0, projectify_1.replaceProjectIdToken)(reqOpts, this.projectId);
    }
    /**
     * setResource detects and sets a detectedresource object on the Logging
     * instance. It can be invoked once to ensure ensuing LogSync entries contain
     * resource context.
     */ async setDetectedResource() {
        if (!this.detectedResource) {
            this.detectedResource = await (0, metadata_1.getDefaultResource)(this.auth);
        }
    }
}
exports.Logging = Logging;
/*! Developer Documentation
 * All async methods (except for streams) will execute a callback in the event
 * that a callback is provided.
 */ (0, promisify_1.callbackifyAll)(Logging, {
    exclude: [
        'request'
    ]
});
/*! Developer Documentation
 *
 * These methods can be auto-paginated.
 */ paginator_1.paginator.extend(Logging, [
    'getEntries',
    'getLogs',
    'getSinks'
]);
/**
 * Reference to the low-level auto-generated clients for the V2 Logging service.
 *
 * @type {object}
 * @property {constructor} LoggingServiceV2Client
 *   Reference to {@link v2.LoggingServiceV2Client}
 * @property {constructor} ConfigServiceV2Client
 *   Reference to {@link v2.ConfigServiceV2Client}
 * @property {constructor} MetricsServiceV2Client
 *   Reference to {@link v2.MetricsServiceV2Client}
 */ module.exports.v2 = v2;
const protos = __turbopack_context__.r("[project]/node_modules/@google-cloud/logging/build/protos/protos.js [app-rsc] (ecmascript)");
exports.protos = protos;
__exportStar(__turbopack_context__.r("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)"), exports); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_%40google-cloud_logging_build_src_c1658694._.js.map